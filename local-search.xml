<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CPP异常处理和异常安全</title>
    <link href="/2023/05/13/CPP%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%92%8C%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8/"/>
    <url>/2023/05/13/CPP%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%92%8C%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="《C-异常处理和异常安全》"><a href="#《C-异常处理和异常安全》" class="headerlink" title="《C++异常处理和异常安全》"></a>《C++异常处理和异常安全》</h2><p>如何写一个安全的拷贝字符串的函数？</p><p>which is better?</p><ul><li>terminate the program on failure and report the error</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">strcpy</span><span class="hljs-params">(cahr *dest, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *source)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!dest || !source)&#123;<br>        std :: cerr &lt;&lt; <span class="hljs-string">&quot;invalud arguments for strcpy.\n&quot;</span>;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(*source)&#123;<br>        *dest ++ = *source ++;<br>        *dest = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>return false on failure</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">strcpy</span><span class="hljs-params">(<span class="hljs-type">char</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* source)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (!dest || !source) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">while</span>(*source)<br>        *dest ++ = *source ++;<br>    *dest = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>be silent to errors</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">strcpy</span><span class="hljs-params">(<span class="hljs-type">char</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* source)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(dest &amp;&amp; source)&#123;<br>        <span class="hljs-keyword">while</span>(*source)<br>            *dest ++ = *source ++;<br>        *dest = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>use assertions</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">strcpy</span><span class="hljs-params">(<span class="hljs-type">char</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *source)</span></span>&#123;<br>    <span class="hljs-built_in">assert</span>(dest != null);<br>    <span class="hljs-built_in">assert</span>(source != null);<br>    <span class="hljs-keyword">while</span>(*source)<br>        *dest ++ = *source ++;<br>    *dest = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ol><li><h3 id="throw-an-exception"><a href="#throw-an-exception" class="headerlink" title="throw an exception"></a>throw an exception</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">strcpy</span><span class="hljs-params">(<span class="hljs-type">char</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *source)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!dest || !source)<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;异常: null pointer passed to strcpy.&quot;</span>);<br>    <span class="hljs-keyword">while</span>(*source)<br>        *dest ++ = *source ++;<br>    *dest = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><h3 id="标准exception"><a href="#标准exception" class="headerlink" title="标准exception"></a>标准exception</h3></li></ol><ul><li><p>the <code>new</code> and <code>new[]</code> 操作输出标准异常 <code>std :: bad_alloc</code> when running out of memory.</p></li><li><p><code>dynamic_cast</code> 对于引用输出标准异常 <code>std::bad_cast</code> when the casting fails.</p><ul><li><p><code>dynamic_cast</code>对于指针不会输出异常，而是返回 <code>nullptr</code>.</p></li><li><p>补充<code>dynamic_cast</code>用法：C++中用于将基类指针或引用转换为派生类指针或引用的运算符。它可以在运行时进行类型检查，并在安全的情况下将指针或引用转换为派生类指针或引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">dynamic_cast</span>&lt;new_type&gt;(expression)<br><span class="hljs-comment">//new_type表示要转换的目标类型，expression表示要转换的源类型指针或引用</span><br><span class="hljs-comment">// 注意以下几点：</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1. 要转换的源类型必须是多态类型，即该类型至少有一个虚函数</span><br><span class="hljs-comment">2. 转换的目标类型必须是类类型，泵你是基本类型</span><br><span class="hljs-comment">3. 如果转换失败，dynamic_cast将返回空指针，或抛出bad_cast异常（对于引用转换）</span><br><span class="hljs-comment">*/</span><br>    <br><span class="hljs-comment">/* 在下面这个示例中，首先创建了一个Derived类的对象，并将其指针赋给一个Base类的指针。然后使用dynamic_cast将该指针转换为Derived类的指针，并判断转换是否成功。由于Derived类是Base类的派生类，并且有自己的虚函数，因此可以使用dynamic_cast进行类型转换。最后，如果转换成功，则调用Derived类中的print函数输出“This is Derived class.”，否则输出“Cast failed.”。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;This is Base class.&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;This is Derived class.&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Base* ptr_base = <span class="hljs-keyword">new</span> Derived;<br>    Derived* ptr_derived = <span class="hljs-built_in">dynamic_cast</span>&lt;Derived*&gt;(ptr_base);<br><br>    <span class="hljs-keyword">if</span> (ptr_derived != <span class="hljs-literal">nullptr</span>) &#123;<br>        ptr_derived-&gt;<span class="hljs-built_in">print</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Cast failed.&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">delete</span> ptr_base;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>STL容器不会检查边界，但是<code>at()</code>函数会</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-type">int</span>&gt; v;<br>v.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>) = <span class="hljs-number">42</span>; <span class="hljs-comment">// throws std :: out_of_range</span><br>v[<span class="hljs-number">0</span>] = <span class="hljs-number">42</span>; <span class="hljs-comment">// 不会报异常，但可能会报 segmentation fault</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">const</span> T &amp;<span class="hljs-title">at</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> n)</span> <span class="hljs-type">const</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(n &gt;= m_size)<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;array subscript out of range.&quot;</span>);<br>        <span class="hljs-keyword">return</span> m_data[n];<br>    &#125;<br>    <span class="hljs-function">T &amp;<span class="hljs-title">at</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">const_cast</span>&lt;T &amp;&gt;(<br>        <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-type">const</span> Array&lt;T&gt; *&gt;(<span class="hljs-keyword">this</span>) -&gt; <span class="hljs-built_in">at</span>(n);<br>        );<br>    &#125;;<br>    <span class="hljs-comment">//...</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>补充<code>static_cast</code>用法：用于静态类型转换，可以将一种类型的值转换为另一种类型，前提是两种类型之间存在着某种隐式转换的关系或者存在可识别的转换方式</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">static_cast</span>&lt;new_type&gt; (expression);<br><span class="hljs-comment">// new_type表示要转换的目标类型，expression表示要转换的源类型</span><br><span class="hljs-comment">//eg1:</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<br><span class="hljs-type">double</span> d = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(i);<br><span class="hljs-comment">//eg2:</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> *p = &amp;i;<br><span class="hljs-type">void</span> *q = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">void</span>* &gt;(p); <span class="hljs-comment">//将int* 转化为void *</span><br><span class="hljs-comment">//eg3:</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>&#123;&#125;<br>&#125;;<br>Derived d;<br>Base* pb = <span class="hljs-built_in">static_cast</span>&lt;Base*&gt;(&amp;d); <span class="hljs-comment">// 将Derived* 转换为Base* 类型</span><br></code></pre></td></tr></table></figure><ul><li>补充<code>const_cast</code>用法：用于移除表达式中<code>const</code>或<code>volatile</code>属性的运算符，它可以将<code>const</code>或<code>volatile</code>指针或引用转换为<code>non-const</code>或<code>non-volatile</code>指针或引用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">const_cast</span>&lt;new_type&gt;(expression);<br><span class="hljs-comment">//new_type表示要转换的目标类型，expression表示要转换的源类型指针或引用。</span><br><span class="hljs-comment">// eg1:</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> * ptr_const = &amp;n;<br><span class="hljs-type">int</span> * ptr_nonconst = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(ptr_const);<br>*ptr_nonconst = <span class="hljs-number">20</span>;<br>cout &lt;&lt; n &lt;&lt; *ptr_const &lt;&lt; *ptr_nonconst &lt;&lt; endl;<br><span class="hljs-comment">// 10 20 20 </span><br><span class="hljs-comment">//首先定义了一个const int类型的变量n，并将其地址赋给一个const int类型的指针ptr_const。</span><br><span class="hljs-comment">//然后使用const_cast将ptr_const转换为一个int类型的指针ptr_nonconst，并通过ptr_nonconst修改了n的值。</span><br><span class="hljs-comment">//注意，由于n是一个常量，如果直接对其进行修改是非法的。但是，由于使用了const_cast，</span><br><span class="hljs-comment">//我们绕过了const属性的限制，程序可以成功执行，并输出“*ptr_const = 20”和“*ptr_nonconst = 20”。</span><br></code></pre></td></tr></table></figure><h3 id="3-try-catch实例"><a href="#3-try-catch实例" class="headerlink" title="3.try-catch实例"></a>3.try-catch实例</h3><ul><li><p>stack unwinding is only guaranteed to happen for caught exceptions . if an exception is not caught, whether the stack is unwound is implementation-defined.</p></li><li><p>operator new[] raises <code>std::bad_alloc</code> when out of memory. but if the array-new length is obvisouly invalid, an instance of <code>std::bad_array_new_length</code> is raised. <code>catch(const std::bad_alloc &amp;)</code> also catches it, because of inheritance: </p><p><code>exception &lt;--- bad_alloc &lt; --- bad_array_new_length</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-built_in">do_something</span>();<br>&#125; <span class="hljs-built_in">catch</span>(<span class="hljs-type">const</span> std :: runtime_error &amp;re)&#123;<br>    <span class="hljs-comment">// 处理runtime_error</span><br>&#125; <span class="hljs-built_in">catch</span>(<span class="hljs-type">const</span> std :: exception &amp;e)&#123;<br>    <span class="hljs-comment">//处理 other kinds of exception</span><br>&#125; <span class="hljs-built_in">catch</span>(...)&#123;<br>    <span class="hljs-comment">// deal with other things</span><br>&#125;<br><span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;i don&#x27;t want to talk to you.&quot;</span>;<br></code></pre></td></tr></table></figure></li><li><p>try-catch for 构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Array</span>(std::<span class="hljs-type">size_t</span> n)<br>        <span class="hljs-keyword">try</span> : <span class="hljs-built_in">m_size</span>(n), <span class="hljs-built_in">m_data</span>(<span class="hljs-keyword">new</span> T[n] &#123;&#125;) &#123;&#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::bad_alloc &amp;ba)&#123;<br>        std :: cerr &lt;&lt; <span class="hljs-string">&quot;no enougt memory.\n&quot;</span>;<br>        <span class="hljs-keyword">throw</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-用户自定义异常类型"><a href="#4-用户自定义异常类型" class="headerlink" title="4. 用户自定义异常类型"></a>4. 用户自定义异常类型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Wrong_answer</span> : <span class="hljs-keyword">public</span> std :: logic_error&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Wrong_answer</span>(std::<span class="hljs-type">size_t</span> line_no) : std :: <span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;Wrong answer on line&quot;</span><br>        + std :: <span class="hljs-built_in">to_string</span>(line_no)) &#123;&#125;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> assert(X)&#123;</span><br><span class="hljs-keyword">if</span>(!(X)) <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Wrong_answer</span>(__LINE__);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a + b + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-built_in">rand</span>(), b = <span class="hljs-built_in">rand</span>();<br>    <span class="hljs-type">int</span> ans = <span class="hljs-built_in">add</span>(a + b);<br>    <span class="hljs-built_in">assert</span>(ans == a + b);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="noexcept关键字"><a href="#noexcept关键字" class="headerlink" title="noexcept关键字"></a><code>noexcept</code>关键字</h3><p>为了让编译器做更好的优化。</p><ul><li><p>当一个异常在一个<code>noexcept</code>的函数中被抛出的时候，调用栈<strong>可能</strong>会展开</p></li><li><p>一些函数必须声明为<code>noexcept</code>，以便于能被标准库调用，如移动构造函数和移动赋值运算符。</p></li><li><p>不会在编译期检查</p></li><li><p><code>noexcept</code> 会接收一个参数，该参数必须是编译期的<code>bool</code>值，必须是一个<code>常量表达式</code></p></li><li><p><code>noexcept</code> 等价于 <code>noexcept(true)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">std :: is_nothrow_copy_constructible&lt;T&gt; :: value&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-comment">// ...</span></span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br></code></pre></td></tr></table></figure></li><li><p><code>noexcept</code> can also work as an operator, which returns a bool value indicating whether an expression throws exceptions</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span>&#123;<br>    T thing;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Box&lt;T&gt; &amp;other)</span></span><br><span class="hljs-function">            <span class="hljs-title">noexcept</span><span class="hljs-params">(<span class="hljs-keyword">noexcept</span>(std::swap(thing, other.thing)))</span></span><br><span class="hljs-function">        </span>&#123;<br>            std::<span class="hljs-built_in">swap</span>(thing, other.thing);<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h3 id="5-exception-safety"><a href="#5-exception-safety" class="headerlink" title="5.exception safety"></a>5.exception safety</h3><h4 id="example1-it-doesn’t-offer-even-the-basic-guarantee"><a href="#example1-it-doesn’t-offer-even-the-basic-guarantee" class="headerlink" title="example1: it doesn’t offer even the basic guarantee."></a>example1: <strong>it doesn’t offer even the basic guarantee.</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span>&#123;<br>    <span class="hljs-type">int</span> *m_data;<br>    std :: <span class="hljs-type">size_t</span> m_size;<br>    <span class="hljs-keyword">public</span>:<br>    Array &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Array &amp;other)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> != &amp;other)&#123;<br>            <span class="hljs-keyword">delete</span>[] m_data;<br>            m_data = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[other.m_size];<br>            std::<span class="hljs-built_in">copy</span>(other.m_data, other.m_data + other.m_size, m_data);<br>            m_size = other.m_size;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="example2-strong-guarantee"><a href="#example2-strong-guarantee" class="headerlink" title="example2: strong guarantee."></a>example2: <strong>strong guarantee.</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    Array &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Array &amp;other)&#123;<br>        <span class="hljs-keyword">auto</span> new_data = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[other.m_size];<br>        std::<span class="hljs-built_in">copy</span>(other.m_data, other.m_data + other.m_size, new_data);<br>        <span class="hljs-keyword">delete</span> [] m_data;<br>        m_data = new_data;<br>        m_size = other.m_size;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="example3-no-exception-safety-guarantee"><a href="#example3-no-exception-safety-guarantee" class="headerlink" title="example3:  no exception-safety guarantee"></a>example3:  <strong>no exception-safety guarantee</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    Array &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Array &amp;other) &#123;<br>        m_size = other.m_size;<br>        <span class="hljs-keyword">auto</span> new_data = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[m_size];<br>        std::<span class="hljs-built_in">copy</span>(other.m_data,<br>        other.m_data + m_size, new_data);<br>        <span class="hljs-keyword">delete</span>[] m_data;<br>        m_data = new_data;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="example4-strong-guarantee"><a href="#example4-strong-guarantee" class="headerlink" title="example4:  strong guarantee"></a>example4:  <strong>strong guarantee</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Array &amp;other)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        <span class="hljs-keyword">using</span> std::swap;<br>        <span class="hljs-built_in">swap</span>(m_size, other.m_size);<br>        <span class="hljs-built_in">swap</span>(m_data, other.m_data);<br>    &#125;<br>    Array &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Array &amp;other) &#123;<br>    <span class="hljs-built_in">Array</span>(other).<span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="example5-no-guarantee"><a href="#example5-no-guarantee" class="headerlink" title="example5:  no guarantee"></a>example5:  <strong>no guarantee</strong></h4><p>if an exception occurs when copying, m_size and m_data will be destroyed, resulting in <em>memory leak</em>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Array</span>(<span class="hljs-type">const</span> Array &amp;other)<br>    : <span class="hljs-built_in">m_data</span>(<span class="hljs-keyword">new</span> T[other.m_size]),<br>    <span class="hljs-built_in">m_size</span>(other.m_size) &#123;<br>    std::<span class="hljs-built_in">copy</span>(other.m_data,<br>    other.m_data + other.m_size, m_data);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="example6-no-guarantee"><a href="#example6-no-guarantee" class="headerlink" title="example6: no guarantee"></a>example6: <strong>no guarantee</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    Array &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Array &amp;other) &#123;<br>    <span class="hljs-keyword">auto</span> new_data = <span class="hljs-keyword">new</span> T[other.m_size];<br>    std::<span class="hljs-built_in">copy</span>(other.m_data,<br>    other.m_data + other.m_size, new_data);<br>    <span class="hljs-keyword">delete</span>[] m_data;<br>    m_data = new_data;<br>    m_size = other.m_size;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="example7-strong-guarantee"><a href="#example7-strong-guarantee" class="headerlink" title="example7: strong guarantee"></a>example7: <strong>strong guarantee</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Array &amp;other)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        <span class="hljs-keyword">using</span> std::swap;<br>        <span class="hljs-built_in">swap</span>(m_size, other.m_size);<br>        <span class="hljs-built_in">swap</span>(m_data, other.m_data);<br>        &#125;<br>    Array &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Array &amp;other) &#123;<br>        <span class="hljs-built_in">Array</span>(other).<span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><p>参考： Gkxx</p>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP移动语义和完美转发</title>
    <link href="/2023/05/03/CPP%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E5%92%8C%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"/>
    <url>/2023/05/03/CPP%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E5%92%8C%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h3 id="《C-移动语义和完美转发》"><a href="#《C-移动语义和完美转发》" class="headerlink" title="《C++移动语义和完美转发》"></a>《C++移动语义和完美转发》</h3><p>定义一个类的时候，我们显式地或隐式地指定在此类型的对象拷贝、移动、赋值和销毁时做什么。</p><ol><li>拷贝构造函数</li><li>拷贝赋值运算符</li><li>移动构造函数</li><li>移动赋值运算符</li><li>析构函数</li></ol><p>1&amp;3定义了当用同类型地的另一个对象初始化本对象时做什么</p><p>2&amp;4定义了将一个对象赋予同类型的另一个对象时做什么</p><p>5定义了当此类型对象销毁时做什么</p><ol><li><strong>拷贝构造函数</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Foo</span>(); <span class="hljs-comment">//默认构造函数</span><br>    <span class="hljs-built_in">Foo</span>(<span class="hljs-type">const</span> Foo&amp;); <span class="hljs-comment">//拷贝构造函数</span><br>&#125;;<span class="hljs-comment">//拷贝构造函数的第一个参数必须是一个引用类型（可以定义一个接受非const引用的拷贝构造函数），拷贝构造函数在几种情况下都会隐式地使用，因此拷贝构造函数通常不应该是explicit的。</span><br></code></pre></td></tr></table></figure><ol start="2"><li><strong>拷贝赋值运算符</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">Sales_data trans, accum;<br>trans = accum; <span class="hljs-comment">//使用Sales_data的拷贝赋值运算符</span><br></code></pre></td></tr></table></figure><ol start="3"><li><strong>移动构造函数</strong></li></ol><p>类似string类，如果我们自己的类也同时支持移动和拷贝，那么也能从中受益，为了让我们自己的类型支持移动操作，需要为其定义移动构造函数和移动赋值运算符。这两个成员类似对应的拷贝操作，但他们从给定对象“窃取”资源而不是拷贝资源。</p><p>类似拷贝构造函数，移动构造函数的第一个参数是该类类型的一个应用，不同于拷贝构造函数的是，这个引用参数在移动构造函数中是一个右值引用。除了完成资源移动，移动构造函数还必须确保移后源对象处于这样一个状态–销毁它是无害的。（一旦资源完成移动，源对象必须不再指向被移动的资源，这些资源所有权已经归属新创建的对象）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">StrVec::<span class="hljs-built_in">StrVec</span>(StrVec &amp;&amp;s) <span class="hljs-keyword">noexcept</span> <span class="hljs-comment">//移动操作不应抛出任何异常</span><br>    : <span class="hljs-built_in">elements</span>(s.elements), <span class="hljs-built_in">first_free</span>(s.first_free), <span class="hljs-built_in">cap</span>(s.cap)&#123;<br>        s.elements = s.first_free = s.cap = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-comment">//令s进入一个这样的状态，对其析构是安全的</span><br>    &#125;<br><span class="hljs-comment">//noexcept它通知标准库我们的析构函数不抛出任何异常</span><br></code></pre></td></tr></table></figure><ul><li>不抛出异常的移动构造函数和移动赋值运算符必须标记为<code>noexcept</code>。</li></ul><ol start="4"><li><strong>移动赋值运算符</strong></li></ol><p>与移动构造函数一样，如果我们的移动赋值运算符不抛出任何异常，我们就应该将它标记为<code>noexcept</code>，类似拷贝赋值运算符，移动赋值运算符必须正确处理自赋值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">StrVec &amp;StrVec::<span class="hljs-keyword">operator</span>=(StrVec &amp;&amp;rhs) <span class="hljs-keyword">noexcept</span> &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> != &amp;rhs) &#123; <span class="hljs-comment">//直接检测自赋值,如果相同，右侧和左侧运算符指向相同的对象，不需要做任何事情</span><br>        <span class="hljs-built_in">free</span>(); <span class="hljs-comment">//释放已有资源</span><br>        elements = rhs.elements; <span class="hljs-comment">//从rhs接管资源</span><br>        first_free = rhs.first_free;<br>        cap = rhs.cap;<br>        rhs.elements = rhs.first_free = rhs.cap = <span class="hljs-literal">nullptr</span>；<br>    &#125;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于<code>this</code>指针的补充：this指针指向正在被该成员函数操作的那个对象，当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的那个对象的指针，<code>this</code>指针是一个右值，所以不能取得地址（❌ <code>&amp;this</code>）。</p><p><strong>移动右值，拷贝左值：</strong></p><p>如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数。例如我们的<code>StrVec</code>类中，拷贝构造函数接受一个<code>const StrVec</code>的引用，因此它可以用于任何可以转换为<code>StrVec</code>的类型，而移动构造函数接受一个<code>StrVec&amp;&amp;</code>，因此只能用于实参是右值的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">StrVec v1, v2;<br>v1 = v2; <span class="hljs-comment">//v2是左值，使用拷贝赋值</span><br><span class="hljs-function">StrVec <span class="hljs-title">getVec</span><span class="hljs-params">(istream &amp;)</span></span>; <span class="hljs-comment">// getVec返回一个右值</span><br>v2 = <span class="hljs-built_in">getVec</span>(cin); <span class="hljs-comment">//使用移动赋值</span><br></code></pre></td></tr></table></figure><p>如果没有移动构造函数，右值也被拷贝。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Foo</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Foo</span>(<span class="hljs-type">const</span> Foo&amp;); <span class="hljs-comment">//拷贝构造函数</span><br>&#125;;<br>Foo x;<br><span class="hljs-function">Foo <span class="hljs-title">y</span><span class="hljs-params">(x)</span></span>; <span class="hljs-comment">//拷贝构造函数，x是一个左值</span><br><span class="hljs-function">Foo <span class="hljs-title">z</span><span class="hljs-params">(std::move(x))</span></span>; <span class="hljs-comment">//拷贝构造函数，因为未定义移动构造函数</span><br><span class="hljs-comment">//在对z进行初始化时，我们调用了move(x)，它返回一个绑定到x的Foo&amp;&amp;,Foo的拷贝构造函数是可行的，因为我们可以将一个Foo&amp;&amp;转换为一个const Foo&amp;。因此z的初始化将使用Foo的拷贝构造函数。</span><br></code></pre></td></tr></table></figure><p>拷贝并交换赋值运算符和移动操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HasPtr</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">HasPtr</span>(HasPtr &amp;&amp;p) <span class="hljs-keyword">noexcept</span><br>            : <span class="hljs-built_in">ps</span>(p.ps), <span class="hljs-built_in">i</span>(p.i) &#123; p.ps = <span class="hljs-number">0</span>; &#125; <br>    <span class="hljs-comment">//赋值运算符既是移动赋值运算符，也是拷贝赋值运算符</span><br>    HasPtr&amp; <span class="hljs-keyword">operator</span> = (HasPtr rhs)&#123;<br>            <span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>, rhs);<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们为类添加了一个移动构造函数，它接管了给定实参的值，构造函数体将给定的<code>HasPtr</code>的指针置为0，从而确保销毁移后对象是安全的，此函数不会抛出异常，因此我们定义为<code>noexcept</code>。<br>此函数有一个<strong>非引用参数</strong>，这意味着此参数要进行拷贝初始化，依赖于实参的类型，拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数—<strong>左值被拷贝，右值被移动</strong>。因此单一的赋值运算符就实现了拷贝赋值运算符和移动赋值运算符两种功能。</p><p>重载赋值运算符：</p><p>重载运算符本质上是函数，其名字由<code>operator</code>关键字后接表示要定义的运算符的符号组成，因此，赋值运算符就是一个名为<code>operator=</code>的函数，类似于其它函数，运算符函数也有一个返回类型和一个参数列表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    Foo&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Foo&amp;); <span class="hljs-comment">//赋值运算符</span><br>&#125;;<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>析构函数</strong></li></ol><p>什么时候调用析构函数：</p><ul><li>变量在离开其作用域时被销毁</li><li>当一个对象被销毁时，其成员被销毁</li><li>容器被销毁时，其元素被销毁</li><li>对于动态分配的对象，当其指向它的指针应用delete运算符时被销毁</li><li>对于临时对象，当创建它的完整表达式结束时被销毁</li></ul><p><code>=default</code>：我们可以通过将拷贝控制成员定义为<code>=default</code>来显式的要求编译器生成合成的版本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sales_data</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Sales_data</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Sales_data</span>(<span class="hljs-type">const</span> Sales_data&amp;) = <span class="hljs-keyword">default</span>;<br>    Sales_data&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Sales_data &amp;);<br>    ~<span class="hljs-built_in">Sales_data</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br>Sales_data&amp; Sales_data::<span class="hljs-keyword">operator</span> = (<span class="hljs-type">const</span> Sales_data&amp;) = <span class="hljs-keyword">default</span>;<br><span class="hljs-comment">//当我们在类内使用=default修饰成员的声明时，合成的函数将隐式地声明为内联的。如果我们不希望合成的成员函数是内联函数，应该只对成员的类外定义使用=default，就像对拷贝赋值运算符所做的那样。</span><br></code></pre></td></tr></table></figure><hr><p>产生一个右值： <strong>static_cast</strong></p><ul><li><code>std::move</code> performs a <code>static_cast</code> to <strong>rvalue</strong> reference, which produces an <strong>rvalue</strong>.</li><li><code>std::move</code> is used to indicate that an object may be “moved from”.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::string <span class="hljs-title">s</span><span class="hljs-params">(t)</span></span>; <span class="hljs-comment">//拷贝</span><br><span class="hljs-function">std::string <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-keyword">static_cast</span>&lt;std::string &amp;&amp;&gt;(t))</span></span>; <span class="hljs-comment">//移动</span><br><br><span class="hljs-function">std::string <span class="hljs-title">s3</span><span class="hljs-params">(std::move(s))</span></span>; <span class="hljs-comment">//移动</span><br></code></pre></td></tr></table></figure><p>关于<code>static_cast</code>强制类型转换：</p><ul><li>用于非多态类型的转换</li><li>不执行运行时类型检查</li><li>通常用于转换数值型数据（<code>float</code> $\rightarrow$ <code>int</code>）</li><li>可以在整个层次结构中移动指针，子类转换为父类安全、父类转换为子类不安全（因为子类可能有不在父类的字段或方法）</li></ul><p>可能的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>[[nodiscard]] <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">move</span><span class="hljs-params">(T &amp;&amp;t)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">-&gt; std::<span class="hljs-type">remove_reference_t</span>&lt;T&gt; &amp;&amp;</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;std::<span class="hljs-type">remove_reference_t</span>&lt;T&gt; &amp;&amp;&gt;(t);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>&#123;<br>    Array&lt;<span class="hljs-type">int</span>&gt; m_array;<br>    std::string m_str;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Widget</span>(Widget &amp;&amp;other) <span class="hljs-keyword">noexcept</span><br>            : <span class="hljs-built_in">m_array</span>(std:: <span class="hljs-built_in">move</span>(other.m_array)), <span class="hljs-comment">//移动初始化</span><br>     <span class="hljs-built_in">m_str</span>(std::<span class="hljs-built_in">move</span>(other.m_str))&#123;&#125;<br>    <br>    Widget &amp;<span class="hljs-keyword">operator</span>=(Widget &amp;&amp;other) <span class="hljs-keyword">noexcept</span>&#123;<br>            m_array = std::<span class="hljs-built_in">move</span>(other.m_array); <span class="hljs-comment">//移动赋值</span><br>            m_str = std::<span class="hljs-built_in">move</span>(other.m_str);<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>万能引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T &amp;&amp;x)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>如果参数是一个<code>Tp</code>类型的右值，则这是一个正常的右值引用，并且<code>T=Tp</code></li><li>如果参数是一个<code>Tp</code>类型的左值，则它遵循下面的规则：<ul><li><code>T</code>会被推断为左值引用，并且<code>T = Tp &amp;</code></li><li><code>x</code>是<code>Tp &amp; &amp;&amp;</code> ，但会显示为：  <code>Tp &amp;</code>, 引用折叠的原因</li></ul></li><li>cv属性会被保留<ul><li>如果参数是一个常量左值，则<code>x</code>会是一个左值的常量引用</li></ul></li></ul><p>万能引用和右值引用：</p><p><code>T &amp;&amp;x</code>是万能引用， T通过类型推导直接获得</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T &amp;&amp;x)</span></span>; <span class="hljs-comment">// universal reference</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T &amp;&amp;x)</span></span>; <span class="hljs-comment">// rvalue reference</span><br>&#125;;<br><span class="hljs-keyword">auto</span> &amp;&amp;x = y; <span class="hljs-comment">// universal reference</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(std::vector&lt;T&gt; &amp;&amp;x)</span></span>; <span class="hljs-comment">// rvalue reference</span><br></code></pre></td></tr></table></figure><p> 引用折叠：</p><ul><li><p><code>&amp; &amp;</code>，<code>&amp; &amp;&amp;</code> and <code>&amp;&amp; &amp;</code> collapse to <code>&amp;</code>.</p></li><li><p><code>&amp;&amp; &amp;&amp;</code> collapses to <code>&amp;&amp;</code>.</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> lref = <span class="hljs-type">int</span> &amp;;<br><span class="hljs-keyword">using</span> rref = <span class="hljs-type">int</span> &amp;&amp;;<br><span class="hljs-type">int</span> n = <span class="hljs-number">42</span>;<br><br>lref r1 = n; <span class="hljs-comment">// int&amp;</span><br>lref r2 = n; <span class="hljs-comment">// int&amp;</span><br>rref r3 = n; <span class="hljs-comment">// int&amp;</span><br>rref r4 - <span class="hljs-number">42</span>; <span class="hljs-comment">//int&amp;&amp;</span><br></code></pre></td></tr></table></figure><p>完美转发：<strong>std::forward</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Func, <span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">invoke1</span><span class="hljs-params">(Func f, T &amp;&amp;arg)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(std::forward&lt;T&gt;(arg));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>当传入的参数是一个左值时，<code>std::forward&lt;T&amp;&gt;(x)</code> 返回一个左值引用。</p></li><li><p>当传入的参数是一个右值时，<code>std::forward&lt;T&gt;(x)</code>， 此时T不是引用类型，返回一个右值引用。</p><ul><li>在这种情况下，等价于<code>std::move(x)</code>。</li></ul></li><li><p>std::forward does not actually “forward” anything! it’s uesd to preserve all the details about an argument’s type (including value categories and cv-qualifiers).</p></li></ul><p><strong>example1</strong>:  <code>vector&lt;T&gt;::emplace_back</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Alloc&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">vector</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>...Args&gt;</span><br><span class="hljs-function">    <span class="hljs-type">void</span> <span class="hljs-title">emplace_back</span><span class="hljs-params">(Args &amp;&amp; ...args)</span></span>&#123;<br>            <span class="hljs-built_in">check_and_realloc</span>();<br>            <span class="hljs-keyword">using</span> all_tr = std::allocator_traits&lt;Alloc&gt;;<br>            alloc::<span class="hljs-built_in">construct</span>(s_alloc, m_data + m_size, std::forward&lt;Args&gt;(args)...);<br>            ++ m_size;<br>        &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(value_type &amp;&amp;x)</span></span>&#123;<br>            <span class="hljs-built_in">emplace_back</span>(std::<span class="hljs-built_in">move</span>(x)); <span class="hljs-comment">//move</span><br>        &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> value_type &amp;x)</span></span>&#123;<br>        <span class="hljs-built_in">emplace_back</span>(x);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>example2</strong>: a python-style print</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> First, <span class="hljs-keyword">typename</span> ... Rest&gt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(First &amp;&amp;first, Rest &amp;&amp;... rest)</span></span>&#123;<br>    std::cout &lt;&lt; std::forward&lt;First&gt;(first);<br>    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-keyword">sizeof</span> ...(rest) == <span class="hljs-number">0</span>)</span></span><br><span class="hljs-function">        std::cout &lt;&lt; &#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        <span class="hljs-built_in">print</span>(std::forward&lt;Rest&gt;(rest)...);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考：Gkxx.</p>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ajax</title>
    <link href="/2023/04/06/ajax/"/>
    <url>/2023/04/06/ajax/</url>
    
    <content type="html"><![CDATA[<h3 id="常用的ajax方法："><a href="#常用的ajax方法：" class="headerlink" title="常用的ajax方法："></a>常用的ajax方法：</h3><h4 id="1-GET方法："><a href="#1-GET方法：" class="headerlink" title="1.GET方法："></a>1.GET方法：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">$.<span class="hljs-title function_">ajax</span>(&#123;<br>    <span class="hljs-attr">url</span>:<span class="hljs-string">&quot;https://www.example.top&quot;</span>,<br>    <span class="hljs-attr">type</span>:<span class="hljs-string">&quot;GET&quot;</span>,<br>    <span class="hljs-attr">data</span>:&#123;<br>        <span class="hljs-attr">username</span>:<span class="hljs-string">&quot;xx&quot;</span>, <span class="hljs-attr">age</span>:<span class="hljs-number">18</span>,<br>    &#125;,<br>    <span class="hljs-attr">dataType</span>: <span class="hljs-string">&quot;json&quot;</span>,<br>    <span class="hljs-attr">success</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">resp</span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;success&quot;</span>);<br>    &#125;,<br>&#125;);<br><br><span class="hljs-comment">//实战小例子</span><br>$ajax(&#123;<br>    <span class="hljs-attr">url</span>:<span class="hljs-string">&quot;https://www.toptop.tech/settings/web/apply_code&quot;</span>,<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;GET&quot;</span>,<br>    <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">resp</span>)&#123;<br>        <span class="hljs-keyword">if</span>(resp.<span class="hljs-property">result</span> === <span class="hljs-string">&quot;success&quot;</span>)&#123;<br>            <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-title function_">replace</span>(resp.<span class="hljs-property">apply_code_url</span>);<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="2-POST方法："><a href="#2-POST方法：" class="headerlink" title="2.POST方法："></a>2.POST方法：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js">$.<span class="hljs-title function_">ajax</span>(&#123;<br>    <span class="hljs-attr">url</span>: url,<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;POST&quot;</span>,<br>    <span class="hljs-attr">data</span>: &#123;<br>    &#125;,<br>    <span class="hljs-attr">dataType</span>: <span class="hljs-string">&quot;json&quot;</span>,<br>    <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">resp</span>) &#123;<br><br>    &#125;,<br>&#125;);<br><br><span class="hljs-comment">//实战小例子</span><br>$ajax(&#123;<br>    <span class="hljs-attr">url</span>:<span class="hljs-string">&quot;https://www.toptop.tech/settings/token&quot;</span>,<br>    <span class="hljs-attr">type</span>:<span class="hljs-string">&quot;POST&quot;</span>,<br>    <span class="hljs-attr">data</span>:&#123;<br>        <span class="hljs-attr">username</span>: username,<br>        <span class="hljs-attr">password</span>:password,<br>    &#125;<br>    <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">resp</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resp);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span>.<span class="hljs-property">access</span> = resp.<span class="hljs-property">access</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span>.<span class="hljs-property">refresh</span> = resp.<span class="hljs-property">refresh</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">refresh_jwt_token</span>();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getinfo_web</span>();<br>&#125;,<br><span class="hljs-attr">error</span>:<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">$login_error_message</span>.<span class="hljs-title function_">html</span>(<span class="hljs-string">&quot;用户名或密码错误&quot;</span>);<br>&#125;<br>&#125;);<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>url</td><td>必需，请求url</td></tr><tr><td>type</td><td>GET、POST</td></tr><tr><td>datatype</td><td>一般为json、还可为script、html、xml等</td></tr><tr><td>data</td><td>可选，请求数据</td></tr><tr><td>success</td><td>可选，当请求成功时运行的函数，函数形式：function(data, status, xhr){….},其中参数data表示服务器返回的数据，status表示请求的状态，xhr表示XMLHttpRequest对象</td></tr><tr><td>error</td><td>如果请求失败要运行的函数，函数形式同success</td></tr><tr><td>async</td><td>是否异步请求，默认为true</td></tr><tr><td>timeout</td><td>请求超时时间</td></tr><tr><td>complete</td><td>请求完成时运行的函数，（在请求成功或失败之后均调用），函数形式同success</td></tr></tbody></table><p>JSON对象用于序列化对象、数组、数值、字符串、布尔值、和null。</p><p>常用API：<code>JSON.parse()</code>:将字符串解析成对象</p><p>​<code>JSON.stringify()</code>:将对象转化为字符串</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>chatgpt带我学IO复用</title>
    <link href="/2023/03/22/chatgpt%E5%B8%A6%E6%88%91%E5%AD%A6IO%E5%A4%8D%E7%94%A8/"/>
    <url>/2023/03/22/chatgpt%E5%B8%A6%E6%88%91%E5%AD%A6IO%E5%A4%8D%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="C-中阻塞IO和非阻塞IO的区别"><a href="#C-中阻塞IO和非阻塞IO的区别" class="headerlink" title="C++中阻塞IO和非阻塞IO的区别"></a>C++中阻塞IO和非阻塞IO的区别</h3><p>在C++中，阻塞I&#x2F;O和非阻塞I&#x2F;O的主要区别在于对I&#x2F;O操作的等待方式。</p><p>阻塞I&#x2F;O（Blocking I&#x2F;O）指的是当应用程序执行I&#x2F;O操作时，如果I&#x2F;O操作没有完成，则应用程序会一直等待直到I&#x2F;O操作完成为止。在这个过程中，应用程序会被阻塞，不能执行其他任务。当I&#x2F;O操作完成后，应用程序才会继续执行。例如，当使用<code>std::cin</code>进行输入操作时，输入流会一直等待用户输入，直到输入完成后才会继续执行程序。</p><p>非阻塞I&#x2F;O（Non-blocking I&#x2F;O）指的是当应用程序执行I&#x2F;O操作时，如果I&#x2F;O操作没有完成，则应用程序不会等待，而是立即返回一个错误码或空数据。在这个过程中，应用程序可以继续执行其他任务，不会被阻塞。应用程序需要轮询I&#x2F;O操作的状态，直到I&#x2F;O操作完成为止。例如，当使用socket进行网络通信时，可以使用<code>fcntl</code>函数将<code>socket</code>设置为非阻塞模式，当进行读写操作时，如果数据还没有准备好，则函数会立即返回一个错误码，应用程序需要继续轮询直到数据准备好为止。</p><p>阻塞I&#x2F;O和非阻塞I&#x2F;O都有其优缺点。阻塞I&#x2F;O可以确保I&#x2F;O操作完成后再继续执行程序，但是可能会导致应用程序的效率低下，因为在等待I&#x2F;O操作完成的过程中，应用程序无法执行其他任务。非阻塞I&#x2F;O可以提高应用程序的效率，因为在等待I&#x2F;O操作完成的过程中可以执行其他任务，但是需要消耗更多的系统资源，并且编写代码可能会更加复杂。因此，在选择阻塞I&#x2F;O和非阻塞I&#x2F;O时需要根据具体的应用场景和需求来决定。</p><h3 id="select、poll、epoll三者的区别"><a href="#select、poll、epoll三者的区别" class="headerlink" title="select、poll、epoll三者的区别"></a>select、poll、epoll三者的区别</h3><p><code>select</code>、<code>poll</code>和<code>epoll</code>都是Linux下常用的I&#x2F;O多路复用机制，它们可以同时监控多个文件描述符的可读可写状态，并在有数据可读或可写时返回，从而避免了使用阻塞I&#x2F;O造成的线程等待和系统调用开销过大的问题。它们的区别如下：</p><ol><li>select和poll的效率会随着文件描述符数量的增加而降低，而epoll则不会受到文件描述符数量的影响。</li><li>select和poll使用轮询的方式进行文件描述符的检测，而epoll使用事件通知的方式，当有数据到达时会通知应用程序，这样可以避免不必要的轮询，提高了效率。</li><li>select和poll支持的文件描述符数量有限，一般在1024以内，而epoll没有限制。</li><li>select和poll会将所有监控的文件描述符从用户空间复制到内核空间，这个过程需要开销，并且每次调用都要重复，而epoll在添加和删除文件描述符时只需要将文件描述符添加到一个内核事件表中，这个表只需要在初始化时复制一次，这样可以减少系统调用和内存开销。</li><li>select和poll需要遍历整个监控的文件描述符列表，而epoll会将就绪的文件描述符存放到一个就绪队列中，应用程序只需要处理就绪队列中的文件描述符即可。</li></ol><p>总之，epoll相对于select和poll具有更高的效率和更好的扩展性，适合高并发和大规模的网络应用。但是，对于一些小型应用，select和poll可能是更加简单和实用的选择。</p><p>epoll的LT和ET模式的理解：</p><p>LT模式：当<code>epoll_wait</code>检测到描述符事件发⽣并将此事件通知应⽤程序，应⽤程序可以不⽴即处理该事件。下次调⽤<code>epoll_wait</code>时，会再次响应应⽤程序并通知此事件。<br>ET模式：当<code>epoll_wait</code>检测到描述符事件发⽣并将此事件通知应⽤程序，应⽤程序必须⽴即处理该事件。如果不处理，下次调⽤<code>epoll_wait</code>时，不会再次响应应⽤程序并通知此事件。  </p><h4 id="它们三者的底层实现"><a href="#它们三者的底层实现" class="headerlink" title="它们三者的底层实现"></a>它们三者的底层实现</h4><p><code>select</code>、<code>poll</code>和<code>epoll</code>都是I&#x2F;O多路复用机制，它们的底层实现有所不同。</p><ol><li><code>select</code>底层实现：<code>select</code>使用<strong>轮询</strong>的方式进行文件描述符的检测，其核心数据结构是一个<code>fd_set</code>类型的数组。当应用程序调用<code>select</code>时，会将所有待监控的文件描述符从用户空间复制到内核空间，然后在内核空间遍历这些文件描述符，检查它们是否准备好进行I&#x2F;O操作，如果准备好了，则将其加入到一个结果集中并返回。这个过程需要将所有的文件描述符复制到内核空间，而且每次调用都需要重新复制，因此效率较低。</li><li><code>poll</code>底层实现：<code>poll</code>也使用<strong>轮询</strong>的方式进行文件描述符的检测，其核心数据结构是一个<code>pollfd</code>类型的数组。当应用程序调用<code>poll</code>时，会将所有待监控的文件描述符从用户空间复制到内核空间，然后在内核空间遍历这些文件描述符，检查它们是否准备好进行I&#x2F;O操作，如果准备好了，则将其加入到一个结果集中并返回。和select类似，这个过程需要将所有的文件描述符复制到内核空间，而且每次调用都需要重新复制，因此效率较低。</li><li><code>epoll</code>底层实现：<code>epoll</code>使用事件通知的方式进行文件描述符的检测，其核心数据结构是一个<strong>内核事件表</strong>。当应用程序调用<code>epoll</code>时，会将待监控的文件描述符加入到内核事件表中，并注册对应的事件类型（可读、可写、异常等）。当有文件描述符准备好进行I&#x2F;O操作时，内核会将其加入到一个就绪队列中，并通过一个回调函数通知应用程序。这个过程只需要将文件描述符添加到内核事件表中，不需要重复复制，因此效率较高。[没有最大的并发连接限制，内存拷贝、利用mmap()文件映射内存加速与内核空间的消息传递。]</li></ol><p>综上所述，epoll比select和poll具有更高的效率和更好的扩展性。</p><h3 id="IO复用的原理"><a href="#IO复用的原理" class="headerlink" title="IO复用的原理"></a>IO复用的原理</h3><p>IO多路复用（IO multiplexing）是一种利用操作系统提供的一些系统调用（如select、poll、epoll等）来实现同时监控多个文件描述符的状态，从而实现高效的IO操作的技术。其原理基于操作系统提供的异步IO机制，使得可以同时监视多个文件描述符的可读、可写、异常等事件，当有IO事件发生时，操作系统会通知应用程序进行相应的处理。</p><p>具体实现时，IO多路复用可以用于在一个进程中同时处理多个socket连接。当某个socket上有数据到达时，操作系统会通过系统调用返回这个socket的文件描述符，应用程序可以通过读取该文件描述符中的数据来处理网络通信。</p><p>相比于传统的多线程或多进程模型，IO多路复用具有以下优点：</p><ul><li>能够高效地处理大量的连接，避免了线程或进程切换的开销。</li><li>能够实现高并发和高性能的网络通信，可以同时处理多个连接的IO操作。</li><li>能够有效地避免网络连接因为阻塞等原因导致的资源浪费，提高了系统的资源利用率。</li></ul><p>IO多路复用是实现高性能网络通信的重要技术之一，在网络编程中得到广泛应用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>chatgpt带我学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>chatpgt生成系列-之信号量实现线程同步</title>
    <link href="/2023/03/21/chatpgt%E7%94%9F%E6%88%90%E7%B3%BB%E5%88%97-%E4%B9%8B%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <url>/2023/03/21/chatpgt%E7%94%9F%E6%88%90%E7%B3%BB%E5%88%97-%E4%B9%8B%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="线程的同步方式："><a href="#线程的同步方式：" class="headerlink" title="线程的同步方式："></a>线程的同步方式：</h3><ol><li>临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问，在任意一个时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么再有一个线程进入后，其它试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其它线程才可以抢占。</li><li>互斥对象：互斥对象和临界区很像，采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程同时访问，当前拥有互斥对象的线程处理完任务之后必须将线程交出，以便其它线程访问该资源。</li><li>信号量：允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目，在<code>CreateSemaphore()</code>创建信号量时即要同时指出允许的最大资源计数和当前可用资源计数。⼀般是将当前可⽤资源计数设置为最 ⼤资源计数，每增加⼀个线程对共享资源的访问，当前可⽤资源计数就会减1 ，只要当前可⽤资源计数是⼤于0的，就可以发出信号量信号。但是当前可⽤计数减⼩ 到0 时则说明当前占⽤资源的线程数已经达到了所允许的最⼤数⽬，不能在允许其他线程的进⼊，此时的信号量信号将⽆法发出。线程在处理完共享资源后，应在离 开的同时通过<code>ReleaseSemaphore()</code>函数将当前可⽤资源计数加1 。在任何时候当前可⽤资源计数决不可能⼤于最⼤资源计数。  </li><li>事件对象：通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级的比较。</li></ol><h3 id="以下是chatGPT给出的答案："><a href="#以下是chatGPT给出的答案：" class="headerlink" title="以下是chatGPT给出的答案："></a>以下是<em>chatGPT</em>给出的答案：</h3><p>线程同步是指多个线程之间的协作，以保证它们不会同时访问共享资源或发生竞态条件（race condition）。以下是常见的线程同步方式：</p><ol><li>互斥锁（Mutex）：互斥锁是一种最常用的同步机制，用于保护共享资源的访问，一次只允许一个线程访问共享资源。当一个线程获得了互斥锁，其他线程就不能访问共享资源，直到获得锁的线程释放互斥锁。</li><li>信号量（Semaphore）：信号量是一种计数器，用于控制同时访问共享资源的线程数量。当一个线程访问共享资源时，它会通过信号量将计数器减1，其他线程要访问该资源时需要等待，直到计数器变为非零为止。</li><li>条件变量（Condition Variable）：条件变量是一种同步机制，用于在线程之间传递信号，以便它们可以相互通信和协调操作。当一个线程需要等待某个条件满足时，它可以调用条件变量的等待函数，这会使线程暂停，并释放锁。当其他线程满足条件并发出信号时，等待线程会被唤醒并重新获得锁。</li><li>屏障（Barrier）：屏障是一种同步机制，用于在多个线程并发执行的情况下同步它们的操作。当一个线程到达屏障点时，它会停止执行，并等待其他线程到达屏障点。当所有线程都到达屏障点时，它们会同时继续执行。</li><li>读写锁（Reader-Writer Lock）：读写锁是一种同步机制，用于在读多写少的场景中优化性能。它允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。当一个线程请求写入锁时，它会排斥其他所有的读取和写入操作，直到它释放写入锁为止。</li></ol><h3 id="实战环节："><a href="#实战环节：" class="headerlink" title="实战环节："></a>实战环节：</h3><ol><li>基于信号量的线程同步代码：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><span class="hljs-type">sem_t</span> sem;<br><br><span class="hljs-comment">/*  这里定义了一个生产者线程producer，它每隔1秒向队列中插入一个数，并通过sem_post()函数增加信号量计数器的值。此外，它还在控制台上打印了一条生产信息。 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">producer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>        q.<span class="hljs-built_in">push</span>(i);<br>        <span class="hljs-built_in">sem_post</span>(&amp;sem);<br>        cout &lt;&lt; <span class="hljs-string">&quot;Produced &quot;</span> &lt;&lt; i &lt;&lt; endl;<br>        this_thread::<span class="hljs-built_in">sleep_for</span>(chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">1000</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 这里定义了一个消费者线程consumer，它每隔0.5秒从队列中取出一个数，并通过sem_wait()函数等待信号量计数器大于0。此外，它还在控制台上打印了一条消费信息。 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-built_in">sem_wait</span>(&amp;sem);<br>        <span class="hljs-type">int</span> num = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;Consumed &quot;</span> &lt;&lt; num &lt;&lt; endl;<br>        this_thread::<span class="hljs-built_in">sleep_for</span>(chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">500</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">sem_init</span>(&amp;sem, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-function">thread <span class="hljs-title">t1</span><span class="hljs-params">(producer)</span></span>;<br>    <span class="hljs-function">thread <span class="hljs-title">t2</span><span class="hljs-params">(consumer)</span></span>;<br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br><br>    <span class="hljs-built_in">sem_destroy</span>(&amp;sem);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="2"><li>基于互斥锁实现的线程同步代码：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br>std::mutex mtx; <span class="hljs-comment">// 定义互斥锁对象</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>    mtx.<span class="hljs-built_in">lock</span>(); <span class="hljs-comment">// 加锁，防止多个线程同时输出</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; is running.&quot;</span> &lt;&lt; std::endl;<br>    mtx.<span class="hljs-built_in">unlock</span>(); <span class="hljs-comment">// 解锁，允许其他线程输出</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(print, <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(print, <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t3</span><span class="hljs-params">(print, <span class="hljs-number">3</span>)</span></span>;<br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    t3.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">在这个示例中，我们定义了一个互斥锁对象 mtx，并将其用于保护 print() 函数中的输出语句。在 print() 函数中，线程会先通过 mtx.lock() 加锁，防止其他线程同时输出。当输出完成后，线程通过 mtx.unlock() 解锁，允许其他线程输出。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">在主函数中，我们创建了三个线程，并将它们的任务都设置为调用 print() 函数。当所有线程完成任务后，主函数通过 join() 函数等待它们的完成。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><ol start="3"><li>基于条件变量实现的线程同步代码：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><br>std::mutex mtx; <span class="hljs-comment">// 定义互斥锁对象</span><br>std::condition_variable cv; <span class="hljs-comment">// 定义条件变量对象</span><br><span class="hljs-type">bool</span> ready = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 定义等待条件</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lck</span><span class="hljs-params">(mtx)</span></span>; <span class="hljs-comment">// 定义互斥锁作用域</span><br>    <span class="hljs-keyword">while</span> (!ready) &#123; <span class="hljs-comment">// 检查等待条件</span><br>        cv.<span class="hljs-built_in">wait</span>(lck); <span class="hljs-comment">// 等待条件变量</span><br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; is running.&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(print, <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(print, <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t3</span><span class="hljs-params">(print, <span class="hljs-number">3</span>)</span></span>;<br><br>    <span class="hljs-comment">// 通知所有线程等待条件已满足</span><br>    &#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lck</span><span class="hljs-params">(mtx)</span></span>; <span class="hljs-comment">// 定义互斥锁作用域</span><br>        ready = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 修改等待条件</span><br>    &#125;<br>    cv.<span class="hljs-built_in">notify_all</span>(); <span class="hljs-comment">// 通知所有等待线程</span><br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    t3.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>基于读写锁实现的线程同步方式代码：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;shared_mutex&gt;</span></span><br><br>std::shared_mutex rw_mutex; <span class="hljs-comment">// 读写锁</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">writer</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::shared_mutex&gt; <span class="hljs-title">write_lock</span><span class="hljs-params">(rw_mutex)</span></span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Writer &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; is writing.&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-comment">// 进行写操作</span><br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Writer &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; has finished writing.&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reader</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;<br>    <span class="hljs-function">std::shared_lock&lt;std::shared_mutex&gt; <span class="hljs-title">read_lock</span><span class="hljs-params">(rw_mutex)</span></span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Reader &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; is reading.&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-comment">// 进行读操作</span><br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">500</span>));<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Reader &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; has finished reading.&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> num_readers = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> num_writers = <span class="hljs-number">2</span>;<br>    std::thread readers[num_readers];<br>    std::thread writers[num_writers];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num_readers; i++) &#123;<br>        readers[i] = std::<span class="hljs-built_in">thread</span>(reader, i);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num_writers; i++) &#123;<br>        writers[i] = std::<span class="hljs-built_in">thread</span>(writer, i);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num_readers; i++) &#123;<br>        readers[i].<span class="hljs-built_in">join</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num_writers; i++) &#123;<br>        writers[i].<span class="hljs-built_in">join</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="5"><li>基于barrier实现的线程同步方式代码：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>mutex mtx;<br>condition_variable cv;<br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> num_threads = <span class="hljs-number">5</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">worker</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; started&quot;</span> &lt;&lt; endl;<br>    &#123;<br>        <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>        count++;<br>        <span class="hljs-keyword">if</span> (count == num_threads) &#123;<br>            cv.<span class="hljs-built_in">notify_all</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cv.<span class="hljs-built_in">wait</span>(lock);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; finished&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">/* 这段代码是一个多线程的例子，其中包含了一个互斥锁和条件变量。代码中定义了一个计数器count，初始值为0，然后创建了5个线程，每个线程都会调用worker函数。在worker函数中，首先输出线程的id，然后对count进行加1操作，如果count等于num_threads（即5），则调用cv.notify_all()唤醒所有等待的线程，否则调用cv.wait(lock)等待条件变量。最后输出线程的id。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">在main函数中，创建了5个线程并启动，然后等待所有线程结束。 */</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    thread threads[num_threads];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num_threads; i++) &#123;<br>        threads[i] = <span class="hljs-built_in">thread</span>(worker, i);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num_threads; i++) &#123;<br>        threads[i].<span class="hljs-built_in">join</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>chatgpt带我学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT6.S081-chapter9</title>
    <link href="/2023/03/20/MIT6-S081-chapter9/"/>
    <url>/2023/03/20/MIT6-S081-chapter9/</url>
    
    <content type="html"><![CDATA[<p>9 concurrency revisited</p><p>同时获得良好的并行性能、并发时的正确性和可理解的代码是内核设计中的一大挑战。 直接使用锁是实现正确性的最佳途径，但并非总是可行。 本章重点介绍 xv6 被迫以复杂方式使用锁的示例，以及 xv6 使用类锁技术但不使用锁的示例。</p><p>9.1 locking patterns</p><p>缓存的项目通常很难锁定。 例如，文件系统的块缓存 (kernel&#x2F;bio.c:26) 存储多达 NBUF 磁盘块的副本。 给定的磁盘块在缓存中最多有一个副本是至关重要的； 否则，不同的进程可能会对本应属于同一块的不同副本进行相互冲突的更改。 每个缓存块都存储在一个 struct buf (kernel&#x2F;buf.h:1) 中。<br>一个 struct buf 有一个锁定字段，它有助于确保一次只有一个进程使用给定的磁盘块。 然而，那个锁还不够：如果一个块根本不存在于缓存中，并且两个进程想要同时使用它怎么办？ 没有 struct buf（因为块还没有被缓存），因此没有什么可以锁定的。 Xv6 通过将附加锁 (bcache.lock) 与缓存块的标识集相关联来处理这种情况。 需要检查的代码如果一个块被缓存（例如，bget (kernel&#x2F;bio.c:59)），或者改变缓存块的集合，必须持有 bcache.lock； 在该代码找到它需要的块和 struct buf 之后，它可以释放 bcache.lock 并只锁定特定的块。 这是一个常见的模式：一个锁用于一组物品，每件物品加一把锁。</p><p>通常获取锁的同一个函数会释放它。 但更精确的看待事物的方式是，在必须表现为原子的序列开始时获取锁，并在该序列结束时释放。 如果序列在不同的函数、不同的线程或不同的 CPU 中开始和结束，那么锁的获取和释放必须做同样的事情。 锁的作用是强制其他使用等待，而不是将一条数据钉在某个特定的代理上。 一个例子是 yield (kernel&#x2F;proc.c:496) 中的 acquire，它是在调度程序线程中释放的，而不是在获取过程中释放的。 再比如ilock中的acquiresleep(kernel&#x2F;fs.c:289)； 此代码经常在读取磁盘时休眠； 它可能会在不同的 CPU 上唤醒，这意味着可能会在不同的 CPU 上获取和释放锁。</p><p>释放受对象中嵌入的锁保护的对象是一项微妙的工作，因为拥有锁不足以保证释放是正确的。当其他线程正在等待获取使用该对象时，就会出现问题； 释放对象会隐式释放嵌入的锁，这将导致等待线程发生故障。 一种解决方案是跟踪存在多少对对象的引用，以便仅在最后一个引用消失时才释放它。 有关示例，请参见 pipeclose (kernel&#x2F;pipe.c:59)； pi-&gt;readopen 和 pi-&gt;writeopen 跟踪管道是否有引用它的文件描述符。</p><p>9.2 lock-like patterns</p><p>在许多地方，xv6 以类似锁的方式使用引用计数或标志来指示对象已分配且不应被释放或重新使用。 进程的 p-&gt;state 以这种方式运行，文件、inode 和 buf 结构中的引用计数也是如此。 虽然在每种情况下锁都会保护标志或引用计数，但后者可以防止对象被过早释放。</p><p>文件系统使用struct inode reference counts作为一种可以被多个进程持有的共享锁，以避免代码使用普通锁时出现的死锁。<br>例如，namex (kernel&#x2F;fs.c:629) 中的循环依次锁定每个路径名组件命名的目录。 但是，namex 必须在循环结束时释放每个锁，因为如果它持有多个锁，如果路径名包含一个点（例如，a&#x2F;.&#x2F;b），它可能会与自身发生死锁。</p><p>它还可能会因涉及目录的并发查找而死锁…… 正如第 8 章所解释的，解决方案是循环将目录 inode 带到下一次迭代，其引用计数递增，但不锁定。</p><p>一些数据项在不同时间受到不同机制的保护，有时可能会通过 xv6 代码的结构隐式地保护免受并发访问，而不是通过显式的<br>锁。 例如，当物理页面空闲时，它受 kmem.lock (kernel&#x2F;kalloc.c:24) 保护。<br>如果页面随后被分配为管道 (kernel&#x2F;pipe.c:23)，它会受到不同锁（嵌入式 pi-&gt;lock）的保护。 如果为新进程的用户内存重新分配页面，则它根本不受锁保护。 相反，分配器不会将该页面提供给任何其他进程（直到它被释放）这一事实保护它免受并发访问。 新进程内存的所有权很复杂：<br>首先，父进程在 fork 中分配和操作它，然后子进程使用它，并且（在子进程退出后）父进程再次拥有内存并将其传递给 kfree。 这里有两个教训：一个数据对象可以在其生命周期的不同时间点以不同的方式受到并发保护，并且保护可以采用隐式结构的形式而不是显式锁。<br>最后一个类似锁的例子是需要在调用 mycpu() (kernel&#x2F;proc.c:80) 时禁用中断。 禁用中断会导致调用代码相对于可能强制上下文切换的计时器中断是原子的，从而将进程移动到不同的 CPU。</p><p>9.3 no locks at all</p><p>有几个地方 xv6 共享可变数据而根本没有锁。 一个是自旋锁的实现，尽管可以将 RISC-V 原子指令视为依赖于在硬件中实现的锁。 另一个是main.c（kernel&#x2F;main.c:7）中的started变量，用来防止其他CPU运行，直到CPU零完成对xv6的初始化； volatile 确保编译器实际生成加载和存储指令。 第三个例子是 p-&gt;killed，它在持有 p-&gt;lock (kernel&#x2F;proc.c:579) 时设置，但在没有持有锁的情况下进行检查 (kernel&#x2F;trap.c:56)。<br>xv6 包含一个 CPU 或线程写入一些数据，另一个 CPU 或线程读取数据的情况，但没有专用于保护该数据的特定锁。 例如，在 fork 中，父进程写入子进程的用户内存页面，而子进程（不同的线程，可能在不同的 CPU 上）读取这些页面； 没有锁明确保护这些页面。 这不是严格意义上的锁定问题，因为子进程直到父进程完成写入后才开始执行。 这是一个潜在的内存排序问题（见第 6 章），因为没有内存屏障就没有理由期望一个 CPU 看到另一个 CPU 的写入。 然而，由于父进程释放锁，而子进程在启动时获取锁，获取和释放中的内存屏障确保子进程的 CPU 可以看到父进程的写入。</p><p>9.4 parallelism</p><p>锁定主要是为了正确性而抑制并行性。 因为性能也很重要，所以内核设计者经常不得不考虑如何以既实现正确性又允许并行性的方式使用锁。 虽然 xv6 并不是为高性能而系统地设计的，但仍然值得考虑哪些 xv6 操作可以并行执行，哪些可能会在锁上发生冲突。<br>xv6 中的管道是相当好的并行性的一个例子。 每个管道都有自己的锁，这样不同的进程就可以在不同的CPU上并行读写不同的管道。 但是，对于给定的管道，写入者和读取者必须等待对方释放锁； 他们不能同时读&#x2F;写同一个管道。 从空管道读取（或写入满管道）也必须阻塞，但这不是由于锁定方案。<br>上下文切换是一个更复杂的例子。 两个内核线程，各自在自己的 CPU 上执行，可以同时调用 yield、sched 和 swtch，这些调用将并行执行。<br>线程各自持有一个锁，但它们是不同的锁，因此它们不必相互等待。<br>然而，一旦进入调度程序，两个 CPU 在搜索进程表以寻找可运行的进程时可能会在锁上发生冲突。 也就是说，xv6 可能会在上下文切换期间从多个 CPU 中获得性能优势，但可能不会达到它所能达到的程度。</p><p>另一个例子是从不同 CPU 上的不同进程并发调用 fork。 这些调用可能必须相互等待 pid_lock 和 kmem.lock，以及在进程表中搜索 UNUSED 进程所需的每个进程锁。 另一方面，这两个分叉进程可以完全并行地复制用户内存页和格式化页表页。<br>在某些情况下，上述每个示例中的锁定方案都会牺牲并行性能。 在每种情况下，都可以使用更精细的设计来获得更多的并行性。 是否值得取决于细节：相关操作被调用的频率、代码花费多长时间持有竞争锁、有多少 CPU 可能同时运行冲突操作、代码的其他部分是否是更具限制性的瓶颈。 很难猜测给定的锁定方案是否会导致性能问题，或者新设计是否明显更好，因此通常需要对实际工作负载进行测量。</p><p>end!</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MIT6.S081-chapter8</title>
    <link href="/2023/03/18/MIT6-S081-chapter8/"/>
    <url>/2023/03/18/MIT6-S081-chapter8/</url>
    
    <content type="html"><![CDATA[<ol start="8"><li>file system</li></ol><p>文件系统的目的是组织和存储数据。 文件系统通常支持在用户和应用程序之间共享数据以及持久性，以便数据在重启后仍然可用。xv6 文件系统提供类 Unix 文件、目录和路径名（参见第 1 章），并将其数据存储在 virtio 磁盘上以实现持久性。 文件系统解决了几个挑战：</p><ul><li>文件系统需要磁盘上的数据结构来表示命名目录和文件的树，记录保存每个文件内容的块的身份，并记录磁盘的哪些区域是空闲的。</li><li>文件系统必须支持崩溃恢复。 也就是说，如果发生崩溃（例如，电源故障），文件系统必须在重新启动后仍能正常工作。 风险在于崩溃可能会中断一系列更新并留下不一致的磁盘数据结构（例如，一个块既在文件中使用又标记为空闲）。</li><li>不同的进程可能同时对文件系统进行操作，因此文件系统代码必须协调以保持不变量。</li><li>访问磁盘比访问内存慢几个数量级，因此文件系统必须维护流行块的内存缓存。</li></ul><p>8.1 overview</p><p>xv6 文件系统实现分为七层，如图 8.1 所示。 磁盘层在 virtio 硬盘驱动器上读取和写入块。 缓冲区缓存层缓存磁盘块并同步访问它们，确保一次只有一个内核进程可以修改存储在任何特定块中的数据。 日志层允许更高层将更新包装到事务中的多个块，并确保块在面对崩溃时自动更新（即，所有块都被更新或没有）。 inode 层提供单独的文件，每个文件都表示为具有唯一 i-number 的 inode 和一些保存文件数据的块。 目录层将每个目录实现为一种特殊类型的 inode，其内容是一系列目录条目，每个目录条目包含一个文件名和 i-number。 路径名层提供分层路径名，如&#x2F;usr&#x2F;rtm&#x2F;xv6&#x2F;fs.c，并通过递归查找来解析它们。 文件描述符层使用文件系统接口抽象出许多 Unix 资源（例如，管道、设备、文件等），简化了应用程序程序员的工作。</p><img src="/2023/03/18/MIT6-S081-chapter8/81.png" class="" title="架构图"><p>磁盘硬件传统上将磁盘上的数据表示为 512 字节块（也称为扇区）的编号序列：扇区 0 是前 512 字节，扇区 1 是下一个，依此类推。 操作系统用于其文件系统的块大小可能与磁盘使用的扇区大小不同，但通常块大小是扇区大小的倍数。 Xv6 在 struct buf (kernel&#x2F;buf.h:1) 类型的对象中保存已读入内存的块的副本。 存储在该结构中的数据有时与磁盘不同步：它可能尚未从磁盘读入（磁盘正在处理它但尚未返回扇区的内容），或者它可能已被更新 软件但尚未写入磁盘。</p><p>文件系统必须有一个在磁盘上存储 inode 和内容块的计划。 为此，xv6 将磁盘分成几个部分，如图 8.2 所示。 文件系统不使用块 0（它包含引导扇区）。 块 1 称为超级块； 它包含有关文件系统的元数据（以块为单位的文件系统大小、数据块数、inode 数和日志中的块数）。 从 2 开始的块保存日志。 日志之后是索引节点，每个块有多个索引节点。 在那些之后是位图块跟踪正在使用的数据块。 其余块为数据块； 每个都在位图块中标记为空闲，或者<br>保存文件或目录的内容。 超级块由一个名为 mkfs 的单独程序填充，该程序构建一个初始文件系统。</p><img src="/2023/03/18/MIT6-S081-chapter8/82.png" class="" title="架构图"><p>8.2 buffer cache layer</p><p>缓冲区缓存有两个工作：（1）同步对磁盘块的访问，以确保内存中只有一个块的副本，并且一次只有一个内核线程使用该副本； (2) 缓存流行的块，这样它们就不需要从慢盘中重新读取。 代码在 bio.c 中。<br>buffer cache导出的主要接口由bread和bwrite组成； 前者获得一个包含可在内存中读取或修改的块副本的 buf，后者将修改后的缓冲区写入磁盘上的相应块。 内核线程在使用完缓冲区后必须通过调用 brelse 来释放缓冲区。 缓冲区缓存使用每个缓冲区的睡眠锁来确保一次只有一个线程使用每个缓冲区（以及每个磁盘块）； bread 返回一个锁定的缓冲区，brelse 释放锁。<br>让我们回到缓冲区缓存。 缓冲区缓存有固定数量的缓冲区来保存磁盘块，这意味着如果文件系统请求缓存中不存在的块，缓冲区缓存必须回收当前保存其他块的缓冲区。 缓冲区缓存为新块回收最近最少使用的缓冲区。 假设最近最少使用的缓冲区是最不可能很快再次使用的缓冲区。</p><p>8.3 code: buffer cache</p><p>缓冲区高速缓存是缓冲区的双向链表。 由 main (kernel&#x2F;- main.c:27) 调用的函数 binit 使用静态数组 buf (kernel&#x2F;bio.c:43-52) 中的 NBUF 缓冲区初始化列表。 所有其他对缓冲区缓存的访问都通过 bcache.head 引用链表，而不是 buf 数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">binit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span><br><br>  initlock(&amp;bcache.lock, <span class="hljs-string">&quot;bcache&quot;</span>);<br><br>  <span class="hljs-comment">// Create linked list of buffers</span><br>  bcache.head.prev = &amp;bcache.head;<br>  bcache.head.next = &amp;bcache.head;<br>  <span class="hljs-keyword">for</span>(b = bcache.buf; b &lt; bcache.buf+NBUF; b++)&#123;<br>    b-&gt;next = bcache.head.next;<br>    b-&gt;prev = &amp;bcache.head;<br>    initsleeplock(&amp;b-&gt;lock, <span class="hljs-string">&quot;buffer&quot;</span>);<br>    bcache.head.next-&gt;prev = b;<br>    bcache.head.next = b;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>缓冲区有两个与之关联的状态字段。 字段 valid 指示缓冲区包含块的副本。 field disk表示缓冲区内容已经交给<br>磁盘，这可能会改变缓冲区（例如，将数据从磁盘写入数据）。<br>Bread (kernel&#x2F;bio.c:93) 调用 bget 以获取给定扇区 (kernel&#x2F;bio.c:97) 的缓冲区。 如果需要从磁盘读取缓冲区，bread 会在返回缓冲区之前调用 virtio_disk_rw 来执行此操作。<br>Bget (kernel&#x2F;bio.c:59) 扫描缓冲区列表以查找具有给定设备和扇区号 (kernel&#x2F;bio.c:65-73) 的缓冲区。 如果存在这样的缓冲区，则 bget 获取缓冲区的睡眠锁。 然后 Bget 返回锁定的缓冲区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Return a locked buf with the contents of the indicated block.</span><br><span class="hljs-keyword">struct</span> buf*<br><span class="hljs-title function_">bread</span><span class="hljs-params">(uint dev, uint blockno)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span><br><br>  b = bget(dev, blockno);<br>  <span class="hljs-keyword">if</span>(!b-&gt;valid) &#123;<br>    virtio_disk_rw(b, <span class="hljs-number">0</span>);<br>    b-&gt;valid = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> b;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果给定扇区没有缓存缓冲区，则 bget 必须创建一个，可能会重新使用包含不同扇区的缓冲区。它第二次扫描缓冲区列表，寻找未使用的缓冲区 (b-&gt;refcnt &#x3D; 0)； 可以使用任何此类缓冲区。 Bget 编辑缓冲区元数据以记录新设备和扇区号并获取其睡眠锁。 请注意，赋值 b-&gt;valid &#x3D; 0 确保 bread 将从磁盘读取块数据，而不是错误地使用缓冲区的先前内容。</p><p>重要的是每个磁盘扇区最多有一个缓存缓冲区，以确保读者看到写入，并且因为文件系统使用缓冲区上的锁来进行同步。</p><p>Bget 通过从第一个循环检查块是否被缓存到第二个循环声明块现在被缓存（通过设置 dev、blockno 和refcnt）连续持有 bache.lock 来确保这种不变性。 这导致检查块的存在和（如果不存在）缓冲区的指定以保持块是原子的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Look through buffer cache for block on device dev.</span><br><span class="hljs-comment">// If not found, allocate a buffer.</span><br><span class="hljs-comment">// In either case, return locked buffer.</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> buf*<br><span class="hljs-title function_">bget</span><span class="hljs-params">(uint dev, uint blockno)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span><br><br>  acquire(&amp;bcache.lock);<br><br>  <span class="hljs-comment">// Is the block already cached?</span><br>  <span class="hljs-keyword">for</span>(b = bcache.head.next; b != &amp;bcache.head; b = b-&gt;next)&#123;<br>    <span class="hljs-keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;<br>      b-&gt;refcnt++;<br>      release(&amp;bcache.lock);<br>      acquiresleep(&amp;b-&gt;lock);<br>      <span class="hljs-keyword">return</span> b;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// Not cached.</span><br>  <span class="hljs-comment">// Recycle the least recently used (LRU) unused buffer.</span><br>  <span class="hljs-keyword">for</span>(b = bcache.head.prev; b != &amp;bcache.head; b = b-&gt;prev)&#123;<br>    <span class="hljs-keyword">if</span>(b-&gt;refcnt == <span class="hljs-number">0</span>) &#123;<br>      b-&gt;dev = dev;<br>      b-&gt;blockno = blockno;<br>      b-&gt;valid = <span class="hljs-number">0</span>;<br>      b-&gt;refcnt = <span class="hljs-number">1</span>;<br>      release(&amp;bcache.lock);<br>      acquiresleep(&amp;b-&gt;lock);<br>      <span class="hljs-keyword">return</span> b;<br>    &#125;<br>  &#125;<br>  panic(<span class="hljs-string">&quot;bget: no buffers&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>bget 在 bcache.lock 关键部分之外获取缓冲区的睡眠锁是安全的，因为非零 b-&gt;refcnt 防止缓冲区被重新用于不同的磁盘块。 睡眠锁保护块缓冲内容的读写，而bcache.lock 保护有关哪些块被缓存的信息。<br>如果所有的缓冲区都忙，那么太多进程同时执行文件系统调用； 恐慌。 一个更优雅的响应可能是休眠直到缓冲区空闲，尽管这样可能会出现死锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Write b&#x27;s contents to disk.  Must be locked.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">bwrite</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b)</span><br>&#123;<br>  <span class="hljs-keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))<br>    panic(<span class="hljs-string">&quot;bwrite&quot;</span>);<br>  virtio_disk_rw(b, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>一旦 bread 读取了磁盘（如果需要）并将缓冲区返回给它的调用者，调用者就可以独占使用缓冲区并且可以读取或写入数据字节。 如果调用者确实修改了缓冲区，它必须在释放缓冲区之前调用 bwrite 将更改的数据写入磁盘。 写入(kernel&#x2F;bio.c:107) 调用 virtio_disk_rw 与磁盘硬件对话。<br>当调用者用完一个缓冲区时，它必须调用 brelse 来释放它。 （名称 brelse 是 b-release 的缩写，含糊不清但值得学习：它起源于 Unix，也用于 BSD、Linux 和 Solaris。）Brelse (kernel&#x2F;bio.c:117) 释放睡眠锁 并将缓冲区移动到链表的前面 (kernel&#x2F;bio.c:128-133)。 移动缓冲区会导致列表按最近使用缓冲区的时间（意味着已释放）排序：列表中的第一个缓冲区是最近使用的，最后一个是最近最少使用的。 bget 中的两个循环利用了这一点：扫描现有缓冲区必须在最坏的情况下处理整个列表，但首先检查最近使用的缓冲区（从 bcache.head 开始并跟随下一个指针）将减少扫描时间 有很好的参考资料。 选择缓冲区以重用的扫描通过向后扫描（跟随 prev 指针）选择最近最少使用的缓冲区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Release a locked buffer.</span><br><span class="hljs-comment">// Move to the head of the most-recently-used list.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">brelse</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b)</span><br>&#123;<br>  <span class="hljs-keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))<br>    panic(<span class="hljs-string">&quot;brelse&quot;</span>);<br><br>  releasesleep(&amp;b-&gt;lock);<br><br>  acquire(&amp;bcache.lock);<br>  b-&gt;refcnt--;<br>  <span class="hljs-keyword">if</span> (b-&gt;refcnt == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// no one is waiting for it.</span><br>    b-&gt;next-&gt;prev = b-&gt;prev;<br>    b-&gt;prev-&gt;next = b-&gt;next;<br>    b-&gt;next = bcache.head.next;<br>    b-&gt;prev = &amp;bcache.head;<br>    bcache.head.next-&gt;prev = b;<br>    bcache.head.next = b;<br>  &#125;<br>  <br>  release(&amp;bcache.lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>8.4 logging layer</p><p>文件系统设计中最有趣的问题之一是崩溃恢复。 问题的出现是因为许多文件系统操作涉及对磁盘的多次写入，并且在一部分写入后崩溃可能会使磁盘上的文件系统处于不一致的状态。 例如，假设在文件截断期间发生崩溃（将文件的长度设置为零并释放其内容块）。 根据磁盘写入的顺序，崩溃可能会留下一个索引节点引用标记为空闲的内容块，或者它可能会留下一个已分配但未引用的内容块。</p><p>后者相对良性，但引用释放块的 inode 很可能在重启后导致严重问题。 重启后，内核可能会将该块分配给另一个文件，现在我们有两个不同的文件无意中指向同一个块。 如果 xv6 支持多用户，这种情况可能是一个安全问题，因为旧文件的所有者将能够读取和写入新文件中的块，新文件由不同的用户拥有。</p><p>xv6 使用简单的日志记录形式解决了文件系统操作期间的崩溃问题。 xv6 系统调用不直接写入磁盘文件系统数据结构。 相反，它会在磁盘上的日志中放置它希望进行的所有磁盘写入的描述。 一旦系统调用记录了它的所有写入，它就会向磁盘写入一条特殊的提交记录，表明该日志包含一个完整的操作。 那时系统调用将写入复制到磁盘文件系统数据结构。 这些写入完成后，系统调用将擦除磁盘上的日志。</p><p>如果系统崩溃并重新启动，文件系统代码会在运行任何进程之前按如下方式从崩溃中恢复。 如果日志被标记为包含一个完整的操作，那么恢复代码会将写入复制到磁盘文件系统中它们所属的位置。 如果日志未标记为包含完整操作，恢复代码将忽略该日志。 恢复代码通过擦除日志完成。</p><p>为什么xv6的log解决文件系统操作时崩溃的问题？ 如果崩溃发生在操作提交之前，那么磁盘上的日志将不会被标记为完整，恢复代码将忽略它，磁盘的状态就好像操作还没有开始一样。 如果崩溃发生在操作提交之后，那么恢复将重放操作的所有写入，如果操作已经开始将它们写入磁盘数据结构，则可能会重复它们。 在任何一种情况下，日志都使操作相对于崩溃具有原子性：恢复后，所有操作的写入都出现在磁盘上，或者都不出现。</p><p>8.5 log design</p><p>日志驻留在已知的固定位置，在超级块中指定。 它由一个标头块和一系列更新的块副本（“记录的块”）组成。 标头块包含一组扇区号，每个记录块一个，以及日志块的计数。 磁盘头块中的计数为零，表示日志中没有事务，或者为非零，表示日志包含一个完整的已提交事务，并具有指定数量的记录块。 Xv6 在事务提交时写入标头块，而不是之前，并在将记录的块复制到文件系统后将计数设置为零。 因此，交易中途的崩溃将导致日志头块中的计数为零； 提交后的崩溃将导致非零计数。<br>每个系统调用的代码都指示写入序列的开始和结束，这些写入序列对于崩溃而言必须是原子的。 为了允许不同进程并发执行文件系统操作，日志系统可以将多个系统调用的写入累积到一个事务中。 因此，单个提交可能涉及多个完整系统调用的写入。 为了避免跨事务拆分系统调用，日志系统仅在没有文件系统调用正在进行时才提交。</p><p>一起提交多个事务的想法称为组提交。组提交减少了磁盘操作的数量，因为它将一次提交的固定成本分摊到多个操作中。 组提交还同时为磁盘系统提供更多并发写入，也许允许磁盘在单个磁盘旋转期间将它们全部写入。 xv6 的 virtio 驱动不支持这种批处理，但 xv6 的文件系统设计允许。</p><p>xv6 在磁盘上专门分配了固定数量的空间来保存日志。 事务中系统调用写入的块总数必须适合该空间。 这有两个后果。不允许单个系统调用写入比日志中的空间更多的不同块。 对于大多数系统调用来说这不是问题，但是其中两个可能会写入许多块：write 和 unlink。一次大文件写入可能会写入很多数据块和很多位图块以及一个inode块； 取消链接一个大文件可能会写入许多位图块和一个索引节点。 Xv6 的 write 系统调用将大型写入分解为适合日志的多个较小的写入，并取消链接不会引起问题，因为实际上 xv6 文件系统只使用一个位图块。 日志空间有限的另一个后果是日志系统不允许系统调用启动，除非可以确定系统调用的写入将适合日志中剩余的空间。</p><p>8.6 code : logging</p><p>系统调用中日志的典型用法如下所示：begin_op (kernel&#x2F;log.c:127) 等待直到日志系统当前未提交，并且直到有足够的未保留日志空间来保存来自该调用的写入。 log.outstanding 统计已保留日志空间的系统调用数； 总保留空间是 log.outstanding 乘以 MAXOPBLOCKS。 增加 log.outstanding 既可以保留空间又可以防止在此系统调用期间发生提交。 代码保守地假设每个系统调用最多可以写入 MAXOPBLOCKS 个不同的块.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">begin_op();<br>...<br>bp = bread(...);<br>bp -&gt; data[...] = ...;<br>log_write(bp);<br>...<br>end_op();<br></code></pre></td></tr></table></figure><p>系统调用中日志的典型用法如下所示：begin_op (kernel&#x2F;log.c:127) 等待直到日志系统当前未提交，并且直到有足够的未保留日志空间来保存来自该调用的写入。 log.outstanding 统计已保留日志空间的系统调用数； 总保留空间是 log.outstanding 乘以 MAXOPBLOCKS。 增加 log.outstanding 既可以保留空间又可以防止在此系统调用期间发生提交。 代码保守地假设每个系统调用最多可以写入 MAXOPBLOCKS 个不同的块</p><p>log_write (kernel&#x2F;log.c:215) 充当 bwrite 的代理。 它在内存中记录块的扇区号，在磁盘上的日志中为其保留一个槽，并将缓冲区固定在块缓存中以防止块缓存将其驱逐。 该块必须保留在缓存中直到提交：在此之前，缓存的副本是修改的唯一记录； 在提交之后才能将其写入磁盘上的位置； 并且同一事务中的其他读取必须看到修改。 log_write 通知当一个块在单个事务中被多次写入时，并在日志中为该块分配相同的槽。 这种优化通常称为吸收。 例如，包含多个文件的 inode 的磁盘块在一个事务中被多次写入是很常见的。 通过将多个磁盘写入合并为一个，文件系统可以节省日志空间并可以获得更好的性能，因为只需要将磁盘块的一个副本写入磁盘。</p><p>end_op (kernel&#x2F;log.c:147) 首先减少未完成的系统调用的计数。 如果计数现在为零，它会通过调用 commit() 来提交当前事务。 这个过程有四个阶段。 write_log() (kernel&#x2F;log.c:179) 将事务中修改的每个块从缓冲区缓存复制到磁盘日志中的槽。 write_head() (kernel&#x2F;log.c:103) 将头块写入磁盘：这是提交点，写入后崩溃将导致恢复从日志中重放事务的写入。 install_trans (kernel&#x2F;log.c:69) 从日志中读取每个块并将其写入文件系统中的适当位置。 最后 end_op 写入计数为零的日志头； 这必须在下一个事务开始写入记录块之前发生，这样崩溃就不会导致使用一个事务的标头和后续事务的标头进行恢复记录块。</p><p>recover_from_log (kernel&#x2F;log.c:117) 从 initlog (kernel&#x2F;log.c:55) 调用，它在第一个用户进程运行之前从 fsinit(kernel&#x2F;fs.c:42) 调用 (kernel&#x2F;proc .c:520）。 它读取日志标头，并在标头指示日志包含已提交的事务时模仿 end_op 的操作。</p><p>日志的使用示例发生在文件写入 (kernel&#x2F;file.c:135) 中。 交易看起来像这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">begin_op();<br>ilock(f -&gt; ip);<br>r = writei(f -&gt; ip, ...);<br>iunlock(f -&gt; ip);<br>end_op();<br></code></pre></td></tr></table></figure><p>此代码包含在一个循环中，该循环一次将大量写入分解为仅几个扇区的单个事务，以避免日志溢出。作为此事务的一部分，对 writei 的调用写入许多块：文件的索引节点、一个或多个位图块以及一些数据块。</p><p>8.7 code : block allocator</p><p>文件和目录内容存储在磁盘块中，磁盘块必须从空闲池中分配。 Xv6 的块分配器在磁盘上维护一个空闲位图，每个块一个位。 零位表示相应的块是免费的； 一位表示它正在使用中。 程序 mkfs 设置与引导扇区、超级块、日志块、inode 块和位图块对应的位。</p><p>块分配器提供两个功能：balloc 分配一个新的磁盘块，bfree 释放一个块。 Balloc 在 (kernel&#x2F;fs.c:71) 处的 balloc 循环考虑每个块，从块 0 开始直到 sb.size，文件系统中的块数。 它寻找位图位为零的块，表示它是空闲的。 如果 balloc 找到这样的块，它会更新位图并返回该块。 为了提高效率，循环被分成两部分。 外循环读取每个位图位块。 内部循环检查单个位图块中的所有每块位数 (BPB) 位。 如果两个进程试图同时分配一个块，则可能发生的竞争被缓冲区缓存一次只允许一个进程使用任何一个位图块这一事实所阻止。</p><p>Bfree (kernel&#x2F;fs.c:90) 找到正确的位图块并清除正确的位。 bread 和 brelse 隐含的独占使用再次避免了显式锁定的需要。<br>与本章其余部分描述的大部分代码一样，balloc 和 bfree 必须在事务内部调用。</p><p>8.8 inode layer</p><p>术语 inode 可以具有两个相关含义之一。 它可能指的是包含文件大小和数据块编号列表的磁盘数据结构。 或者“inode”可能指的是内存中的 inode，它包含磁盘 inode 的副本以及内核所需的额外信息。</p><p>磁盘上的 inode 被打包到称为 inode 块的连续磁盘区域中。 每个 inode 的大小都相同，因此给定一个数字 n 很容易找到磁盘上的第 n 个 inode。 事实上，这个数字 n，称为 inode 编号或 i-number，是在实现中识别 inode 的方式。<br>磁盘 inode 由 struct dinode (kernel&#x2F;fs.h:32) 定义。 类型字段区分文件、目录和特殊文件（设备）。 零类型表示磁盘上的 inode 是空闲的。 nlink 字段计算引用此 inode 的目录条目的数量，以便识别何时应释放磁盘上的 inode 及其数据块。 大小字段记录了文件中内容的字节数。 addrs数组记录了块号保存文件内容的磁盘块。<br>内核将活动 inode 的集合保存在内存中一个名为 itable 的表中； struct inode (kernel&#x2F;file.h:17) 是磁盘上 struct dinode 的内存副本。 仅当有 C 指针指向该 inode 时，内核才会将 inode 存储在内存中。 ref 字段计算引用内存中 inode 的 C 指针的数量，如果引用计数降为零，内核将从内存中丢弃 inode。 iget 和 iput 函数获取和释放指向 inode 的指针，修改引用计数。 指向 inode 的指针可以来自文件描述符、当前工作目录和临时内核代码（如 exec）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dinode</span> &#123;</span><br>  <span class="hljs-type">short</span> type;           <span class="hljs-comment">// File type</span><br>  <span class="hljs-type">short</span> major;          <span class="hljs-comment">// Major device number (T_DEVICE only)</span><br>  <span class="hljs-type">short</span> minor;          <span class="hljs-comment">// Minor device number (T_DEVICE only)</span><br>  <span class="hljs-type">short</span> nlink;          <span class="hljs-comment">// Number of links to inode in file system</span><br>  uint size;            <span class="hljs-comment">// Size of file (bytes)</span><br>  uint addrs[NDIRECT+<span class="hljs-number">1</span>];   <span class="hljs-comment">// Data block addresses</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>xv6 的 inode 代码中有四种锁或类锁机制。itable.lock 保护一个 inode 最多出现在 inode 表中一次的不变量，以及一个 inmemory inode 的 ref 字段计算指向 inode 的内存指针的数量的不变量。每个内存中的 inode 都有一个包含睡眠锁的锁定字段，它确保对 inode 的字段（例如文件长度）以及 inode 的文件或目录内容块的独占访问。 一个 inode 的 ref，如果它大于零，会导致系统在表中维护 inode，而不是为不同的 inode 重新使用表条目。 最后，每个 inode 包含一个 nlink 字段（在磁盘上，如果在内存中则复制到内存中），用于计算引用文件的目录条目的数量； 如果 inode 的链接数大于零，xv6 将不会释放它。<br>iget() 返回的 struct inode 指针在对应的 iput() 调用之前保证有效； inode 不会被删除，指针指向的内存也不会被其他 inode 重新使用。 iget() 提供对一个 inode 的非独占访问，因此可以有多个指向同一个 inode 的指针。 文件系统代码的许多部分都依赖于 iget() 的这种行为，既可以保持对索引节点（如打开的文件和当前目录）的长期引用，又可以防止竞争，同时避免操作多个索引节点（例如路径名）的代码中出现死锁）。</p><p>iget 返回的 struct inode 可能没有任何有用的内容。 为了确保它拥有磁盘 inode 的副本，代码必须调用 ilock。 这将锁定索引节点（以便其他进程无法锁定它）并从磁盘读取索引节点（如果尚未读取）。iunlock 释放 inode 上的锁。 将 inode 指针的获取与锁定分开有助于在某些情况下避免死锁，例如在目录查找期间。 多个进程可以持有一个指向 iget 返回的 inode 的 C 指针，但一次只有一个进程可以锁定 inode。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// in-memory copy of an inode</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> &#123;</span><br>  uint dev;           <span class="hljs-comment">// Device number</span><br>  uint inum;          <span class="hljs-comment">// Inode number</span><br>  <span class="hljs-type">int</span> ref;            <span class="hljs-comment">// Reference count</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sleeplock</span> <span class="hljs-title">lock</span>;</span> <span class="hljs-comment">// protects everything below here</span><br>  <span class="hljs-type">int</span> valid;          <span class="hljs-comment">// inode has been read from disk?</span><br><br>  <span class="hljs-type">short</span> type;         <span class="hljs-comment">// copy of disk inode</span><br>  <span class="hljs-type">short</span> major;<br>  <span class="hljs-type">short</span> minor;<br>  <span class="hljs-type">short</span> nlink;<br>  uint size;<br>  uint addrs[NDIRECT+<span class="hljs-number">1</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p>inode 表仅存储内核代码或数据结构持有 C 指针的 inode。 它的主要工作是同步多个进程的访问。 inode表也恰好缓存了常用的inode，但缓存是次要的； 如果一个 inode 被频繁使用，buffer cache 可能会将它保存在内存中。 修改内存中 inode 的代码使用 iupdate 将其写入磁盘。</p><p>8.10 code: inode content</p><p>磁盘上的 inode 结构 struct dinode 包含一个大小和一个块号数组（见图 8.3）。inode 数据位于 dinode 的地址数组中列出的块中。 第一个 NDIRECT 数据块列在数组的第一个 NDIRECT 条目中； 这些块称为直接块。 下一个 NINDIRECT 数据块不在 inode 中列出，而是在称为间接块的数据块中列出。 addrs 数组中的最后一项给出了间接块的地址。<br>因此，文件的前 12 kB ( NDIRECT x BSIZE) 字节可以从 inode 中列出的块加载，而接下来的 256 kB ( NINDIRECT x BSIZE) 字节只能在查询间接块后加载。 这是一个很好的磁盘表示，但对客户端来说是一个复杂的表示。 函数 bmap 管理表示，以便更高级别的例程，例如我们将很快看到的 readi 和 writei，不需要管理这种复杂性。 Bmap 返回 inode ip 的第 bn 个数据块的磁盘块号。 如果 ip 还没有这样的块，bmap 会分配一个。</p><img src="/2023/03/18/MIT6-S081-chapter8/83.png" class="" title="架构图"><p>函数 bmap (kernel&#x2F;fs.c:378) 首先选择简单的情况：第一个 NDIRECT 块列在 inode 本身 (kernel&#x2F;fs.c:383-387) 中。 接下来的 NINDIRECT 块列在 ip-&gt;addrs[NDIRECT] 的间接块中。 bmap 读取间接块 (kernel&#x2F;fs.c:394)，然后从块内的正确位置读取块号 (kernel&#x2F;fs.c:395)。 如果块号超过NDIRECT+NINDIRECT，bmap panic； writei 包含防止这种情况发生的检查 (kernel&#x2F;fs.c:494)。</p><p>bmap 根据需要分配块。 ip-&gt;addrs[] 或零间接条目表示没有分配块。 当 bmap 遇到零时，它会用新块的数量替换它们，按需分配 (kernel&#x2F;fs.c:384-385) (kernel&#x2F;fs.c:392-393)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Return the disk block address of the nth block in inode ip.</span><br><span class="hljs-comment">// If there is no such block, bmap allocates one.</span><br><span class="hljs-type">static</span> uint<br><span class="hljs-title function_">bmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ip, uint bn)</span><br>&#123;<br>  uint addr, *a;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br><br>  <span class="hljs-keyword">if</span>(bn &lt; NDIRECT)&#123;<br>    <span class="hljs-keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="hljs-number">0</span>)<br>      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);<br>    <span class="hljs-keyword">return</span> addr;<br>  &#125;<br>  bn -= NDIRECT;<br><br>  <span class="hljs-keyword">if</span>(bn &lt; NINDIRECT)&#123;<br>    <span class="hljs-comment">// Load indirect block, allocating if necessary.</span><br>    <span class="hljs-keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="hljs-number">0</span>)<br>      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);<br>    bp = bread(ip-&gt;dev, addr);<br>    a = (uint*)bp-&gt;data;<br>    <span class="hljs-keyword">if</span>((addr = a[bn]) == <span class="hljs-number">0</span>)&#123;<br>      a[bn] = addr = balloc(ip-&gt;dev);<br>      log_write(bp);<br>    &#125;<br>    brelse(bp);<br>    <span class="hljs-keyword">return</span> addr;<br>  &#125;<br><br>  panic(<span class="hljs-string">&quot;bmap: out of range&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>itrunc 释放文件的块，将 inode 的大小重置为零。 Itrunc (kernel&#x2F;fs.c:410) 首先释放直接块 (kernel&#x2F;fs.c:416-421)，然后是间接块中列出的块 (kernel&#x2F;fs.c:426-429)，最后 间接块本身 (kernel&#x2F;fs.c:431-432)。</p><p>bmap 使 readi 和 writei 可以很容易地获取 inode 的数据。 readi (kernel&#x2F;fs.c:456) 首先确保偏移量和计数不超出文件末尾。 从文件末尾开始的读取返回错误 (kernel&#x2F;fs.c:461-462)，而从文件末尾开始或越过文件末尾的读取返回的字节数少于请求的字节数 (kernel&#x2F;fs.c:463-464) ). 主循环处理文件的每个块，将数据从缓冲区复制到 dst (kernel&#x2F;fs.c:466-475)。 writei (kernel&#x2F;fs.c:487) 与 readi 相同，但有三个例外：从文件末尾开始或越过文件末尾的写入会增大文件，直至达到最大文件大小 (kernel&#x2F;fs.c:494-495) ; 循环将数据复制到缓冲区而不是 out (kernel&#x2F;fs.c:36)； 如果写入扩展了文件，writei 必须更新它的大小。</p><p>readi 和 writei 都从检查 ip-&gt;type &#x3D;&#x3D; T_DEV 开始。 这种情况处理数据不在文件系统中的特殊设备； 我们将在文件描述符层中返回到这种情况。</p><p>函数 stati (kernel&#x2F;fs.c:442) 将 inode 元数据复制到 stat 结构中，该结构通过 stat 系统调用公开给用户程序。</p><p>8.11 code : directory layer</p><p>目录在内部实现很像文件。 它的 inode 类型为 T_DIR，它的数据是一系列目录条目。 每个条目都是一个 struct dirent (kernel&#x2F;fs.h:56)，其中包含一个名称和一个 inode 编号。 名称最多为 DIRSIZ (14) 个字符； 如果更短，则以 NUL (0) 字节结束。 索引节点号为零的目录条目是免费的。</p><p>函数 dirlookup (kernel&#x2F;fs.c:530) 在目录中搜索具有给定名称的条目。<br>如果它找到一个，它返回一个指向相应 inode 的指针，解锁，并将 *poff 设置为目录中条目的字节偏移量，以防调用者希望编辑它。 如果 dirlookup 找到具有正确名称的条目，它会更新 *poff 并返回通过 iget 获得的未锁定 inode。<br>Dirlookup 是 iget 返回未锁定 inode 的原因。 调用者已锁定 dp，因此如果查找是针对当前目录的别名 .，则在返回之前尝试锁定 inode 将尝试重新锁定 dp 和死锁。 （还有更复杂的死锁场景，涉及多个进程和 ..，父目录的别名； . 不是唯一的问题。）调用者可以解锁 dp，然后锁定 ip，确保它一次只持有一个锁。</p><p>函数 dirlink (kernel&#x2F;fs.c:557) 将具有给定名称和 inode 编号的新目录条目写入目录 dp。 如果该名称已存在，dirlink 将返回错误 (kernel&#x2F;fs.c:563-567)。 主循环读取目录条目以查找未分配的条目。 当它找到一个时，它会提前停止循环（kernel&#x2F;fs.c:541-542），并将 off 设置为可用条目的偏移量。 否则，循环以 off 设置为 dp-&gt;size 结束。 无论哪种方式，dirlink 然后通过在偏移量处写入 (kernel&#x2F;fs.c:577-580) 来向目录添加一个新条目。</p><p>8.12 code: path names</p><p>路径名称查找涉及对 dirlookup 的一系列调用，每个路径组件调用一次。<br>Namei (kernel&#x2F;fs.c:664) 评估路径并返回相应的 inode。 函数 nameiparent 是一个变体：它在最后一个元素之前停止，返回父目录的 inode 并将最后一个元素复制到 name 中。 两者都调用广义函数 namex 来完成实际工作。</p><p>Namex (kernel&#x2F;fs.c:629) 首先决定路径评估从哪里开始。 如果路径以斜杠开头，则计算从根开始； 否则，从当前目录开始计算 (kernel&#x2F;fs.c:633-636)。<br>然后它使用 skipelem 依次考虑路径的每个元素 (kernel&#x2F;fs.c:638)。 循环的每次迭代都必须在当前 inode ip 中查找名称。 迭代从锁定 ip 并检查它是否是一个目录开始。 如果不是，则查找失败 (kernel&#x2F;fs.c:639-643)。 （锁定 ip 是必要的，不是因为 ip-&gt;type 可以在脚下改变——它不能——而是因为在 ilock 运行之前，不能保证 ip-&gt;type 已经从磁盘加载。）如果调用是 nameiparent 并且这是 最后一个路径元素，循环提前停止，按照 nameiparent 的定义； 最终的路径元素已经被复制到 name 中，所以 namex 只需要返回解锁的 ip (kernel&#x2F;fs.c:644-648)。<br>最后，循环使用 dirlookup 查找路径元素，并通过设置 ip &#x3D; next (kernel&#x2F;fs.c:649-654) 为下一次迭代做准备。 当循环用完路径元素时，它返回 ip。</p><p>过程 namex 可能需要很长时间才能完成：它可能涉及多个磁盘操作来读取路径名中遍历的目录的 inode 和目录块（如果它们不在缓冲区缓存中）。 Xv6 经过精心设计，因此如果一个内核线程对 namex 的调用在磁盘 I&#x2F;O 上被阻塞，则另一个内核线程查找不同的路径名可以并发进行。 Namex 分别锁定路径中的每个目录，以便可以并行进行不同目录中的查找。</p><p>这种并发性带来了一些挑战。 例如，当一个内核线程正在查找路径名时，另一个内核线程可能正在通过取消链接目录来更改目录树。<br>一个潜在的风险是查找可能正在搜索已被另一个内核线程删除的目录，并且其块已被重新用于另一个目录或文件。<br>xv6 避免了这样的竞争。 例如，在 namex 中执行 dirlookup 时，查找线程持有目录锁，dirlookup 返回一个使用 iget 获得的 inode。<br>iget 增加 inode 的引用计数。 只有从 dirlookup 接收到 inode 后，namex 才会释放对目录的锁定。 现在另一个线程可能会取消索引节点与目录的链接，但 xv6 不会删除索引节点，因为索引节点的引用计数仍然大于零。<br>另一个风险是死锁。 例如next在查找“.”时指向与ip相同的inode。 在释放对 ip 的锁定之前锁定 next 将导致死锁。 为避免此死锁，namex 在获取下一个锁之前解锁目录。 在这里我们再次看到为什么 iget 和 ilock 之间的分离很重要。</p><p>8.13 file descriptor layer</p><p>Unix 界面的一个很酷的方面是 Unix 中的大多数资源都表示为文件，包括控制台、管道等设备，当然还有真实的文件。 文件描述符层是实现这种一致性的层。<br>正如我们在第 1 章中看到的，xv6 为每个进程提供了自己的打开文件表或文件描述符。<br>每个打开的文件都由一个结构文件 (kernel&#x2F;file.h:1) 表示，它是一个 inode 或管道的包装器，加上一个 I&#x2F;O 偏移量。 每次调用 open 都会创建一个新的打开文件（一个新的结构文件）：如果多个进程独立打开同一个文件，不同的实例将具有不同的 I&#x2F;O 偏移量。 另一方面，一个打开的文件（同一个文件结构）可以在一个进程的文件表中出现多次，也可以在多个进程的文件表中出现。 如果一个进程使用 open 打开文件，然后使用 dup 创建别名或使用 fork 与子进程共享，就会发生这种情况。 引用计数跟踪对特定打开文件的引用数。 文件可以打开以供读取或写入或两者兼而有之。 可读和可写字段跟踪这一点。</p><p>系统中所有打开的文件都保存在一个全局文件表 ftable 中。 文件表有分配文件（filealloc）、创建重复引用（filedup）、释放引用（fileclose）、读写数据（fileread和filewrite）等函数。<br>前三个遵循现在熟悉的形式。 Filealloc (kernel&#x2F;file.c:30) 扫描文件表寻找一个未被引用的文件（f-&gt;ref &#x3D;&#x3D; 0）并返回一个新的引用； filedup (kernel&#x2F;file.c:48) 增加引用计数； 和 fileclose (kernel&#x2F;file.c:60) 递减它。 当文件的引用计数达到零时，fileclose 根据类型释放底层管道或 inode。<br>函数filestat、fileread和filewrite实现了对文件的stat、read和write操作。 Filestat (kernel&#x2F;file.c:88) 只允许在 inode 上调用 stati。 Fileread 和 filewrite 检查打开模式是否允许该操作，然后将调用传递给管道或 inode 实现。 如果文件表示一个 inode，fileread 和 filewrite 使用 I&#x2F;O 偏移量作为操作的偏移量，然后将其推进 (kernel&#x2F;file.c:122-123) (kernel&#x2F;file.c:153-154)。 管道没有偏移的概念。 回想一下，inode 函数要求调用者处理锁定 (kernel&#x2F;file.c:94-96) (kernel&#x2F;file.c:121-124) (kernel&#x2F;file.c:163-166)。 inode 锁定有一个方便的副作用，即读写偏移量是自动更新的，因此同时对同一文件的多次写入不会覆盖彼此的数据，尽管它们的写入可能会交错结束。</p><p>8.14 code : sytem calls</p><p>使用较低层提供的功能，大多数系统调用的实现都是微不足道的（参见（kernel&#x2F;sysfile.c））。 有一些call值得仔细研究。<br>函数 sys_link 和 sys_unlink 编辑目录，创建或删除对 inode 的引用。 它们是使用事务的强大功能的另一个很好的例子。 Sys_link (kernel&#x2F;sysfile.c:120) 首先获取它的参数，两个字符串旧的和新的 (kernel&#x2F;sysfile.c:125)。 假设 old 存在并且不是目录 (kernel&#x2F;sysfile.c:129-132)，sys_link 增加其 ip-&gt;nlink 计数。 然后 sys_link 调用 nameiparent 找到 new (kernel&#x2F;sysfile.c:145) 的父目录和最终路径元素，并创建一个指向 old 的 inode (kernel&#x2F;sysfile.c:148) 的新目录条目。 新的父目录必须存在并且与现有 inode 位于同一设备上：inode 编号仅在单个磁盘上具有唯一含义。 如果出现这样的错误，sys_link 必须返回并递减 ip-&gt;nlink。<br>事务简化了实现，因为它需要更新多个磁盘块，但我们不必担心执行它们的顺序。 他们要么全部成功，要么全无。 例如，在没有事务的情况下，在创建链接之前更新 ip-&gt;nlink 会使文件系统暂时处于不安全状态，其间的崩溃可能会导致严重破坏。 有了交易，我们就不必担心这个了。</p><p>Sys_link 为现有 inode 创建一个新名称。 函数 create (kernel&#x2F;sysfile.c:242) 为新 inode 创建一个新名称。 它是三个文件创建系统调用的概括：用 O_CREATE 标志打开创建一个新的普通文件，mkdir 创建一个新目录，mkdev 创建一个新的设备文件。 和sys_link一样，create开始时调用nameiparent获取父目录的inode。 然后它调用 dirlookup 来检查名称是否已经存在 (kernel&#x2F;sysfile.c:252)。 如果名称确实存在，则 create 的行为取决于它被用于哪个系统调用：open 与 mkdir 和 mkdev 具有不同的语义。 如果 create 代表 open (type &#x3D;&#x3D; T_FILE) 使用并且存在的名称本身就是一个常规文件，则 open 将其视为成功，因此 create 也是如此 (kernel&#x2F;sysfile.c:256)。 否则，它是一个错误 (kernel&#x2F;sysfile.c:257-258)。 如果该名称尚不存在，则 create 现在会使用 ialloc (kernel&#x2F;sysfile.c:261) 分配一个新的 inode。 如果新 inode 是一个目录，create 会用 . 和 .. 条目。 最后，现在数据已正确初始化，create 可以将其链接到父目录 (kernel&#x2F;sysfile.c:274)。 create和sys_link一样，同时持有两个inode锁：ip和dp。 没有死锁的可能，因为 inode ip 是新分配的：系统中没有其他进程会持有 ip 的锁然后尝试锁定 dp。</p><p>使用create，很容易实现sys_open、sys_mkdir、sys_mknod。 sys_open (kernel&#x2F;sysfile.c:287) 是最复杂的，因为创建一个新文件只是它能做的一小部分。 如果 open 传递了 O_CREATE 标志，它会调用 create (kernel&#x2F;sysfile.c:301)。 否则，它调用 namei (kernel&#x2F;sysfile.c:307)。 Create 返回一个锁定的 inode，但 namei 没有，所以 sys_open必须锁定 inode 本身。 这提供了一个方便的地方来检查目录是否只打开用于读取，而不是用于写入。 假设 inode 是通过某种方式获得的，sys_open 分配一个文件和一个文件描述符 (kernel&#x2F;sysfile.c:325)，然后填充文件 (kernel&#x2F;sysfile.c:337-342)。 请注意，没有其他进程可以访问部分初始化的文件，因为它仅在当前进程的表中。<br>第 7 章检查了在我们甚至拥有文件系统之前管道的实现。 函数 sys_pipe 通过提供一种创建管道对的方法将该实现连接到文件系统。它的参数是一个指向两个整数空间的指针，它将记录两个新的文件描述符。然后它分配管道并安装文件描述符。</p><p>8.15 real world</p><p>实际操作系统中的缓冲区缓存比 xv6 的复杂得多，但它有两个相同的目的：缓存和同步对磁盘的访问。 Xv6 的缓冲区缓存，与 V6 一样，使用简单的最近最少使用 (LRU) 驱逐策略； 可以实施许多更复杂的策略，每个策略都适合某些工作负载，但对其他工作负载则不利。 更高效的 LRU 缓存将消除链表，而不是使用哈希表进行查找，使用堆进行 LRU 驱逐。 现代缓冲区高速缓存通常与虚拟内存系统集成以支持内存映射文件。<br>Xv6 的日志系统效率低下。 提交不能与文件系统系统调用同时发生。 系统记录整个块，即使块中只有几个字节被更改。 它执行同步日志写入，一次一个块，每个块可能需要整个磁盘旋转时间。 真正的日志记录系统解决了所有这些问题。</p><p>日志记录不是提供崩溃恢复的唯一方法。 早期的文件系统在重新引导期间使用清除程序（例如，UNIX fsck 程序）来检查每个文件和目录以及块和 inode 空闲列表，查找并解决不一致。 对于大型文件系统，清理可能需要数小时，并且在某些情况下无法以导致原始系统调用成为原子的方式解决不一致。 从日志中恢复要快得多，并导致系统调用在崩溃时是原子的。<br>xv6 使用与早期 UNIX 相同的 inode 和目录的基本磁盘布局； 多年来，这一计划一直非常顽固。 BSD 的 UFS&#x2F;FFS 和 Linux 的 ext2&#x2F;ext3 使用本质上相同的数据结构。 文件系统布局中效率最低的部分是目录，它需要在每次查找期间对所有磁盘块进行线性扫描。 当目录只有几个磁盘块时，这是合理的，但对于包含许多文件的目录来说，这是昂贵的。 Microsoft Windows 的 NTFS、macOS 的 HFS 和 Solaris 的 ZFS（仅举几例）将目录实现为磁盘上的块平衡树。 这很复杂但保证对数时间目录查找。</p><p>xv6 对磁盘故障处理很naive：如果磁盘操作失败，xv6 会崩溃。 这是否合理取决于硬件：如果操作系统位于使用冗余来屏蔽磁盘故障的特殊硬件之上，操作系统可能很少看到故障，因此恐慌是可以接受的。 另一方面，使用普通磁盘的操作系统应该预见到故障并更优雅地处理它们，这样一个文件中的块丢失不会影响文件系统其余部分的使用。<br>xv6 要求文件系统适合一个磁盘设备并且大小不变。 随着大型数据库和多媒体文件对存储的要求越来越高，操作系统正在开发消除“每个文件系统一个磁盘”瓶颈的方法。 基本方法是将许多磁盘组合成一个逻辑磁盘。 RAID 等硬件解决方案仍然是最受欢迎的，但当前的趋势是尽可能多地在软件中实现这种逻辑。 这些软件实现通常允许丰富的功能，例如通过动态添加或删除磁盘来增加或缩小逻辑设备。 当然，一个存储层可以<br>动态增长或收缩需要一个可以执行相同操作的文件系统：xv6 使用的固定大小的 inode 块数组在此类环境中无法正常工作。 将磁盘管理与文件系统分开可能是最干净的设计，但两者之间复杂的接口导致一些系统（如 Sun 的 ZFS）将它们结合起来。<br>xv6 的文件系统缺少现代文件系统的许多其他特性； 例如，它不支持快照和增量备份。<br>现代 Unix 系统允许使用与磁盘存储相同的系统调用来访问多种资源：命名管道、网络连接、远程访问的网络文件系统以及监视和控制接口，例如 &#x2F;proc。 与 xv6 的文件读取和文件写入中的 if 语句不同，这些系统通常为每个打开的文件提供一个函数指针表，每个操作一个，并调用函数指针来调用该 inode 的调用实现。 网络<br>文件系统和用户级文件系统提供将这些调用转换为网络 RPC 并在返回之前等待响应的功能。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MIT6.S081-chapter7</title>
    <link href="/2023/03/15/MIT6-S081-chapter7/"/>
    <url>/2023/03/15/MIT6-S081-chapter7/</url>
    
    <content type="html"><![CDATA[<ol start="7"><li>scheduling</li></ol><p>任何操作系统运行的进程都可能多于计算机的 CPU，因此需要一个计划来在进程之间分时分配 CPU。理想情况下，共享对用户进程是透明的。 一种常见的方法是通过将进程多路复用到硬件 CPU 上，为每个进程提供它拥有自己的虚拟 CPU 的错觉。 本章解释 xv6 如何实现这种多路复用。</p><p>7.1 multiplexing</p><p>xv6 通过在两种情况下将每个 CPU 从一个进程切换到另一个进程来实现多路复用。 首先，xv6 的睡眠和唤醒机制在进程等待设备或管道 I&#x2F;O 完成时切换，或者等待子进程退出，或者在睡眠系统调用中等待。 其次，xv6 周期性地强制切换以应对长时间不休眠计算的进程。 这种多路复用创造了每个进程都有自己的 CPU 的错觉，就像 xv6 使用内存分配器和硬件页表来创造每个进程都有自己的内存的错觉一样。</p><p>实施多路复用会带来一些挑战。 一、如何从一个进程切换到另一个进程？ 虽然上下文切换的想法很简单，但是实现是 xv6 中一些最不透明的代码。 第二，如何以对用户进程透明的方式强制切换？ Xv6 使用硬件定时器中断驱动上下文切换的标准技术。 第三，所有 CPU 在同一共享进程集之间切换，并且需要锁定计划来避免竞争。第四，进程退出时必须释放进程的内存和其他资源，但它不能自己完成所有这些，因为（例如）它无法在仍在使用它的同时释放自己的内核堆栈。 第五，多核机器的每个核心都必须记住它正在执行哪个进程，以便系统调用影响正确进程的内核状态。 最后，sleep 和 wakeup 允许一个进程放弃 CPU 并等待被另一个进程或中断唤醒。需要注意避免导致唤醒通知丢失的竞争。 Xv6 试图尽可能简单地解决这些问题，但是生成的代码却很棘手。</p><img src="/2023/03/15/MIT6-S081-chapter7/71.png" class="" title="架构图"><p>7.2 code : context switching</p><p>上图概述了一个用户进程切换到另一个用户进程所涉及的步骤，用户内核转换（系统调用或中断）到旧的内核线程。上下文切换到当前 CPU 的调度程序线程，上下文切换到新进程的内核线程，陷阱返回到用户级进程。 xv6 调度器每个 CPU 都有一个专用线程（保存的寄存器和堆栈），因为调度器在旧进程的内核堆栈上执行是不安全的：其他一些核心可能会唤醒进程并运行它，这将是一场灾难 在两个不同的内核上使用相同的堆栈。 在本节中，我们将研究在内核线程和调度程序线程之间切换的机制。</p><p>从一个线程切换到另一个涉及保存旧线程的 CPU 寄存器，并恢复新线程先前保存的寄存器； 堆栈指针和程序计数器被保存和恢复的事实意味着 CPU 将切换堆栈并切换它正在执行的代码。</p><p>函数 <code>swtch</code> 执行内核线程切换的保存和恢复。 swtch 不直接了解线程； 它只是保存和恢复 32 个 RISC-V 寄存器集，称为上下文。当进程放弃 CPU 时，进程的内核线程调用 swtch 来保存自己的上下文并返回到调度程序上下文。 每个上下文都包含在结构上下文 (kernel&#x2F;proc.h:2) 中，它本身包含在进程的 struct proc 或 CPU 的 struct cpu 中。 swtch 有两个参数：<code>struct context *old</code> 和 <code>struct context *new</code>。 它将当前寄存器保存在旧寄存器中，从新寄存器中加载寄存器，然后返回。</p><p>让我们通过 swtch 进入调度程序来跟踪一个过程。 我们在第 4 章中看到，中断结束时的一种可能性是 usertrap 调用 yield。 yield依次调用sched，sched调用swtch将当前上下文保存在<code>p-&gt;context</code>中，并切换到之前保存在<code>cpu-&gt;scheduler</code>(kernel&#x2F;proc.c:490)中的scheduler上下文。</p><p>swtch (kernel&#x2F;swtch.S:3) 只保存被调用者保存的寄存器； C 编译器在调用者中生成代码以将调用者保存的寄存器保存在堆栈中。 swtch 知道每个寄存器字段在结构上下文中的偏移量。 它不保存程序计数器。 相反，swtch 保存 ra 寄存器，它保存调用 swtch 的返回地址。 现在 swtch 从新的上下文中恢复寄存器，该上下文保存由先前的 swtch 保存的寄存器值。 当swtch返回时，返回到恢复的ra寄存器指向的指令，也就是新线程之前调用swtch的指令。 此外，它返回新线程的堆栈，因为那是恢复的 sp 指向的地方。</p><p>在我们的示例中，sched 调用 swtch 以切换到 cpu-&gt;scheduler，即每个 CPU 的调度程序上下文。 该上下文是在过去调度程序调用 swtch (kernel&#x2F;proc.c:456) 切换到现在正在放弃 CPU 的进程时保存的。 当我们一直跟踪的 swtch 返回时，它返回的不是 sched，而是 scheduler，栈指针在当前 CPU 的调度程序栈中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">sched</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> intena;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>    <span class="hljs-keyword">if</span>(!holding(&amp;p -&gt;lock))&#123;<br>        panic(<span class="hljs-string">&quot;sched p -&gt; lock&quot;</span>);<br>    <span class="hljs-keyword">if</span>(mycpu()-&gt;noff != <span class="hljs-number">1</span>)<br>    panic(<span class="hljs-string">&quot;sched locks&quot;</span>);<br>    <span class="hljs-keyword">if</span>(p-&gt;state == RUNNING)<br>    panic(<span class="hljs-string">&quot;sched running&quot;</span>);<br>    <span class="hljs-keyword">if</span>(intr_get())<br>    panic(<span class="hljs-string">&quot;sched interruptible&quot;</span>);<br><br>  intena = mycpu()-&gt;intena;<br>  swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context);<br>  mycpu()-&gt;intena = intena;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>7.3 code :scheduling(调度器)</p><p>最后一节介绍了 swtch 的底层细节； 现在让我们将 swtch 作为给定的并检查通过调度程序从一个进程的内核线程切换到另一个进程。 调度器以每个 CPU 一个特殊线程的形式存在，每个线程都运行调度器函数。 该函数负责选择下一步要运行的进程。 想要放弃 CPU 的进程必须获得自己的进程锁 p-&gt;lock，释放它持有的任何其他锁，更新自己的状态 (p-&gt;state)，然后调用 sched。 您可以在 yield (kernel&#x2F;proc.c:496)、sleep 和 exit 中看到这个序列。 Sched 仔细检查了其中一些要求 (kernel&#x2F;proc.c:480-485)，然后检查了一个含义：由于持有锁，因此应该禁用中断。 最后sched调用swtch将当前上下文保存在p-&gt;context中，切换到cpu-&gt;scheduler中的scheduler上下文。 Swtch 返回调度程序的堆栈，就好像调度程序的 swtch 已经返回一样。调度程序继续其 for 循环，找到要运行的进程，切换到它，然后循环重复。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">scheduler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpu</span> *<span class="hljs-title">c</span> =</span> mycpu();<br>    c -&gt; proc = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(;;)&#123;<br>        intr_on();<br>        <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p ++)&#123;<br>            acquire(&amp;p -&gt; lock);<br>            <span class="hljs-keyword">if</span>(p -&gt; state == RUNNABLE)&#123;<br>                <span class="hljs-comment">// switch to chosen process. It is the process&#x27;s job</span><br>                <span class="hljs-comment">// to release  its lock and then reacquire it</span><br>                <span class="hljs-comment">// before jumping back to us.</span><br>                p -&gt; state = RUNNING;<br>                c -&gt; proc = p;<br>                swtch(&amp;c -&gt; context, &amp;p -&gt; context);<br>                <span class="hljs-comment">// process is done running for now</span><br>                <span class="hljs-comment">// it should have changed its p -&gt; state before coming back</span><br>                c -&gt; proc = <span class="hljs-number">0</span>;<br>            &#125;<br>            release(&amp;p -&gt; lock);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们刚刚看到 xv6 在对 swtch 的调用中持有 p-&gt;lock：swtch 的调用者必须已经持有锁，并且锁的控制传递给切换到的代码。 这种约定对于锁是不常见的； 通常获取锁的线程也负责释放锁，这样更容易判断正确性。 对于上下文切换，有必要打破这个约定，因为 p-&gt;lock 保护进程状态和上下文字段的不变量<br>在 swtch 中执行时不正确。 如果 p-&gt;lock 在 swtch 期间未保持，则可能出现的一个问题示例：不同的 CPU 可能会在 yield 将其状态设置为 RUNNABLE 之后但在 swtch 导致它停止使用自己的内核堆栈之前决定运行该进程。 结果将是两个 CPU 在同一个堆栈上运行，这将导致混乱。</p><p>内核线程放弃其 CPU 的唯一地方是在 sched 中，它总是切换到调度程序中的相同位置，调度程序（几乎）总是切换到以前调用 sched 的某个内核线程。 因此，如果要打印出 xv6 切换的行号线程，人们会观察到以下简单模式：(kernel&#x2F;proc.c:456), (kernel&#x2F;proc.c:490), (kernel&#x2F;proc.c:456), (kernel&#x2F;proc.c:490), 等等。 有意通过线程切换将控制转移给彼此的过程有时称为协程； 在这个例子中，sched 和 scheduler 是彼此的协程。</p><p>有一种情况是调度程序对 swtch 的调用没有在 sched 中结束。 allocproc 将新进程的上下文 ra 寄存器设置为 forkret (kernel&#x2F;proc.c:508)，以便它的第一个 swtch “返回”到该函数的开始。 Forkret 的存在是为了释放 p-&gt;lock； 否则，因为新进程需要像从 fork 返回一样返回到用户空间，它可以改为从 usertrapret 开始。</p><p>调度程序（kernel&#x2F;proc.c:438）运行一个循环：找到一个要运行的进程，运行它直到它yield，repeat。 调度程序循环遍历进程表以寻找可运行的进程，一个具有 p-&gt;state&#x3D;&#x3D; RUNNABLE 的进程。 一旦找到进程，它就会设置每个 CPU 当前进程变量 c-&gt;proc，将进程标记为 RUNNING，然后调用 swtch 开始运行 (kernel&#x2F;proc.c:451-456)。</p><p>考虑调度代码结构的一种方法是，它对每个进程强制执行一组不变量，并在这些不变量不正确时保持 p-&gt;lock。 一个不变的是，如果一个进程正在运行，定时器中断的收益必须能够安全地从该进程切换出去； 这意味着 CPU 寄存器必须保存进程的寄存器值（即 swtch 没有将它们移动到上下文中），并且 c-&gt;proc 必须引用进程。 另一个不变量是，如果一个进程是 RUNNABLE 的，那么空闲 CPU 的调度程序运行它必须是安全的； 这意味着 p-&gt;context 必须保存进程的寄存器（即，它们实际上不在真实寄存器中），没有 CPU 在进程的内核堆栈上执行，并且没有 CPU 的 c-&gt;proc 引用该进程。 请注意，当 p-&gt;lock 被持有时，这些属性通常不成立。</p><p>保持上述不变量是 xv6 经常在一个线程中获取 p-&gt;lock 并在另一个线程中释放它的原因，例如在 yield 中获取并在 scheduler 中释放。 一旦 yield 开始修改正在运行的进程的状态以使其成为 RUNNABLE，锁必须保持<br>保持到不变量恢复：最早的正确释放点是在调度程序（在其自己的堆栈上运行）清除 c-&gt;proc 之后。 同样，一旦调度程序开始将一个 RUNNABLE 进程转换为 RUNNING，直到内核线程完全运行（在 swtch 之后，例如在 yield 中），才能释放锁。</p><p>7.4 code: mycpu and myproc</p><p>xv6 通常需要一个指向当前进程的 proc 结构的指针。 在单处理器上，可以有一个指向当前进程的全局变量。 这在多核机器上不起作用，因为每个核心执行不同的进程。 解决这个问题的方法是利用每个内核都有自己的一组寄存器这一事实； 我们可以使用其中一个寄存器来帮助查找每个核心的信息。</p><p>xv6 为每个 CPU 维护一个 struct cpu (kernel&#x2F;proc.h:22)，它记录当前在该 CPU 上运行的进程（如果有的话），为 CPU 的调度程序线程保存的寄存器，以及管理中断所需的嵌套自旋锁的数量 禁用。 函数 mycpu (kernel&#x2F;proc.c:72) 返回指向当前 CPU 的 struct cpu 的指针。 RISC-V 给它的 CPU 编号，给每个 CPU 一个 hartid。 xv6 确保每个 CPU 的 hartid 在内核中存储在该 CPU 的 tp 寄存器中。这允许 mycpu 使用 tp 索引一组 cpu 结构以找到正确的那个。</p><p>确保 CPU 的 tp 始终保存 CPU 的 hartid 有点复杂。 mstart 在 CPU 启动序列的早期设置 tp 寄存器，同时仍处于机器模式 (kernel&#x2F;start.c:51)。 usertrapret 将tp 保存在trampoline 页面中，因为用户进程可能会修改tp。 最后，uservec 恢复从用户空间进入内核时保存的 tp (kernel&#x2F;trampoline.S:70)。 编译器保证永远不会使用 tp 寄存器。 如果 xv6 可以在需要时向 RISC-V 硬件询问当前的 hartid 会更方便，但 RISC-V 只允许在机器模式下，而不是在管理模式下。</p><p>cpuid 和 mycpu 的返回值是脆弱的：如果计时器中断并导致线程让步，然后转移到不同的 CPU，之前返回的值将不再正确。 为避免此问题，xv6 要求调用者禁用中断，并且仅在使用完返回的 struct cpu 后才启用它们。</p><p>函数 myproc (kernel&#x2F;proc.c:80) 返回当前 CPU 上运行的进程的 struct proc 指针。 myproc 禁用中断，调用 mycpu，从 struct cpu 中获取当前进程指针 (c-&gt;proc)，然后启用中断。 即使启用了中断，myproc 的返回值也可以安全使用：如果定时器中断将调用进程移动到不同的 CPU，其 struct proc 指针将保持不变。</p><p>7.5 sleep and wakeup</p><p>调度和锁有助于从另一个线程中隐藏一个线程的操作，但我们还需要帮助线程有意交互的抽象。 例如，xv6 中管道的读取器可能需要等待写入进程产生数据；父进程需要等待子进程退出，而读取磁盘的进程需要等待磁盘硬件完成读取。 xv6 内核在这些情况下（以及许多其他情况下）使用称为睡眠和唤醒的机制。 睡眠允许内核线程等待特定事件； 另一个线程可以调用唤醒来指示等待事件的线程应该恢复。 睡眠和唤醒通常称为序列协调或条件同步机制。</p><p>睡眠和唤醒提供了一个相对低级的同步接口。 为了激发它们在 xv6 中的工作方式，我们将使用它们来构建一个更高级别的同步机制，称为信号量，用于协调生产者和消费者（xv6 不使用信号量）。 信号量维护一个计数并提供两个操作。 “V”操作（对于生产者）增加计数。 “P”操作（对于消费者）等待计数不为零，然后递减计数并返回。 如果只有一个生产者线程和一个消费者线程，并且它们在不同的 CPU 上执行，并且编译器没有过度优化，那么这个实现是正确的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>    <span class="hljs-type">int</span> count;<br>&#125;;<br><span class="hljs-type">void</span> <span class="hljs-title function_">V</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> semaphore *s)</span>&#123;<br>    acquire(&amp;s -&gt; lock);<br>    s -&gt; count += <span class="hljs-number">1</span>;<br>    release(&amp;s -&gt; lock);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">P</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> semaphore *s)</span>&#123;<br>    <span class="hljs-keyword">while</span>(s -&gt; count == <span class="hljs-number">0</span>)&#123;<br>        ;<br>        acquire(&amp;s -&gt; lock);<br>        s-&gt; count -= <span class="hljs-number">1</span>;<br>        release(&amp;s -&gt; lock);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的实现是昂贵的。 如果生产者很少行动，消费者将花费大部分时间在 while 循环中旋转，希望得到一个非零计数。 消费者的 CPU 可能会通过反复轮询 s-&gt;count 来找到比忙碌等待更有效率的工作。 避免忙等待需要一种方法让消费者让出 CPU 并仅在 V 增加计数后恢复。</p><p>这是朝着这个方向迈出的一步，但正如我们将看到的那样还不够。 让我们想象一对调用，sleep 和 wakeup，它们的工作方式如下。 Sleep(chan) 在任意值 chan 上休眠，称为等待通道。 Sleep 使调用进程进入睡眠状态，释放 CPU 用于其他工作。 Wakeup(chan) 唤醒所有在 chan 上休眠的进程（如果有），导致它们的睡眠调用返回。 如果没有进程在等待 chan，wakeup 什么都不做。 我们可以改变信号量使用睡眠和唤醒的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> V（<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore</span> *<span class="hljs-title">s</span>)&#123;</span><br>    acquire(&amp;s -&gt; lock);<br>    s -&gt; count ++;<br>    wakeup(s);<br>    release(&amp;s -&gt; lock);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">P</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> semaphore *s)</span>&#123;<br>    <span class="hljs-keyword">while</span>(s -&gt; count == <span class="hljs-number">0</span>)&#123;<br>        sleep(s);<br>        acquire(&amp;s -&gt; lock); <span class="hljs-comment">//</span><br>        s -&gt; count --;<br>        release(&amp;s -&gt; lock);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>P 现在放弃了 CPU 而不是自旋，这很好。 然而，事实证明，在不遭受所谓的丢失唤醒问题的情况下使用此接口设计睡眠和唤醒并不是一件容易的事。 假设 P 在第 212 行发现 s-&gt;count &#x3D;&#x3D; 0。当 P 在第 212 行和第 213 行之间时，V 在另一个 CPU 上运行：它将 s-&gt;count 更改为非零并调用 wakeup，这发现没有进程在休眠并且 因此什么都不做。现在 P 在第 213 行继续执行：它调用睡眠并进入睡眠状态。 这导致了一个问题：P 在等待已经发生的 V 调用时处于睡眠状态。 除非我们很幸运并且生产者再次调用 V，否则即使计数不为零，消费者也会永远等待。这个问题的根源在于，P 仅在 s-&gt;count &#x3D;&#x3D; 0 时才休眠的不变量被在错误时刻运行的 V 所违反。 保护不变量的错误方法是移动 P 中的锁获取（下面以黄色突出显示），以便它对计数的检查和对睡眠的调用是原子的：</p><p>人们可能希望这个版本的 P 会避免丢失唤醒，因为锁阻止了 V 在第 313 行和第 314 行之间执行。它做到了这一点，但它也会死锁：P 在休眠时持有锁，因此 V 将永远阻塞等待锁。</p><p>我们将通过改变sleep的接口来修复上述方案：调用者必须将条件锁传递给sleep，以便在调用进程被标记为睡眠并等待睡眠通道后释放锁。 锁将强制并发 V 等待，直到 P 完成让自己进入睡眠状态，以便唤醒将找到睡眠中的消费者并将其唤醒。 一旦消费者再次醒来， sleep 在返回之前重新获取锁。 我们新的正确睡眠&#x2F;唤醒<br>方案可按如下方式使用（更改以黄色突出显示）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> V（<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore</span> *<span class="hljs-title">s</span>)&#123;</span><br>    acquire(&amp;s -&gt; lock);<br>    s -&gt; count ++;<br>    wakeup(s);<br>    release(&amp;s -&gt; lock);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">P</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> semaphore *s)</span>&#123;<br>    <span class="hljs-keyword">while</span>(s -&gt; count == <span class="hljs-number">0</span>)&#123;<br>        sleep(s, &amp;s -&gt; lock);<span class="hljs-comment">//</span><br>        acquire(&amp;s -&gt; lock); <br>        s -&gt; count --;<br>        release(&amp;s -&gt; lock);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>P 持有 s-&gt;lock 的事实阻止了 V 在 P 检查 c-&gt;count 和调用睡眠之间尝试唤醒它。 但是请注意，我们需要 sleep 以原子方式释放 s-&gt;lock 并将消费进程置于睡眠状态，以避免丢失唤醒。</p><p>7.6 cde : sleep and wakeup</p><p>xv6的sleep（kernel&#x2F;proc.c:529）和wakeup（kernel&#x2F;proc.c:560）提供了上面最后一个例子所示的接口，它们的实现（加上如何使用它们的规则）确保不会丢失 唤醒。 基本思路是让sleep将当前进程标记为SLEEPING，然后调用sched释放CPU； wakeup 查找在给定等待通道上休眠的进程并将其标记为 RUNNABLE。 sleep 和 wakeup 的调用者可以使用任何一个双方都方便的号码作为通道。 xv6 经常使用涉及等待的内核数据结构的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">void</span> *chan, <span class="hljs-keyword">struct</span> spinlock *lk)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>    acquire(&amp;p -&gt;lock);<br>    release(lk);<br>    p -&gt; chan = chan;<br>    p -&gt; state = SLEEPING;<br>    sched();<br>    p -&gt; chan = <span class="hljs-number">0</span>;<br>    release(&amp;p -&gt; lock);<br>    acquire(lk);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">wakeup</span><span class="hljs-params">(<span class="hljs-type">void</span> *chan)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br>    <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p ++)&#123;<br>        <span class="hljs-keyword">if</span>(p != myproc())&#123;<br>            acquire(&amp;p -&gt; lock);<br>            <span class="hljs-keyword">if</span>(p -&gt; state == SLEEPING &amp;&amp; p -&gt; chan == chan)&#123;<br>                p -&gt; state = RUNNING;<br>            &#125;<br>            release(&amp;p -&gt; lock);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>睡眠获取 p-&gt;lock (kernel&#x2F;proc.c:540)。 现在进入睡眠状态的进程持有 p-&gt;lock 和 lk。 持有 lk 在调用者中是必要的（在示例中，P）：它确保没有其他进程（在示例中，一个正在运行的 V）可以启动对 wakeup(chan) 的调用。 现在 sleep 持有 p-&gt;lock，释放 lk 是安全的：一些其他进程可能开始调用 wakeup(chan)，但 wakeup 将等待获取 p-&gt;lock，因此将等到 sleep 完成放置 进入睡眠过程，防止唤醒错过睡眠。</p><p>现在 sleep 持有 p-&gt;lock 而没有其他，它可以通过记录睡眠通道、将进程状态更改为 SLEEPING 并调用 sched (kernel&#x2F;proc.c:544-547) 来使进程进入睡眠状态。稍后就会清楚为什么在进程被标记为 SLEEPING 之前不释放 p-&gt;lock 是至关重要的（由调度程序）。</p><p>在某个时候，进程将获取条件锁，设置睡眠者正在等待的条件，并调用 wakeup(chan)。 在保持条件 lock1 时调用 wakeup 很重要。 唤醒循环遍历进程表 (kernel&#x2F;proc.c:560)。 它获取它检查的每个进程的 p-&gt;lock，这既是因为它可以操纵该进程的状态，也是因为 p-&gt;lock 确保 sleep 和 wakeup 不会错过彼此。 当 wakeup 发现进程处于 SLEEPING 状态并具有匹配的 chan 时，它会将进程的状态更改为 RUNNABLE。 下次调度程序运行时，它将看到该进程已准备好运行。</p><p>为什么睡眠和唤醒的锁定规则确保睡眠过程不会错过唤醒？ 休眠进程持有条件锁或它自己的 p-&gt;lock 或两者，从它检查条件之前的一个点到它被标记为 SLEEPING 之后的一个点。 调用 wakeup 的进程在 wakeup 的循环中持有这两个锁。 因此，唤醒者要么在消费线程检查条件之前使条件为真；要么 或者唤醒者的唤醒在标记为 SLEEPING 后严格检查睡眠线程。 然后 wakeup 会看到睡眠过程并将其唤醒（除非有其他东西先唤醒它）。</p><p>有时会出现多个进程在同一个通道上休眠的情况； 例如，多个进程从管道读取。 一次调用 wakeup 就会把它们全部唤醒。 其中一个将首先运行并获取调用 sleep 时使用的锁，并且（在管道的情况下）读取管道中等待的任何数据。 其他进程会发现，虽然被唤醒了，但是没有数据可读。 从他们的角度来看，唤醒是“虚假的”，他们必须再次入睡。 出于这个原因，睡眠总是在检查条件的循环内调用。</p><p>如果 sleep&#x2F;wakeup 的两次使用不小心选择了同一个频道，也没有什么坏处：他们会看到虚假的唤醒，但是如上所述的循环可以容忍这个问题。 睡眠&#x2F;唤醒的大部分魅力在于它既轻量（无需创建特殊数据结构来充当睡眠通道）又提供了一个间接层（调用者无需知道他们正在与哪个特定进程交互）。</p><p>7.7 code:pipes</p><p>一个更复杂的使用睡眠和唤醒来同步生产者和消费者的例子是 xv6 的管道实现。 我们在第 1 章中看到了管道接口：写入管道一端的字节被复制到内核缓冲区，然后可以从管道的另一端读取。 以后的章节将研究围绕管道的文件描述符支持，但现在让我们看一下 pipewrite 和 piperead 的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pipewrite</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pipe *pi, uint64 addr, <span class="hljs-type">int</span> n)</span><br>&#123;<br>  <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">pr</span> =</span> myproc();<br><br>  acquire(&amp;pi-&gt;lock);<br>  <span class="hljs-keyword">while</span>(i &lt; n)&#123;<br>    <span class="hljs-keyword">if</span>(pi-&gt;readopen == <span class="hljs-number">0</span> || pr-&gt;killed)&#123;<br>      release(&amp;pi-&gt;lock);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pi-&gt;nwrite == pi-&gt;nread + PIPESIZE)&#123; <span class="hljs-comment">//DOC: pipewrite-full</span><br>      wakeup(&amp;pi-&gt;nread);<br>      sleep(&amp;pi-&gt;nwrite, &amp;pi-&gt;lock);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-type">char</span> ch;<br>      <span class="hljs-keyword">if</span>(copyin(pr-&gt;pagetable, &amp;ch, addr + i, <span class="hljs-number">1</span>) == <span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">break</span>;<br>      pi-&gt;data[pi-&gt;nwrite++ % PIPESIZE] = ch;<br>      i++;<br>    &#125;<br>  &#125;<br>  wakeup(&amp;pi-&gt;nread);<br>  release(&amp;pi-&gt;lock);<br><br>  <span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">piperead</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pipe *pi, uint64 addr, <span class="hljs-type">int</span> n)</span><br>&#123;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">pr</span> =</span> myproc();<br>  <span class="hljs-type">char</span> ch;<br><br>  acquire(&amp;pi-&gt;lock);<br>  <span class="hljs-keyword">while</span>(pi-&gt;nread == pi-&gt;nwrite &amp;&amp; pi-&gt;writeopen)&#123;  <span class="hljs-comment">//DOC: pipe-empty</span><br>    <span class="hljs-keyword">if</span>(pr-&gt;killed)&#123;<br>      release(&amp;pi-&gt;lock);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    sleep(&amp;pi-&gt;nread, &amp;pi-&gt;lock); <span class="hljs-comment">//DOC: piperead-sleep</span><br>  &#125;<br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;  <span class="hljs-comment">//DOC: piperead-copy</span><br>    <span class="hljs-keyword">if</span>(pi-&gt;nread == pi-&gt;nwrite)<br>      <span class="hljs-keyword">break</span>;<br>    ch = pi-&gt;data[pi-&gt;nread++ % PIPESIZE];<br>    <span class="hljs-keyword">if</span>(copyout(pr-&gt;pagetable, addr + i, &amp;ch, <span class="hljs-number">1</span>) == <span class="hljs-number">-1</span>)<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  wakeup(&amp;pi-&gt;nwrite);  <span class="hljs-comment">//DOC: piperead-wakeup</span><br>  release(&amp;pi-&gt;lock);<br>  <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个管道都由一个结构管道表示，其中包含一个锁和一个数据缓冲区。 nread 和 nwrite 字段计算从缓冲区读取和写入缓冲区的字节总数。 缓冲区环绕：在 buf[PIPESIZE-1] 之后写入的下一个字节是 buf[0]。 计数不换行。 这个约定让实现区分一个完整的缓冲区（nwrite &#x3D;&#x3D; nread+PIPESIZE）和一个空缓冲区（nwrite &#x3D;&#x3D; nread），但这意味着索引到缓冲区必须使用 buf[nread % PIPESIZE] 而不仅仅是 buf[nread ]（对于 nwrite 也是如此）。</p><p>假设对 piperead 和 pipewrite 的调用同时发生在两个不同的 CPU 上。 Pipewrite (kernel&#x2F;pipe.c:77) 首先获取管道的锁，它保护计数、数据及其相关的不变量。 Piperead (kernel&#x2F;pipe.c:106) 然后也尝试获取锁，但不能。 它在 acquire (kernel&#x2F;spinlock.c:22) 中自旋等待锁。 在 piperead 等待的同时，pipewrite 遍历正在写入的字节 (addr[0..n-1])，依次将每个字节添加到管道 (kernel&#x2F;pipe.c:95)。 在此循环期间，缓冲区可能会填满 (kernel&#x2F;pipe.c:88)。 在这种情况下，pipewrite 调用 wakeup 来提醒所有睡眠中的读者缓冲区中有数据在等待，然后在 &amp;pi-&gt;nwrite 上休眠以等待读者从缓冲区中取出一些字节。 Sleep 释放 pi-&gt;lock 作为使 pipewrite 进程进入睡眠的一部分。</p><p>现在 pi-&gt;lock 可用，piperead 设法获取它并进入其临界区：它发现 pi-&gt;nread !&#x3D; pi-&gt;nwrite (kernel&#x2F;pipe.c:113) (pipewrite 进入休眠状态，因为 pi- &gt;nwrite &#x3D;&#x3D; pi-&gt;nread+PIPESIZE (kernel&#x2F;pipe.c:88)), 所以它落入 for<br>循环，将数据复制出管道 (kernel&#x2F;pipe.c:120)，然后将 nread 增加复制的字节数。 现在有那么多字节可用于写入，因此 piperead 调用 wakeup (kernel&#x2F;pipe.c:127) 以在它返回之前唤醒任何休眠的写入器。 <code>wakeup</code>发现一个进程在 &amp;pi-&gt;nwrite 上休眠，该进程正在运行 pipewrite 但在缓冲区已满时停止。 它将该进程标记为RUNNABLE。</p><p>管道代码为读取器和写入器使用单独的睡眠通道（pi-&gt;nread 和 pi-&gt;nwrite）； 这可能会使系统在有许多读者和作者等待同一个管道的不太可能发生的情况下更有效率。 管道代码在检查睡眠条件的循环中睡眠； 如果有多个读者或作者，除了第一个醒来的进程之外的所有进程都会看到条件仍然为假并再次睡眠。</p><p>7.8 code : wait, exit, and kill</p><p>sleep和wakeup可以用于多种等待。 第 1 章中介绍的一个有趣的例子是子进程的exit与其父进程的wait之间的交互。 子进程死亡，父进程可能正在wait，或者可能正在做其他事情； 在后一种情况下，随后的 wait 调用必须观察到子进程的死亡，也许在它调用 exit 很久之后。 xv6 记录子进程死亡直到 wait 观察到它的方式是 exit 将调用者置于 ZOMBIE 状态，它会一直停留直到父进程的 wait 注意到它，将子进程的状态更改为 UNUSED，复制子进程的退出状态，并返回子进程ID给父进程。 如果父进程先于子进程退出，则父进程将子进程交给 init 进程，该进程会一直调用 wait； 因此每个子进程都有一个父进程来清理它。 一个挑战是避免同时父子进程等待和退出以及同时退出和退出之间的竞争和死锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Wait for a child process to exit and return its pid.</span><br><span class="hljs-comment">// Return -1 if this process has no children.</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(uint64 addr)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">np</span>;</span><br>  <span class="hljs-type">int</span> havekids, pid;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  acquire(&amp;wait_lock);<br><br>  <span class="hljs-keyword">for</span>(;;)&#123;<br>    <span class="hljs-comment">// Scan through table looking for exited children.</span><br>    havekids = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(np = proc; np &lt; &amp;proc[NPROC]; np++)&#123;<br>      <span class="hljs-keyword">if</span>(np-&gt;parent == p)&#123;<br>        <span class="hljs-comment">// make sure the child isn&#x27;t still in exit() or swtch().</span><br>        acquire(&amp;np-&gt;lock);<br><br>        havekids = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(np-&gt;state == ZOMBIE)&#123;<br>          <span class="hljs-comment">// Found one.</span><br>          pid = np-&gt;pid;<br>          <span class="hljs-keyword">if</span>(addr != <span class="hljs-number">0</span> &amp;&amp; copyout(p-&gt;pagetable, addr, (<span class="hljs-type">char</span> *)&amp;np-&gt;xstate,<br>                                  <span class="hljs-keyword">sizeof</span>(np-&gt;xstate)) &lt; <span class="hljs-number">0</span>) &#123;<br>            release(&amp;np-&gt;lock);<br>            release(&amp;wait_lock);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>          &#125;<br>          freeproc(np);<br>          release(&amp;np-&gt;lock);<br>          release(&amp;wait_lock);<br>          <span class="hljs-keyword">return</span> pid;<br>        &#125;<br>        release(&amp;np-&gt;lock);<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// No point waiting if we don&#x27;t have any children.</span><br>    <span class="hljs-keyword">if</span>(!havekids || p-&gt;killed)&#123;<br>      release(&amp;wait_lock);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// Wait for a child to exit.</span><br>    sleep(p, &amp;wait_lock);  <span class="hljs-comment">//DOC: wait-sleep</span><br>  &#125;<br>&#125;<br><br><br><span class="hljs-comment">// Exit the current process.  Does not return.</span><br><span class="hljs-comment">// An exited process remains in the zombie state</span><br><span class="hljs-comment">// until its parent calls wait().</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-keyword">if</span>(p == initproc)<br>    panic(<span class="hljs-string">&quot;init exiting&quot;</span>);<br><br>  <span class="hljs-comment">// Close all open files.</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fd = <span class="hljs-number">0</span>; fd &lt; NOFILE; fd++)&#123;<br>    <span class="hljs-keyword">if</span>(p-&gt;ofile[fd])&#123;<br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span> =</span> p-&gt;ofile[fd];<br>      fileclose(f);<br>      p-&gt;ofile[fd] = <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br><br>  begin_op();<br>  iput(p-&gt;cwd);<br>  end_op();<br>  p-&gt;cwd = <span class="hljs-number">0</span>;<br><br>  acquire(&amp;wait_lock);<br><br>  <span class="hljs-comment">// Give any children to init.</span><br>  reparent(p);<br><br>  <span class="hljs-comment">// Parent might be sleeping in wait().</span><br>  wakeup(p-&gt;parent);<br>  <br>  acquire(&amp;p-&gt;lock);<br><br>  p-&gt;xstate = status;<br>  p-&gt;state = ZOMBIE;<br><br>  release(&amp;wait_lock);<br><br>  <span class="hljs-comment">// Jump into the scheduler, never to return.</span><br>  sched();<br>  panic(<span class="hljs-string">&quot;zombie exit&quot;</span>);<br>&#125;<br><br><br><span class="hljs-comment">// Kill the process with the given pid.</span><br><span class="hljs-comment">// The victim won&#x27;t exit until it tries to return</span><br><span class="hljs-comment">// to user space (see usertrap() in trap.c).</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">kill</span><span class="hljs-params">(<span class="hljs-type">int</span> pid)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br><br>  <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++)&#123;<br>    acquire(&amp;p-&gt;lock);<br>    <span class="hljs-keyword">if</span>(p-&gt;pid == pid)&#123;<br>      p-&gt;killed = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">if</span>(p-&gt;state == SLEEPING)&#123;<br>        <span class="hljs-comment">// Wake process from sleep().</span><br>        p-&gt;state = RUNNABLE;<br>      &#125;<br>      release(&amp;p-&gt;lock);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    release(&amp;p-&gt;lock);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>wait通过获取 wait_lock (kernel&#x2F;proc.c:384) 开始。 原因是 wait_lock 充当条件锁，有助于确保父级不会错过退出的子级的唤醒。然后等待扫描进程表。 如果它找到处于 ZOMBIE 状态的子进程，它会释放该子进程的资源及其 proc 结构，将子进程的退出状态复制到提供给 wait 的地址（如果它不为 0），并返回子进程的进程 ID。 如果 wait 找到孩子但没有一个退出，它会调用 sleep 等待他们中的任何一个退出（kernel&#x2F;proc.c:426），然后再次扫描。 wait经常持有两把锁，wait_lock和某个进程的np-&gt;lock； 避免死锁的顺序首先是 wait_lock 和然后np-&gt;lock。</p><p>exit (kernel&#x2F;proc.c:340) 记录退出状态，释放一些资源，调用reparent将其子进程交给init进程，唤醒等待中的父进程，将调用者标记为zombie，并永久产生 CPU。 exit 在此序列中同时持有 wait_lock 和 p-&gt;lock。 它持有 wait_lock 因为它是 wakeup(p-&gt;parent) 的条件锁，防止等待中的父进程失去唤醒。 exit 也必须为这个序列保持 p-&gt;lock，以防止等待中的父进程在子进程最终调用 swtch 之前看到子进程处于 ZOMBIE 状态。 Exit 以与 wait 相同的顺序获取这些锁以避免死锁。</p><p>exit 在将其状态设置为 ZOMBIE 之前唤醒父级可能看起来不正确，但这是安全的：虽然唤醒可能导致父级运行，但等待中的循环无法检查子级，直到子级的 p-&gt;lock 被释放 调度程序，所以 wait 不能查看退出进程，直到 exit 将其状态设置为 ZOMBIE (kernel&#x2F;proc.c:372)。</p><p>exit 允许进程自行终止，而 kill (kernel&#x2F;proc.c:579) 允许一个进程请求另一个进程终止。 kill 直接销毁受害进程太复杂了，因为受害进程可能正在另一个 CPU 上执行，也许是在对内核数据结构进行一系列敏感更新的过程中。 因此 kill 做的很少：它只是设置受害者的 p-&gt;killed 并且，如果它正在睡觉，将其唤醒。 最终受害者将进入或离开内核，此时如果设置了 p-&gt;killed，usertrap 中的代码将调用 exit。 如果受害者在用户空间运行，它很快就会通过系统调用或因为定时器（或其他一些设备）中断而进入内核。</p><p>如果受害者进程处于睡眠状态，kill 调用 wakeup 将使受害者从睡眠中返回。 这是潜在的危险，因为正在等待的条件可能不正确。然而，xv6 对 sleep 的调用总是包含在 while 循环中，在 sleep 返回后重新测试条件。 一些对 sleep 的调用也在循环中测试 p-&gt;killed ，如果设置了则放弃当前活动。 只有在这种放弃是正确的情况下才会这样做。 例如，如果设置了 killed 标志，则管道读写代码返回； 最终代码将返回到 trap，这将再次检查 p-&gt;killed 并退出。</p><p>一些 xv6 睡眠循环不检查 p-&gt;killed，因为代码处于一个应该是原子的多步系统调用的中间。 virtio 驱动程序 (kernel&#x2F;virtio_disk.c:273) 就是一个例子：它不检查 p-&gt;killed，因为磁盘操作可能是一组写入操作中的一个，这些操作都是为了将文件系统留在 一个正确的状态。 在等待磁盘 I&#x2F;O 时被杀死的进程将不会退出，直到它完成当前系统调用并且 usertrap 看到 killed 标志。</p><p>7.9 process locking</p><p>每个进程关联的锁（p-&gt;lock）是xv6中最复杂的锁。 考虑 p-&gt;lock 的一种简单方法是，在读取或写入以下任何 struct proc 字段时必须持有它：p &gt;state、p-&gt;chan、p-&gt;killed、p-&gt;xstate 和 p- &gt;pid。 这些字段可以被其他进程使用，或者被其他内核上的调度程序线程使用，所以很自然地必须用锁来保护它们。</p><p>但是，p-&gt;lock 的大多数用途是保护 xv6 进程数据结构和算法的更高级别方面。 下面是 p-&gt;lock 做的全部事情：</p><ul><li>与 p-&gt;state 一起，它可以防止在为新进程分配 proc[] 时发生竞争。</li><li>它在进程创建或销毁时将进程隐藏起来。</li><li>它防止父等待收集已将其状态设置为 ZOMBIE 但尚未让出 CPU 的进程。</li><li>它阻止另一个核心的调度程序在将其状态设置为 RUNNABLE 之后但在完成 swtch 之前决定运行一个让步进程。</li><li>它确保只有一个内核的调度程序决定运行一个 RUNNABLE 进程。</li><li>它防止计时器中断导致进程在处于swtch 时产生。</li><li>与条件锁一起，它有助于防止唤醒忽略正在调用睡眠但尚未完成让出CPU 的进程。</li><li>它防止 kill 的受害者进程退出，并可能在 kill 检查 p-&gt;pid 和设置 p-&gt;killed 之间重新分配。</li><li>它使 kill 对 p-&gt;state 的检查和写入成为原子操作。</li></ul><p>p-&gt;parent 字段由全局锁 wait_lock 保护，而不是由 p-&gt;lock 保护。 只有进程的父进程修改 p-&gt;parent，尽管该字段由进程本身和其他搜索其子进程的进程读取。wait_lock 的目的是在 wait 休眠等待任何子进程退出时充当条件锁。 一个退出的子进程持有 wait_lock 或 p-&gt;lock 直到它把它的状态设置为 ZOMBIE，唤醒它的父进程，并让出 CPU。 wait_lock 还序列化父进程和子进程的并发退出，以便保证 init 进程（继承子进程）从等待中唤醒。 wait_lock 是全局锁而不是每个父进程中的每个进程锁，因为在进程获取它之前，它无法知道其父进程是谁。</p><p>7.10 real world</p><p>xv6采用的scheduling的方式为<em>round robin</em>，即每个进程轮流运行，实际的操作系统的scheduling可以让进程有优先级。当高优先级和低优先级共享一个锁而低优先级拿到这个锁的情况下，将产生<em>priority inversion</em>，将导致大量高优先级进程等候低优先级进程，从而形成<em>convoy</em>。</p><p>对整个进程列表查找睡眠在<code>chan</code>上的进程是非常低效的，更好的解决方案是将<code>chan</code>替代为一个可以存储睡眠在此结构体上的进程列表的结构体，比如Linux的<em>wait queue</em></p><p>xv6中的<code>wakeup</code>唤醒所有睡在<code>chan</code>上的进程，然后这些进程将竞争检查sleep conditoin，这种情况通常需要被避免。许多是采用<code>signal</code>和<code>broadcast</code>两种唤醒模式，前面一种只唤醒一个进程，后面一种唤醒所有进程。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MIT6.S081-chapter6</title>
    <link href="/2023/03/10/MIT6-S081-chapter6/"/>
    <url>/2023/03/10/MIT6-S081-chapter6/</url>
    
    <content type="html"><![CDATA[<p>六、locking</p><p>大多数内核，包括 xv6，交错执行多个活动。 交错的来源之一是多处理器硬件：具有多个独立执行的 CPU 的计算机，例如 xv6 的 RISC-V。 这些多个 CPU 共享物理 RAM，xv6 利用共享来维护所有 CPU 读写的数据结构。 这种共享增加了一个 CPU 读取数据结构而另一个 CPU 正在更新数据结构的可能性，甚至多个 CPU 同时更新相同数据的可能性； 如果没有细心的设计，这种并行访问很可能会产生不正确的结果或损坏的数据结构。 即使在单处理器上，内核也可能在多个线程之间切换 CPU，导致它们的执行相互交错。 最后，如果中断发生在错误的时间，则修改与某些可中断代码相同的数据的设备中断处理程序可能会损坏数据。 并发一词是指由于多处理器并行性、线程切换或中断而导致多个指令流交错的情况。</p><p>内核充满了并发访问的数据。 例如，两个 CPU 可以同时调用 kalloc，从而同时从空闲列表的头部弹出。 内核设计者喜欢允许大量的并发，因为它可以通过并行性和响应性提高来提高系统性能。然而，结果是内核设计者花了很多精力说服自己尽管有这种并发性，但仍然是正确的。 有很多方法可以获得正确的代码，其中一些比其他的更容易推理。 以并发下的正确性为目标的策略，以及支持它们的抽象，被称为并发控制技术。</p><p>xv6 根据情况使用多种并发控制技术。 本章重点介绍一种广泛使用的技术：锁。 锁提供互斥，确保一次只有一个 CPU 可以持有锁。 如果程序员为每个共享数据项关联一个锁，并且代码在使用某个项时始终持有关联的锁，那么该项将一次仅由一个 CPU 使用。 在这种情况下，我们说锁保护了数据项。 虽然锁是一种易于理解的并发控制机制，但锁的缺点是它们会扼杀性能，因为它们会序列化并发操作。</p><img src="/2023/03/10/MIT6-S081-chapter6/lock1.png" class="" title="架构图"><p>6.1 race conditions</p><p>作为我们为什么需要锁的一个例子，考虑在两个不同的 CPU 上调用 wait 的两个进程。 等待释放子进程的内存。 因此在每个 CPU 上，内核将调用 kfree 来释放子页面。 内核分配器维护一个链表：<code>kalloc()</code> (kernel&#x2F;kalloc.c:69) 从空闲页面列表中弹出一个内存页面，<code>kfree()</code> 将一个页面压入空闲列表。 为了获得最佳性能，我们可能希望两个父进程的 kfree 并行执行，而不必相互等待，但考虑到 xv6 的 kfree 实现，这是不正确的。图 6.1 更详细地说明了设置：链表位于两个 CPU 共享的内存中，这两个 CPU 使用load和store指令来操作链表。 （实际上，处理器有缓存，但从概念上讲，多处理器系统的行为就像有一个共享内存一样。）如果没有并发请求，我们可以按如下方式实现列表push操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">element</span> &#123;</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">element</span> *<span class="hljs-title">next</span>;</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">element</span> *<span class="hljs-title">list</span> =</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">element</span> *<span class="hljs-title">l</span></span><br><span class="hljs-class">    <span class="hljs-title">l</span> =</span> <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span> *l);<br>    l -&gt; data = data; <span class="hljs-comment">//15</span><br>    l -&gt; next = <span class="hljs-built_in">list</span>; <span class="hljs-comment">//16</span><br>    <span class="hljs-built_in">list</span> = l;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/03/10/MIT6-S081-chapter6/lock2.png" class="" title="架构图"><p>如果单独执行，这样的代码是正确的。 但是，如果多个副本同时执行，则代码不正确。 如果两个 CPU 同时执行 push，它们都可能先执行图 6.1 所示的第 15 行，然后再执行第 16 行，这会导致错误的结果，如图 6.2 所示。 然后将有两个列表元素，其 next 设置为列表的前一个值。 当 list 的两个赋值发生在第 16 行时，第二个将覆盖第一个； 第一个赋值中涉及的元素将丢失。</p><p>第 16 行丢失的更新是竞争条件的一个例子。 竞争条件是同时访问内存位置并且至少有一次访问是写入的情况。 一个竞争往往是错误的迹象，更新丢失（如果访问是写入）或读取未完全更新的数据结构。 比赛的结果取决于所涉及的两个 CPU 的确切时间和内存系统如何对它们的内存操作进行排序，这会使竞争引起的错误难以重现和调试。 例如，在调试推送时添加打印语句可能会改变执行时间，足以使竞争消失。避免竞争的通常方法是使用🔒。锁确保互斥，使同一时间只有一个CPU可以执行push的敏感行，这使得上述情况不可能发生。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">element</span> *<span class="hljs-title">list</span> =</span> <span class="hljs-number">0</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock</span> <span class="hljs-title">listlock</span>;</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">element</span> *<span class="hljs-title">l</span>;</span><br>    l = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span> *l);<br>    l -&gt; data = data;<br>    acquire(&amp;listlock);<br>    <span class="hljs-comment">// critical section</span><br>    l -&gt; next = <span class="hljs-built_in">list</span>;<br>    <span class="hljs-built_in">list</span> = l;<br>    release(&amp;listlock);<br>&#125;<br></code></pre></td></tr></table></figure><p>获取和释放之间的指令序列通常称为临界区。 锁通常被称为保护列表。当我们说锁保护数据时，我们的意思是锁保护了一些适用于数据的不变量集合。 不变量是被维护的数据结构的属性跨操作。 通常，操作的正确行为取决于操作开始时不变量是否为真。 该操作可能会暂时违反不变量，但必须在完成之前重新建立它们。 例如，在链表的情况下，不变量是列表指向列表中的第一个元素，每个元素的下一个字段指向下一个元素。 push 的实现暂时违反了这个不变量：在第 17 行，l 指向下一个列表元素，但 list 还没有指向 l（在第 18 行重新建立）。 我们上面检查的竞争条件的发生是因为第二个 CPU 执行了依赖于列表不变量的代码，而它们（暂时）被违反了。 正确使用锁可以确保同一时刻只有一个 CPU 可以对临界区中的数据结构进行操作，这样当数据结构的不变量不成立时，没有 CPU 会执行数据结构操作。</p><p>我们可以将锁视为序列化并发关键部分，以便它们一次运行一个，从而保留不变量（假设关键部分在隔离时是正确的）。 还可以将由同一锁保护的关键部分视为彼此之间的原子性，这样每个关键部分只能看到来自早期关键部分的完整更改集，而永远不会看到部分完成的更新。</p><p>虽然正确使用锁可以使不正确的代码正确，但锁会限制性能。 例如，如果两个进程并发调用 kfree，锁将序列化这两个调用，我们不会从在不同 CPU 上运行它们中获益。 如果多个进程同时想要同一个锁，我们说多个进程发生冲突，或者锁发生争用。 内核设计的一个主要挑战是避免锁争用。 Xv6 做的很少，但复杂的内核专门组织数据结构和算法以避免锁争用。 在列表示例中，内核可以为每个 CPU 维护一个空闲列表，并且只有在 CPU 的列表为空并且它必须从另一个 CPU 窃取内存时才接触另一个 CPU 的空闲列表。 其他用例可能需要更复杂的设计。</p><p>锁的放置对于性能也很重要。 例如，在 push 中将 acquire 移到更早的位置是正确的：将对 acquire 的调用移到第 13 行之前是可以的。这可能会降低性能，因为对 malloc 的调用也会被序列化。 下面的“使用锁”部分提供了一些关于在何处插入获取和释放调用的指南。</p><p>6.2 code: locks</p><p>xv6有两种类型的锁，spinlock和sleep-locks，spinlock的代码位于kernel&#x2F;spinlock.h的<code>struct spinlock</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> &#123;</span><br>    uint locked;  <span class="hljs-comment">//为0时说明这个锁可以获取</span><br>    <span class="hljs-type">char</span> *name;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpu</span> *<span class="hljs-title">cpu</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">acpuire</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spinlock *lk)</span><br>&#123;<br>    <span class="hljs-keyword">for</span>(;;)&#123;<br>        <span class="hljs-keyword">if</span>(lk -&gt; locked == <span class="hljs-number">0</span>)&#123;<br>            lk -&gt; locked = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不幸的是，这种实现并不能保证多处理器上的互斥。 有可能两个CPU同时到达25行，看到lk-&gt;locked为0，然后都通过执行第26行抢到了锁，此时两个不同的CPU都持有了锁，违反了互斥性。 我们需要的是一种使第 25 行和第 26 行作为原子（即不可分割）步骤执行的方法。</p><p>由于锁被广泛使用，多核处理器通常提供实现第 25 和 26 行原子版本的指令。在 RISC-V 上，这条指令是 amoswap r, a。 amoswap 交换a内存地址中的内容和r寄存器中的内容。 也就是说，它交换了寄存器的内容和内存地址。 它以原子方式执行这个序列，使用特殊硬件来防止任何其他 CPU从使用读取和写入之间的内存地址。</p><p>xv6 的 acquire (kernel&#x2F;spinlock.c:22) 使用可移植的 C 库调用 <code>__sync_lock_test_and_set</code>，归结为 amoswap 指令； 返回值是旧的（交换的）内容lk-&gt;locked。 acquire 函数将交换包装在一个循环中，重试（自旋）直到它获得锁。 每次迭代将一个交换到 lk-&gt;locked 并检查先前的值； 如果之前的值为0，那么我们已经获得了锁，跳出循环，交换将设置 lk-&gt;locked到1。 如果之前的值是1，那么其他 CPU 持有锁，而我们以原子方式将1交换到 lk-&gt;locked 的事实并没有改变它的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(__sync_lock_test_and_set(&amp;lk -&gt; locked, <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>)<br>    ;<br></code></pre></td></tr></table></figure><p>获取到锁后，获取记录获取锁的CPU，方便调试。 lk-&gt;cpu 字段受锁保护，只能在持有锁时更改。</p><p>函数release(kernel&#x2F;spinlock.c:47)与acquire相反：它清除lk-&gt;cpu域，然后释放锁。 从概念上讲，该版本只需要将零分配给 lk-&gt;locked。C 标准库允许编译器使用多个存储指令实现赋值，因此 C 赋值对于并发代码而言可能是非原子的。 相反，release 使用执行原子分配的 C 库函数 <code>__sync_lock_release</code>。 这个函数也归结为一条 RISC-V amoswap 指令。</p><p>由于编译器有时候为了性能优化会重新排列代码的执行顺序，对于顺序执行的代码来说，这种重新排列顺序并不会改变代码执行的结果，但是对于并发执行的代码，则可能改变结果，因此需要在<code>acquire</code>和<code>release</code>中用<code>__sync_synchronize()</code>来保证CPU和编译器不进行重新排列顺序。<code>__sync_synchronize()</code>是一个barrier，任何在这一行代码之前的代码都不能reorder到这一行代码的后面。</p><p>6.3 code: using locks</p><p>Xv6 在许多地方使用锁来避免竞争条件。 如上所述，kalloc (kernel&#x2F;kalloc.c:69) 和 kfree (kernel&#x2F;kalloc.c:47) 是一个很好的例子。 尝试练习 1 和 2，看看如果这些函数省略锁会发生什么。 您可能会发现很难触发不正确的行为，这表明很难可靠地测试代码是否没有锁定错误和竞争。 xv6 有一些竞争并非不可能。</p><p>使用锁的一个困难部分是决定使用多少锁以及每个锁应该保护哪些数据和不变量。 有几个基本原则。 首先，任何时候一个 CPU 可以同时写入一个变量，而另一个 CPU 可以读取或写入它，应该使用锁来防止两个操作重叠。 其次，请记住锁保护不变量：如果一个不变量涉及多个内存位置，通常所有这些位置都需要由一个锁保护以确保不变量得到维护。</p><p>上面的规则只说了什么时候需要锁，而没有说什么时候不需要锁，而且为了提高效率重要的是不要锁太多，因为锁会降低并行度。如果并行性不重要，那么可以安排只有一个线程而不用担心锁。 一个简单的内核可以在多处理器上执行此操作，方法是拥有一个锁，该锁必须在进入内核时获取并在退出内核时释放（尽管诸如管道读取或等待之类的系统调用会带来问题）。 许多单处理器操作系统已使用这种方法转换为在多处理器上运行，有时称为“大内核锁”，但该方法牺牲了并行性：一次只有一个 CPU 可以在内核中执行。 如果内核执行任何繁重的计算，使用更大的一组更细粒度的锁会更有效，这样内核就可以同时在多个 CPU 上执行。</p><p>作为粗粒度锁定的一个例子，xv6 的 kalloc.c 分配器有一个由单个锁保护的单个空闲列表。 如果不同 CPU 上的多个进程同时尝试分配页面，则每个进程都必须通过自旋获取来等待轮到它。 自旋会降低性能，因为它不是有用的工作。 如果锁的争用浪费了 CPU 时间的很大一部分，也许可以通过将分配器设计更改为具有多个空闲列表（每个列表都有自己的锁）以允许真正的并行分配来提高性能。</p><p>作为细粒度锁定的一个例子，xv6 对每个文件都有一个单独的锁，因此操作不同文件的进程通常可以在不等待彼此的锁的情况下继续进行。 如果想要允许进程同时写入同一文件的不同区域，文件锁定方案可以做得更细粒度。 最终，锁定粒度决策需要由性能测量和复杂性考虑来驱动。</p><p>6.4 deadlock adn lock ordering</p><p>如果一块代码需要同时拥有多个锁，那么应该让其他需要相同锁的进程按照相同的顺序acquire这些锁，否则可能出现死锁。比如进程1和2都需要锁A和锁B，如果进程1先acquire了锁A，进程2acquire了锁B，那么接下来进程1需要acquire锁B，进程2需要acquire锁A，但是这两个都不能acquire到也无法release各自的锁，就会出现死锁。</p><p>由于<code>sleep</code>在xv6中的机制，xv6中有很多长度为2的lock-order。比如<code>consoleintr</code>中要求先获得<code>cons.lock</code>，当整行输入完毕之后再唤醒等待输入的进程，这需要获得睡眠进程的锁。xv6的文件系统中有一个很长的lock chain，如果要创建一个文件需要同时拥有文件夹的锁、新文件的inode的锁、磁盘块缓冲区的锁、磁盘驱动器的<code>vdisk_lock</code>的锁以及调用进程的<code>p-&gt;lock</code>的锁</p><img src="/2023/03/10/MIT6-S081-chapter6/lock3.png" class="" title="架构图"><p>除了lock ordering之外，锁和中断的交互也可能造成死锁。比如当<code>sys_sleep</code>拥有<code>tickslock</code>时，发生定时器中断，定时器中断的handler也需要acquire<code>tickslock</code>，就会等待<code>sys_sleep</code>释放，但是因为在中断里面，只要不从中断返回<code>sys_sleep</code>就永远无法释放，因此造成了死锁。对这种死锁的解决方法是：如果一个中断中需要获取某个特定的spinlock，那么当CPU获得了这个spinlock之后，该中断必须被禁用。xv6的机制则更加保守：当CPU获取了任意一个lock之后，将disable掉这个CPU上的所有中断（其他CPU的中断保持原样）。当CPU不再拥有spinlock时，将通过<code>pop_off</code>重新使能中断。</p><p>6.5 re-entrant locks</p><p>使用可重入锁（也称为递归锁）似乎可以避免某些死锁和锁排序挑战。 这个想法是，如果锁被一个进程持有并且如果该进程试图再次获取锁，那么内核可以只允许这样做（因为进程已经拥有锁），而不是像 xv6 内核那样调用 panic 。</p><p>然而，事实证明，可重入锁使并发推理变得更加困难：可重入锁打破了锁导致关键部分相对于其他关键部分是原子的直觉。 考虑以下两个函数 f 和 g：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br><span class="hljs-type">int</span> data = <span class="hljs-number">0</span>;<br>f()&#123;<br>    acquire(&amp;lock);<br>    <span class="hljs-keyword">if</span>(data == <span class="hljs-number">0</span>)&#123;<br>        call_once();<br>        h();<br>        data = <span class="hljs-number">1</span>;<br>    &#125;<br>    release(&amp;lock);<br>&#125;<br><br>g()&#123;<br>    acquire(&amp;lock);<br>    <span class="hljs-keyword">if</span>(data == <span class="hljs-number">0</span>)&#123;<br>        call_once();<br>        data = <span class="hljs-number">1</span>;<br>    &#125;<br>    release(&amp;lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>查看此代码片段，直觉是 call_once 只会被调用一次：由 f 或 g，但不会同时被两者调用。</p><p>但是如果允许重入锁，h恰好调用了g，call_once就会被调用两次。<br>如果不允许重入锁，那么 h 调用 g 会导致死锁，这也不是很好。 但是，假设调用 call_once 是一个严重的错误，死锁是更可取的。 内核开发人员会观察到死锁（内核恐慌 kernel panics）并可以修复代码以避免它，而两次调用 call_once 可能会默默地导致难以追踪的错误。</p><p>为此，xv6 使用了更简单易懂的不可重入锁。 然而，只要程序员记住锁定规则，任何一种方法都可以工作。 如果 xv6 要使用可重入锁，则必须修改 acquire 以注意到锁当前由调用线程持有。 还必须以类似于 push_off 的方式向结构自旋锁添加嵌套获取的计数，这将在接下来讨论。</p><p>6.6 locks and interrupt handlers</p><p>一些 xv6 自旋锁保护线程和中断处理程序使用的数据。 例如，clockintr 计时器中断处理程序可能会在内核线程读取 sys_sleep 中的滴答声的同时递增滴答声 (kernel&#x2F;trap.c:163)。 锁 tickslock 序列化这两个访问。</p><p>自旋锁和中断的相互作用会引发潜在的危险。 假设 sys_sleep 持有 tickslock，其 CPU 被定时器中断中断。 clockintr 会尝试获取 tickslock，看到它被持有，并等待它被释放。 在这种情况下，ticklock 将永不释放：只有 sys_sleep 可以释放它，但 sys_sleep 不会继续运行，直到 clockintr 返回。 所以 CPU 会死锁，任何需要锁的代码也会冻结。</p><p>为避免这种情况，如果中断处理程序使用自旋锁，则 CPU 绝不能在启用中断的情况下持有该锁。 xv6 更保守：当 CPU 获取任何锁时，xv6 总是禁用该 CPU 上的中断。 中断仍然可能发生在其他 CPU 上，因此中断的获取可以等待线程释放自旋锁； 只是不在同一个CPU上。</p><p>xv6 在 CPU 没有自旋锁时重新启用中断； 它必须做一点簿记来处理嵌套的关键部分。 acquire 调用 push_off (kernel&#x2F;spinlock.c:89) 和 release 调用 pop_off (kernel&#x2F;spinlock.c:100) 以跟踪当前 CPU 上锁的嵌套级别。 当该计数达到零时，pop_off 恢复存在于最外层临界区开始处的中断启用状态。 intr_off 和 intr_on 函数执行 RISC-V 指令以分别禁用和启用中断。</p><p>在设置 lk-&gt;locked (kernel&#x2F;spinlock.c:28) 之前严格获取调用 push_off 是很重要的。 如果两者颠倒，则在启用中断的情况下保持锁定时会有一个短暂的窗口，不幸的是定时中断会使系统死锁。 同样重要的是release只有在释放锁后才调用pop_off。</p><p>6.7 intruction and memory ordering</p><p>人们很自然地认为程序是按照源代码语句出现的顺序执行的。 然而，许多编译器和 CPU 会乱序执行代码以实现更高的性能。 如果一条指令需要多个周期才能完成，则 CPU 可能会提早发出该指令，以便它可以与其他指令重叠并避免 CPU 停顿。 例如，CPU 可能会注意到在串行指令序列中，A 和 B 并不相互依赖。 CPU 可能首先启动指令 B，因为它的输入在 A 的输入之前准备就绪，或者为了重叠执行 A 和 B。编译器可以通过在语句的指令之前为一个语句发出指令来执行类似的重新排序 在它之前的来源。</p><p>编译器和 CPU 在重新排序时遵循规则，以确保它们不会更改正确编写的串行代码的结果。 然而，这些规则确实允许重新排序，这会改变并发代码的结果，并且很容易导致多处理器上的错误行为。 CPU 的排序规则称为内存模型。</p><p>比如这段push的代码，如果编译器或者CPU把第4行对应的store移动到第6行release之后的某个点，那将是一场灾难：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">l = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span> *l);<br>l -&gt; data = data;<br>acquire(&amp;listlock);<br>l -&gt; next = <span class="hljs-built_in">list</span>;<br><span class="hljs-built_in">list</span> = l;<br>release(&amp;listlock);<br></code></pre></td></tr></table></figure><p>如果发生这样的<code>re-ordering</code>，将有一个窗口，在此期间另一个 CPU 可以获取锁并观察更新的列表，但会看到一个未初始化的<code>list -&gt; next</code>。</p><p>为了告诉硬件和编译器不要执行此类重新排序，xv6 在获取 (kernel&#x2F;spinlock.c:22) 和释放 (kernel&#x2F;spinlock.c:47) 中都使用了 __sync_synchronize()。 <code>__sync_synchronize()</code> 是一个内存屏障：它告诉编译器和 CPU 不要跨屏障重新排序加载或存储。 在几乎所有重要的情况下，xv6 的获取和释放强制顺序中的障碍，因为 xv6 在对共享数据的访问周围使用锁。</p><p>6.8 sleep locks</p><p>spinlock的两个缺点：1. 如果一个进程拥有一个锁很长时间，另外一个企图acquire的进程将一直等待。2. 当一个进程拥有锁的时候，不允许把当前使用的CPU资源切换给其他线程，否则可能导致第二个线程也acquire这个线程，然后一直无法切回到原来的线程，无法release锁，从而导致死锁。</p><p>xv6提供了一种<em>sleep-locks</em>，可以在试图<code>acquire</code>一个被拥有的锁时<code>yield</code> CPU。spin-lock适合短时间的关键步骤，sleep-lock适合长时间的锁。</p><p>6.9 real world</p><p>尽管对并发原语和并行性进行了多年研究，但使用锁进行编程仍然具有挑战性。 通常最好将锁隐藏在更高级别的构造（如同步队列）中，尽管 xv6 不这样做。 如果您使用锁编程，使用尝试识别竞争条件的工具是明智的，因为很容易错过需要锁的不变量。</p><p>大多数操作系统都支持 POSIX 线程 (Pthreads)，它允许用户进程在不同的 CPU 上同时运行多个线程。 Pthreads 支持用户级锁、屏障等。Pthread 还允许程序员有选择地指定锁应该是可重入的。</p><p>在用户级别支持 Pthreads 需要操作系统的支持。 例如，如果一个 pthread 在系统调用中阻塞，则同一进程的另一个 pthread 应该能够在该 CPU 上运行。 再举一个例子，如果一个 pthread 改变了它的进程的地址空间（例如，映射或取消映射内存），内核必须安排其他运行同一进程线程的 CPU 更新它们的硬件页表以反映地址空间的变化。不用原子指令也可以实现锁，但是代价高昂，而且大多数操作系统都使用原子指令。</p><p>如果许多 CPU 试图同时获取同一个锁，那么锁的开销可能很大。 如果一个 CPU 在其本地缓存中缓存了一个锁，而另一个 CPU 必须获取该锁，那么更新持有锁的缓存行的原子指令必须将该行从一个 CPU 的缓存移动到另一个 CPU 的缓存，也许 使缓存行的任何其他副本无效。 从另一个 CPU 的缓存中获取缓存行的成本可能比从本地缓存中获取缓存行的开销大几个数量级。</p><p>为了避免与锁相关的开销，许多操作系统使用无锁数据结构和算法。 例如，可以实现像本章开头那样的链表，它在列表搜索期间不需要锁，并且可以通过一条原子指令在列表中插入一个项目。 然而，无锁编程比锁编程更复杂； 例如，必须担心指令和内存的重新排序。 用锁编程已经很困难了，所以 xv6 避免了无锁编程的额外复杂性。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MIT6.S081-chapter5</title>
    <link href="/2023/03/01/MIT6-S081-chapter5/"/>
    <url>/2023/03/01/MIT6-S081-chapter5/</url>
    
    <content type="html"><![CDATA[<p>五、Interrupts and device drivers</p><p>驱动程序是操作系统中管理特定设备的代码：它配置设备硬件，告诉设备执行操作，处理产生的中断，并与可能等待设备 I&#x2F;O 的进程交互。 驱动程序代码可能很棘手，因为驱动程序与其管理的设备同时执行。此外，驱动程序必须了解设备的硬件接口，该接口可能很复杂且文档不足。</p><p>需要操作系统注意的设备通常可以配置为生成中断，这是一种陷阱。 内核陷阱处理代码识别设备何时引发中断并调用驱动程序的中断处理程序； 在 xv6 中，这种调度发生在 <code>devintr</code> (kernel&#x2F;trap.c:177) 中。</p><p>许多设备驱动程序在两种上下文中执行代码：上半部分在进程的内核线程中运行，下半部分在中断时执行。 上半部分通过syscall调用，例如希望设备执行 I&#x2F;O 的读取和写入。 这段代码可能会要求硬件开始一个操作（例如，要求磁盘读取一个块）； 然后代码等待操作完成。 最终设备完成操作并引发中断。驱动程序的中断处理程序充当下半部分，找出已完成的操作，在适当的情况下唤醒等待进程，并告诉硬件开始处理任何等待的下一个操作。</p><p>5.1 code : console input</p><p>控制台驱动程序 (kernel&#x2F;console.c) 是驱动程序结构的简单说明。 控制台驱动程序通过连接到 RISC-V 的 UART 串行端口硬件接受人类键入的字符。控制台驱动程序一次累积一行输入，处理退格和控制-u 等特殊输入字符。用户进程（例如 shell）使用 read 系统调用从控制台获取输入行。 当在 QEMU 中向 xv6 键入输入时，您的击键将通过 QEMU 的模拟 UART 硬件传送到 xv6。</p><p>驱动程序与之通信的 UART 硬件是 QEMU 模拟的 16550 芯片。 在真实的计算机上，16550 将管理连接到终端或其他计算机的 RS232 串行链路。当运行 QEMU 时，它连接到你的键盘和显示器。</p><p>UART 硬件在软件看来是一组内存映射控制寄存器。 也就是说，RISC-V 硬件有一些物理地址连接到 UART 设备，因此加载和存储与设备硬件而不是 RAM 交互。 UART 的内存映射地址从 0x10000000 或 UART0 (kernel&#x2F;memlayout.h:21) 开始。 有一些 UART 控制寄存器，每个都是一个字节的宽度。 它们与 UART0 的偏移量在 (kernel&#x2F;uart.c:22) 中定义。 例如，LSR 寄存器包含指示输入字符是否正在等待软件读取的位。 这些字符（如果有的话）可用于读取RHR 寄存器。 每次读取一个，UART 硬件将其从等待字符的内部 FIFO 中删除，并在 FIFO 为空时清除 LSR 中的“就绪”位。 UART 发送硬件在很大程度上独立于接收硬件； 如果软件向 THR 写入一个字节，则 UART 传输该字节。</p><p>xv6 的主要调用 consoleinit (kernel&#x2F;console.c:182) 来初始化 UART 硬件。 此代码将 UART 配置为在 UART 接收到每个输入字节时生成一个接收中断，并在每次 UART 完成发送一个字节的输出时生成一个传输完成中断 (kernel&#x2F;uart.c:53)。</p><p>xv6 shell 通过 init.c (user&#x2F;init.c:19) 打开的文件描述符从控制台读取。 对 read 系统调用的调用通过内核到达 consoleread (kernel&#x2F;console.c:80)。 consoleread 等待输入到达（通过中断）并缓存在 <code>cons.buf</code>中 ，将输入拷贝到用户空间，然后（在整行到达后）返回到用户进程。 如果用户还没有输入整行，则读取进程将在sleep system call中等待。</p><p>当用户键入一个字符时，UART 硬件要求 RISC-V 产生一个中断，从而激活 xv6 的陷阱处理程序。 陷阱处理程序调用 devintr (kernel&#x2F;trap.c:177)，它查看 RISC-V <code>scause</code>寄存器判断中断是否来自外部设备。 然后它要求一个称为 PLIC的硬件单元告诉它哪个设备发生中断 (kernel&#x2F;trap.c:186)。 如果是 UART，devintr 调用 uartintr。uartintr (kernel&#x2F;uart.c:180) 从 UART 硬件读取任何等待输入的字符并将它们交给 consoleintr (kernel&#x2F;console.c:136)； 它不等待字符，因为 future输入将引发新的中断。 <code>consoleintr</code>将积累这些字符直到整行都已经被读取，然后将唤醒仍在<code>sleep</code>的<code>consoleread</code>。当<code>consoleread</code>被唤醒后，将这一行命令复制给user space然后返回。</p><ul><li>LSR寄存器：用来指示输入的字符是否准备好被用户进程读取。</li><li>RHR寄存器：用来放置可以被用户进程读取的字节，让RHR中的一个字节被读取时，UART硬件将其从内部的FIFO硬盘中删除，当FIFO中为空时，LSR寄存器被置为0。</li><li>THR寄存器：当用户进程向THR写入一个字节时，UART将传输这个字节。</li></ul><p>小例子：用户在键盘上输入了一个字符l，这个l通过键盘被发送到UART，然后通过PLIC发送到CPU的一个核，这个核产生中断，跑到<code>devintr</code>，<code>devintr</code>发现是来自UART的，调用<code>uartintr</code>，调用<code>uartgetc()</code>通过<code>RHR</code>寄存器来获取这个字符，然后调用<code>consoleintr</code>，判断这个字符是否是特殊字符(backspace等)，如果不是则将这个字符通过<code>consputc(c)</code>echo回给user，然后将其存储在<code>cons.buf</code>中，当发现整行已经输入完成后(<code>c==&#39;\n&#39; || c ==C(&#39;D&#39;))</code>)，唤醒<code>consoleread()</code>。</p><p>5.2 code : console output</p><p>对连接到控制台的文件描述符的写入系统调用最终到达 uartputc (kernel&#x2F;uart.c:87)。 设备驱动维护一个输出缓冲区（uart_tx_buf），这样写进程就不必等待UART完成发送； 相反，uartputc 将每个字符附加到缓冲区，调用 uartstart 以启动设备传输（如果尚未传输），然后返回。 uartputc 等待的唯一情况是缓冲区已满。</p><p>每次 UART 完成发送一个字节时，它都会产生一个中断。 uartintr 调用 uartstart，它检查设备是否真正完成发送，并将下一个缓冲输出字符交给设备。 因此，如果进程向控制台写入多个字节，通常第一个字节将由 uartputc 调用 uartstart 发送，其余缓冲字节将由当传输完成中断到达时，从 uartintr 调用 uartstart。</p><p>需要注意的一般模式是通过缓冲和中断将设备活动与进程活动分离。 即使没有进程在等待读取输入，控制台驱动程序也可以处理输入；  同样，进程可以发送输出而无需等待设备。 这种分离可以通过允许进程与设备 I&#x2F;O 并发执行来提高性能，并且在设备速度较慢（如 UART）或需要立即关注（如回显键入的字符）时尤为重要。 这种想法有时称为 I&#x2F;O 并发。</p><p>5.3 concurrency in drivers</p><p>我们已经注意到在 consoleread 和 consoleintr 中对 acquire 的调用。 这些调用获取一个锁，以保护控制台驱动程序的数据结构免受并发访问的影响。 这里存在三个并发危险：不同 CPU 上的两个进程可能同时调用 consoleread； 当 CPU 已经在 consoleread 中执行时，硬件可能会要求 CPU 发送一个控制台（实际上是 UART）中断； 并且当 consoleread 正在执行时，硬件可能会在不同的 CPU 上发送控制台中断。 这些危险可能会导致竞争条件或死锁。 第 6 章探讨了这些问题以及锁如何解决这些问题。</p><p>在驱动程序中需要注意并发性的另一种方式是，一个进程可能正在等待来自设备的输入，但是当另一个进程（或根本没有进程）正在运行时，输入的中断信号到达可能会到达。 因此，不允许中断处理程序考虑它们已中断的进程或代码。 例如，中断处理程序无法使用当前进程的页表安全地调用 copyout。 中断处理程序通常做相对较少的工作（例如，只需将输入数据复制到缓冲区），然后唤醒上半部分代码来完成其余工作。</p><p>5.4 timer interrupts</p><p>xv6 使用定时器中断来维护它的时钟并使其能够在计算密集型进程之间切换； usertrap 和 kerneltrap 中的 yield 调用导致了这种切换。 定时器中断来自连接到每个 RISC-V CPU 的时钟硬件。 xv6 对该时钟硬件进行编程以周期性地中断每个 CPU。</p><p>RISC-V 要求定时器中断在机器模式下进行，而不是管理员模式。 RISCV 机器模式在没有分页的情况下执行，并且有一组单独的控制寄存器，因此在机器模式下运行普通的 xv6 内核代码是不切实际的。 因此，xv6 完全独立于上面列出的陷阱机制来处理定时器中断。</p><p>在 main 之前，在 start.c 中以机器模式执行的代码设置为接收定时器中断 (kernel&#x2F;start.c:62)。 部分工作是对 CLINT 硬件（核心本地中断器）进行编程，使其在一定延迟后生成中断。 另一部分是设置一个类似于trapframe的scratch area，帮助timer interrupt handler保存寄存器和CLINT寄存器的地址。最后，start 将 mtvec 设置为 timervec 并启用定时器中断。</p><p>当用户或内核代码正在执行时，定时器中断可以在任何时候发生； 内核无法在关键操作期间禁用定时器中断。 因此，定时器中断处理程序必须以一种保证不会干扰被中断的内核代码的方式来完成它的工作。 基本策略是处理程序要求 RISC-V 引发“软件中断”并立即返回。 RISC-V 通过普通的陷阱机制将软件中断传递给内核，并允许内核禁用它们。 可以在 devintr (kernel&#x2F;trap.c:204) 中看到处理定时器中断产生的软件中断的代码。</p><p>机器模式定时器中断处理程序是 timervec (kernel&#x2F;kernelvec.S:93)。 它在start准备的scratch区保存了几个寄存器，告诉CLINT什么时候产生下一个定时器中断，要求 RISC-V 引发软件中断，恢复寄存器，然后返回。 定时器中断处理程序中没有 C 代码。</p><p>5.5 real world</p><p>xv6 允许在内核中执行设备和定时器中断，以及在执行用户程序时。 定时器中断强制从定时器中断处理程序进行线程切换（调用yield），即使在内核中执行也是如此。 如果内核线程有时花费大量时间计算而不返回用户空间，则在内核线程之间公平地对 CPU 进行时间切片的能力非常有用。 然而，内核代码需要注意它可能会被挂起（由于一个定时器中断）然后在不同的 CPU 上恢复是 xv6 中一些复杂性的来源（参见第 6.6 节）。 如果设备和定时器中断仅在执行用户代码时发生，内核可以变得更简单。</p><p>在典型计算机上支持所有设备的全部工作量很大，因为有很多设备，设备有很多功能，设备和驱动程序之间的协议可能很复杂并且文档很少。 在许多操作系统中，驱动程序所占的代码多于核心内核。</p><p>UART 驱动程序通过读取 UART 控制寄存器一次一个字节地检索数据； 这种模式称为编程 I&#x2F;O，因为软件驱动数据移动。 编程 I&#x2F;O 很简单，但速度太慢，无法在高数据速率下使用。 需要高速移动大量数据的设备通常使用直接内存访问 (DMA)。 DMA 设备硬件直接将传入数据写入 RAM，并从 RAM 读取传出数据。 现代磁盘和网络设备使用 DMA。 DMA 设备的驱动程序会在 RAM 中准备数据，然后使用对控制寄存器的单次写入来告诉设备处理准备好的数据。</p><p>当一个设备在不可预知的时间需要注意而不是太频繁时，中断是有意义的。 但是中断有很高的 CPU 开销。 因此，高速设备（例如网络和磁盘控制器）使用减少中断需求的技巧。 一个技巧是为整批传入或传出请求引发单个中断。 另一个技巧是驱动程序完全禁用中断，并定期检查设备以查看是否需要注意。 这种技术称为轮询。 如果设备非常快速地执行操作，轮询是有意义的，但如果设备大部分时间都处于空闲状态，则轮询会浪费 CPU 时间。 某些驱动程序根据当前设备负载在轮询和中断之间动态切换。</p><p>UART 驱动程序首先将传入数据复制到内核中的缓冲区，然后再复制到用户空间。 这在低数据速率下是有意义的，但这样的双重副本会显着降低快速生成或使用数据的设备的性能。 一些操作系统能够直接在用户空间缓冲区和设备硬件之间移动数据，通常使用 DMA。</p><p>如第 1 章所述，控制台对应用程序来说就像一个常规文件，应用程序使用读写系统调用读取输入和写入输出。 应用程序可能想要控制无法通过标准文件系统调用表达的设备方面（例如，在控制台驱动程序中启用&#x2F;禁用行缓冲）。 Unix 操作系统支持针对此类情况的 ioctl 系统调用。</p><p>计算机的某些用途要求系统必须在限定时间内做出响应。 例如，在sfety-critical系统中，错过最后期限可能会导致灾难。 xv6 不适合硬实时设置。 硬实时操作系统往往是与应用程序链接的库，允许通过分析确定最坏情况下的响应时间。 xv6 也不适合软实时应用程序，偶尔错过最后期限是可以接受的，因为 xv6 的调度程序过于简单，并且它具有长时间禁用中断的内核代码路径。</p><p>5.6 exercises</p><ol><li>修改 uart.c 以完全不使用中断。 您可能还需要修改 console.c。</li><li>为以太网卡添加驱动程序。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MIT6.S081-chapter4</title>
    <link href="/2023/02/25/MIT6-S081-chapter4/"/>
    <url>/2023/02/25/MIT6-S081-chapter4/</url>
    
    <content type="html"><![CDATA[<p>四、 traps and system calls</p><p>​有三种事件会导致 CPU 搁置指令的普通执行，并强制将控制权转移到处理该事件的特殊代码。 一种情况是系统调用syscall，当用户程序执行 <code>ecall</code> 指令要求内核为它做某事时。 另一种情况是异常<code>exception</code>：指令（用户或内核）做了一些非法的事情，例如除以零或使用无效的虚拟地址。 第三种情况是设备中断，当设备发出需要注意的信号时，例如当磁盘硬件完成读取或写入请求时。</p><p>​本书使用陷阱（trap）作为这些情况的通用术语。 通常，陷阱发生时，正在执行的任何代码稍后都需要恢复，并且不需要知道发生了什么特殊的事情。 也就是说，我们通常希望陷阱是透明的； 这对于设备中断尤其重要，因为中断代码通常不希望出现这种情况。 通常的顺序是陷阱强制将控制权转移到内核中； 内核保存寄存器和其他状态，以便之后可以恢复执行； 内核执行适当的处理程序代码（例如，系统调用实现或设备驱动程序）； 内核恢复保存的状态并从陷阱中返回； 并且原始代码从它停止的地方恢复执行。</p><p>​xv6 处理内核中的所有trap； <code>trap</code>不会传递给用户代码。 在内核中处理<code>trap</code>对于系统调用来说是很自然的。 这对于中断是有意义的，因为隔离要求只允许内核使用设备，并且因为内核是一种在多个进程之间共享设备的便利机制。 它对于异常也有意义，因为 xv6 通过杀死有问题的程序来响应来自用户空间的所有异常。</p><p>​xv6 陷阱处理分四个阶段进行：RISC-V CPU采取的硬件操作，一些为内核 C 代码方式准备的汇编指令，决定如何处理陷阱的 C 函数，以及系统调用或设备驱动程序服务程序。虽然三种陷阱类型之间的共性表明内核可以使用单一代码路径处理所有陷阱，但事实证明为三种不同的情况使用单独的代码会很方便：即来自用户空间的陷阱、来自内核空间的陷阱和定时器中断会有不同的 handler。 处理陷阱的内核代码（汇编程序或 C）通常称为处理程序； 第一个处理程序指令通常用汇编程序（而不是 C）编写，有时称为vector。</p><p>4.1 RISC-V trap machinery</p><p>每个 RISC-V CPU 都有一组控制寄存器，内核写入这些寄存器以告诉 CPU 如何处理陷阱，内核可以读取这些寄存器以找出已发生的陷阱。 RISC-V 文档包含完整的故事。 riscv.h包含 xv6 使用的定义。 以下是最重要的寄存器的概述：</p><ul><li>stvec：内核在这里写入它的陷阱处理程序，RISC-V跳转到stvec中的地址来处理陷阱。</li><li>sepc: 当陷阱发生时，RISC-V 将程序计数器保存在这里（因为 pc在之后的操作中会被 stvec 中的值覆盖）。 sret（从陷阱返回）指令将 sepc 复制到 pc。 内核可以编写 sepc 来控制 sret 的去向。</li><li>scause: RISC-V 在这里放了一个代码来描述陷阱的原因。</li><li>sscractch: 内核在此处放置一个值，在trap handler的最开始时派上用场。</li><li>sstatus : sstatus 中的 SIE 位控制是否启用设备中断。 如果内核清除 SIE，RISC-V 将推迟设备中断，直到内核设置 SIE。 SPP 位指示陷阱是来自用户模式还是管理员模式，并控制 sret 返回的模式。</li></ul><p>上述寄存器与管理员模式下处理的陷阱有关，在用户模式下不能读写。 对于在机器模式下处理的陷阱，有一组类似的控制寄存器； xv6 仅将它们用于定时器中断的特殊情况。</p><p>多核芯片上的每个 CPU 都有自己的一组寄存器，并且在任何给定时间可能有多个 CPU 正在处理陷阱。</p><p>当发生除了计时器中断以外的其他类型的trap时，RISC-V 硬件对所有陷阱类型（定时器中断除外）执行以下操作：</p><ol><li>如果trap是一个设备中断，而SIE又被清除的情况下，不会做以下任何事情</li><li>通过清除sstatus中的SIE位来失能中断</li><li>拷贝pc到sepc</li><li>在sstatus中的SPP位保存当前模式（user&#x2F;supervisor）</li><li>设置scause来反馈陷阱产生的原因</li><li>设置模式为supervisor</li><li>拷贝stvec到pc</li><li>从新的pc开始执行</li></ol><p>请注意，CPU 不会切换到内核页表，不会切换到内核中的堆栈，也不会保存 pc 以外的任何寄存器。 内核软件必须执行这些任务。<br>CPU 在陷阱期间做最少工作的原因之一是为软件提供灵活性； 例如，某些操作系统在某些情况下会省略页表切换以提高处理陷阱的性能。</p><p>值得考虑是否可以省略上面列出的任何步骤，也许是为了更快的发现陷阱。 尽管在某些情况下可以使用更简单的顺序，但通常省略许多步骤会很危险。 例如，假设 CPU 没有切换程序计数器pc。 或者来自用户空间的陷阱可以切换到管理员模式，同时仍在运行用户指令。 这些用户指令可能会破坏用户&#x2F;内核隔离，例如通过修改 satp 寄存器以指向允许访问所有物理内存的页表。因此，CPU 切换到内核指定的指令地址很重要，即 <code>stvec</code>。</p><p>4.2 Traps from user space</p><p>xv6 处理陷阱的方式这取决于它是在内核空间中执行还是在用户空间代码中执行。这是用户代码陷阱的故事； 4.5 节描述了来自内核代码的陷阱。</p><p>如果用户程序进行系统调用（ecall 指令）、执行非法操作或设备中断，则在用户空间执行时可能会发生陷阱。 来自用户空间的trap的高层路径是<code>uservec</code>(kernel&#x2F;trappoline.S:16)，然后是<code>usertrap</code>(kernel&#x2F;trap.c:37)； 返回时，<code>usertrapret</code> (kernel&#x2F;trap.c:90) 然后是 <code>userret</code> (kernel&#x2F;trampoline.S:88)通过<code>sret</code>跳回到user space。</p><p>xv6 陷阱处理设计的一个主要限制是 RISC-V 硬件在强制陷阱时不会切换页表。 这意味着 <code>stvec</code> 中的陷阱处理程序地址必须在用户页表中具有有效映射，因为当陷阱处理代码开始执行时，这是有效的页表。 此外，xv6 的陷阱处理代码需要切换到内核页表； 为了能够在该切换之后继续执行，内核页表还必须具有 <code>stvec</code> 指向的处理程序的映射。</p><p>xv6 使用<code>trampoline</code>页面来满足这些要求。 <code>trampoline</code> 页面包含 <code>uservec</code>，<code>stvec</code> 指向的 xv6 陷阱处理代码。 <code>trampoline</code>页面映射在每个进程的地址 TRAMPOLINE 处的页表，它位于虚拟地址空间的末尾，因此它将位于程序自己使用的内存之上。 trampoline页面也被映射到地址内核页表中的 TRAMPOLINE。 参见图 2.3 和图 3.3。 因为 trampoline 页面被映射到用户页表中，带有 PTE_U 标志，陷阱可以在supervisor模式下开始执行。 因为trampoline page映射到内核地址空间中的同一地址，trap handler在切换到内核页表后可以继续执行。</p><p>uservec 陷阱处理程序的代码位于 trampoline.S 。当uservec启动时，所有32个寄存器包含的值都被中断的用户代码所拥有。这 32 个值需要保存在内存中的某个地方，以便当陷阱返回到用户空间时可以恢复它们。 存储到内存需要使用寄存器来保存地址，但此时没有可用的通用寄存器！ 幸运的是，RISC-V 以 <code>sscratch</code> 寄存器的形式提供了帮助。 <code>uservec</code> 开头的 csrrw 指令交换 a0 和 sscratch 的内容。 现在用户代码的a0保存在sscratch中； <code>uservec</code> 有一个寄存器 (a0) 可以使用； a0 包含内核先前放置在 sscratch 中的值。</p><p>uservec 的下一个任务是保存 32 个用户寄存器。在进入用户空间之前，内核将 sscratch 设置为指向每个进程的 trapframe 结构，该结构（除其他外）有空间保存 32 个用户寄存器 (kernel&#x2F;proc.h:44)。 因为<code>satp</code>仍然引用用户页表，所以<code>uservec</code>需要<code>trapframe</code>映射到用户地址空间。 在创建每个进程时，xv6 为进程的 trapframe 分配一个页面，并安排它始终映射到用户虚拟地址 TRAPFRAME，它就在 TRAMPOLINE 下面。 进程的 <code>p-&gt;trapframe</code> 也指向 trapframe，虽然是在它的物理地址，因此内核可以通过内核页表使用它。因此在交换 a0 和 sscratch 之后，a0 持有指向当前进程的陷阱帧的指针。 uservec 现在将所有用户寄存器保存在那里，包括用户的 a0，从 sscratch 读取。</p><p>trapframe中包含了当前进程的内核栈地址、当前CPU的hartid、usertrap函数的地址、内核页表的地址。 uservec 检索这些值，将 satp 切换到内核页表，并调用 usertrap。</p><p>usertrap 的工作是确定陷阱的原因，处理它，然后返回。 它首先更改 stvec，以便内核中的陷阱将由 kernelvec 而不是 uservec 处理。 它保存了 sepc 寄存器（保存的用户程序计数器），因为usertrap 可能会调用 yield 切换到另一个进程的内核线程，并且该进程可能会返回到用户空间，在此过程中它会修改 sepc。 如果trap是系统调用，usertrap调用syscall来处理； 如果设备中断，devintr； 否则就是异常，内核会终止错误进程。 系统调用路径将保存的用户程序计数器加四，因为在系统调用的情况下，RISC-V 使程序指针指向 ecall 指令，但用户代码需要在后续指令处恢复执行。 在退出时，usertrap 检查进程是否已被杀死或是否应该让出 CPU（如果此陷阱是定时器中断）。</p><p>返回用户空间的第一步是调用 <code>usertrapret</code> (kernel&#x2F;trap.c:90)。 此函数设置 RISC-V 控制寄存器，为将来来自用户空间的陷阱做准备。 这涉及更改 stvec 以引用 uservec，准备 uservec 所依赖的 trapframe 字段，以及将 sepc 设置为先前保存的用户程序计数器。 最后，usertrapret 在映射到用户和内核页表的 trampoline 页上调用 userret； 原因是userret中的汇编代码会切换页表。</p><p>usertrapret 对 userret 的调用传递了 a0 中的 TRAPFRAME 和 a1 中指向进程用户页表的值（kernel&#x2F;trampoline.S:88）。 userret 将 satp 切换到进程的用户页表。 回想一下，用户页表映射了 trampoline 页和 TRAPFRAME，但没有映射到内核。 trampoline 页映射到用户页表和内核页表中的相同虚拟地址这一事实允许 uservec 在更改 satp 后继续执行。userret 将 trapframe 的已保存用户 a0 复制到 sscratch，为以后与 TRAPFRAME 的交换做准备。 从这一点开始，userret 唯一可以使用的数据就是寄存器内容和trapframe 的内容。 接下来 userret 从 trapframe 中恢复保存的用户寄存器，最后交换 a0 和 sscratch 以恢复用户 a0 并为下一个陷阱保存 TRAPFRAME，并执行 sret 返回用户空间。</p><p>4.3 code: calling system calls</p><p>第 2 章以 initcode.S 调用 exec 系统调用 (user&#x2F;initcode.S:11) 结束。 让我们看看用户调用是如何进入内核中 exec 系统调用的实现的。</p><p>initcode.S 将 exec 的参数放在寄存器 a0 和 a1 中，并将系统调用号放在 a7 中。 系统调用号与 syscalls 数组中的条目相匹配，这是一个函数指针表 (kernel&#x2F;syscall.c:108)。 ecall 指令陷入内核并导致 uservec、usertrap 和 syscall 执行，如我们上面所见。</p><p>syscall (kernel&#x2F;syscall.c:133) 从 trapframe 中保存的 a7 中检索系统调用号，并使用它来索引系统调用。 对于第一次系统调用，a7包含SYS_exec(kernel&#x2F;syscall.h:8)，导致调用系统调用实现函数sys_exec。</p><p>当sys_exec返回时，syscall将其返回值记录在p-&gt;trapframe-&gt;a0中。 这将导致对 exec() 的原始用户空间调用返回该值，因为 RISC-V 上的 C 调用约定将返回值放在 a0 中。 系统调用通常返回负数表示错误，返回零或正数表示成功。 如果系统调用号无效，则 syscall 打印错误并返回 -1。</p><p>4.4 code: system call arguments</p><p>内核中的系统调用实现需要找到用户代码传递的参数。 因为用户代码调用系统调用包装函数，所以参数最初位于 RISC-V C 调用约定放置它们的位置：在寄存器中。 内核陷阱代码将用户寄存器保存到当前进程的trapframe中，内核代码可以在其中找到它们。 内核函数 argint、argaddr 和 argfd 从陷阱帧中检索第 n 个系统调用参数作为整数、指针或文件描述符。 它们都调用 argraw 来检索适当的已保存用户寄存器 (kernel&#x2F;syscall.c:35)。</p><p>一些系统调用将指针作为参数传递，内核必须使用这些指针来读取或写入用户内存。 例如，exec 系统调用将指向用户空间中字符串参数的指针数组传递给内核。 这些指标带来了两个挑战。 首先，用户程序可能存在错误或恶意，可能会向内核传递一个无效指针或旨在诱使内核访问内核内存而不是用户内存的指针。 其次，xv6 内核页表映射与用户页表映射不同，因此内核不能使用普通指令从用户提供的地址加载或存储。</p><p>内核实现了能够安全地将数据传输到用户提供的地址和从用户提供的地址传输数据的功能。 fetchstr 是一个示例 (kernel&#x2F;syscall.c:25)。 exec 等文件系统调用使用 fetchstr 从用户空间检索字符串文件名参数。 fetchstr 调用 copyinstr 来完成任务工作。</p><p><code>copyinstr</code> (kernel&#x2F;vm.c:398) 从用户页表 pagetable 中的虚拟地址 srcva 复制最大字节数到 dst。 由于 pagetable 不是当前页表，copyinstr 使用 walkaddr（调用 walk）在 pagetable 中查找 srcva，产生物理地址 pa0。 内核将每个物理RAM地址映射到对应的内核虚拟地址，因此copyinstr可以直接将字符串字节从pa0复制到dst。 walkaddr (kernel&#x2F;vm.c:104) 检查用户提供的虚拟地址是进程用户地址空间的一部分，所以程序不能欺骗内核读取其他内存。 类似的函数 copyout 将数据从内核复制到用户提供的地址。</p><p>4.5 traps from kernel space</p><p>xv6 根据执行的是用户代码还是内核代码，对 CPU 陷阱寄存器的配置略有不同。 当内核在 CPU 上执行时，内核将 stvec 指向程序集kernelvec 中的代码 (kernel&#x2F;kernelvec.S:10)。 由于 xv6 已经在内核中，kernelvec 可以依赖于将 satp 设置为内核页表，以及指向有效内核堆栈的堆栈指针。 kernelvec 将所有 32 个寄存器压入堆栈，稍后它将从堆栈中恢复它们，以便中断的内核代码可以不受干扰地恢复。</p><p>kernelvec 将寄存器保存在中断的内核线程的堆栈中，这是有道理的，因为寄存器值属于该线程。 如果陷阱导致切换到不同的线程，这一点尤其重要——在这种情况下，陷阱实际上会从新线程的堆栈中返回，将被中断线程保存的寄存器安全地留在其堆栈中。</p><p>kernelvec 在保存寄存器后跳转到 kerneltrap (kernel&#x2F;trap.c:134)。 kerneltrap 为两种类型的陷阱准备：设备中断和异常。 它调用 devintr (kernel&#x2F;-trap.c:177) 来检查和处理前者。 如果陷阱不是设备中断，它一定是一个异常，如果它发生在 xv6 内核中，那总是一个致命错误； 内核调用 panic 并停止执行。</p><p>如果 kerneltrap 由于计时器中断而被调用，并且进程的内核线程正在运行（而不是调度程序线程），则 kerneltrap 调用 yield 来为其他线程提供运行的机会。在某个时候，其中一个线程会让步，让我们的线程和它的内核陷阱再次恢复。 第 7 章解释了 yield 中发生的事情。</p><p>当 kerneltrap 的工作完成后，它需要返回到被陷阱中断的任何代码。 因为 yield 可能会干扰 sepc 和 sstatus 中的先前模式，所以 kerneltrap 在启动时会保存它们。 它现在恢复那些控制寄存器并返回到 kernelvec（内核&#x2F;kernelvec.S:48）。 kernelvec 从堆栈中弹出保存的寄存器并执行 sret，它将 sepc 复制到 pc 并恢复中断的内核代码。</p><p>如果 kerneltrap 由于定时器中断而调用 yield，那么值得思考陷阱返回是如何发生的。</p><p>当 CPU 从用户空间进入内核时，xv6 将 CPU 的 stvec 设置为 kernelvec； 我们可以在 usertrap (kernel&#x2F;trap.c:29) 中看到这一点。 内核开始执行时有一个时间窗口，但 stvec 仍设置为 uservec，在该窗口期间没有设备中断发生是至关重要的。 幸运的是，RISC-V 在开始捕获陷阱时总是禁用中断，而 xv6 在设置 stvec 之前不会再次启用它们。</p><p>4.6 page-fault exceptions</p><p>许多内核使用页面错误来实现写时复制 (Copy-on-Write) fork。要解释写时复制 fork，请考虑第 3 章中描述的 xv6 的 fork。fork 导致子进程的初始内存内容与 fork 时父进程的内存内容相同。 xv6 使用 uvmcopy (kernel&#x2F;vm.c:301) 实现 fork，它为子进程分配物理内存并将父进程的内存复制到其中。 如果子进程和父进程可以共享父进程的物理内存，效率会更高。 然而，直接实现这一点是行不通的，因为它会导致父子进程通过写入共享堆栈和堆来干扰彼此的执行。</p><p>通过适当使用页表权限和页面错误，父进程和子进程可以安全地共享物理内存。 当使用的虚拟地址在页表中没有映射，或者具有 PTE_V 标志为清除的映射，或者其许可位（PTE_R、PTE_W、PTE_X、PTE_U）禁止的映射时，CPU 会引发页面错误异常正在尝试操作。 RISC-V 区分了三种页面错误：加载页面错误load page faults（当加载指令无法转换其虚拟地址时）、存储页面错误store page faults（当存储指令无法转换其虚拟地址时）和指令页面错误instruction page faults（当一个instruction的地址无法翻译时发生）。 scause 寄存器指示页面错误的类型，而 stval 寄存器包含无法翻译的地址。在xv6中对于exception一律都会将这个进程kill掉，但是实际上可以结合page faults实现一些功能。：</p><p>1.可以实现<em>copy-on-write fork</em>。在<code>fork</code>时，一般都是将父进程的所有user memory复制到子进程中，但是<code>fork</code>之后一般会直接进行<code>exec</code>，这就会导致复制过来的user memory又被放弃掉。因此改进的思路是：子进程和父进程共享一个物理内存，但是mapping时将PTE_W置零，只有当子进程或者父进程的其中一个进程需要向这个地址写入时产生page fault，此时才会进行copy。</p><p>2.可以实现<em>lazy allocation</em>。旧的<code>sbrk()</code>申请分配内存，但是申请的这些内存进程很可能不会全部用到，因此改进方案为：当进程调用<code>sbrk()</code>时，将修改<code>p-&gt;sz</code>，但是并不实际分配内存，并且将PTE_V置0。当在试图访问这些新的地址时发生page fault再进行物理内存的分配。</p><p>3.<em>paging from disk</em>：当内存没有足够的物理空间时，可以先将数据存储在其他的存储介质（比如硬盘）上，，将该地址的PTE设置为invalid，使其成为一个evicted page。当需要读或者写这个PTE时，产生Page fault，然后在内存上分配一个物理地址，将这个硬盘上的evicted page的内容写入到该内存上，设置PTE为valid并且引用到这个内存物理地址。</p><p>COW fork 中的基本计划是让父进程和子进程共享所有物理页面，但每个人都将它们映射为只读（清除 PTE_W 标志）。 父进程和子进程可以从共享的物理内存中读取。 如果任一者写入给定页面，RISC-V CPU 将引发页面错误异常。 内核的陷阱处理程序通过分配一个新的物理内存页面并将错误地址映射到的物理页面复制到其中来做出响应。内核更改故障进程页表中的相关 PTE 以指向副本并允许写入和读取，然后在导致故障的指令处恢复故障进程。 由于 PTE 允许写入，因此重新执行的指令现在将无故障执行。 写时复制需要簿记（book-keeping）以帮助决定何时可以释放物理页面，因为每个页面都可以由不同数量的页表引用，具体取决于fork、页面错误（page faults）、执行（execs）和退出（exits）的历史记录。 这种簿记（book-keeping）允许一个重要的优化：如果进程发生存储页面错误并且物理页面仅从该进程的页表中引用，则不需要副本。</p><p>写时复制使 fork 更快，因为 fork 不需要复制内存。 一些内存必须在以后写入时复制，但通常情况下大部分内存永远不必复制。 一个常见的例子是 fork 之后是 exec：在 fork 之后可能会写入几页，但是随后子进程的 exec 释放了从父进程继承的大部分内存。写时复制 fork 消除了复制此内存的需要。 此外，COW fork是透明的：无需对应用程序进行任何修改即可使它们受益。</p><p>页表和页错误的结合开辟了除 COW fork 之外的广泛有趣的可能性。 另一个广泛使用的特性称为惰性分配（lazy allocation），它有两个部分。 首先，当应用程序通过调用 sbrk 请求更多内存时，内核会注意到大小的增加，但不会分配物理内存，也不会为新的虚拟地址范围创建 PTE。 其次，在其中一个新地址发生页面错误时，内核会分配一页物理内存并将其映射到页表中。 与 COW fork 一样，内核可以对应用程序透明地实现惰性分配。</p><p>由于应用程序经常请求比他们需要的更多的内存，延迟分配是一个胜利：内核根本不需要为应用程序从不使用的页面做任何工作。 此外，如果应用程序要求大量增加地址空间，那么没有惰性分配的 sbrk 是昂贵的：如果应用程序要求 1 GB 的内存，内核必须分配和归零 262,144 个 4096 字节的页面。 惰性分配允许此成本随着时间的推移而分散。另一方面，惰性分配会导致页面错误的额外开销，这涉及内核&#x2F;用户转换。 操作系统可以通过为每个页面错误分配一批连续的页面而不是一个页面来降低这种成本，并通过为此类页面错误专门化内核进入&#x2F;退出代码。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       </p><p>另一个广泛使用的利用页面错误的功能是请求分页。 在 exec 中，xv6 将应用程序的所有文本和数据急切地加载到内存中。 由于应用程序可能很大并且从磁盘读取的成本很高，因此用户可能会注意到这种启动成本：当用户从 shell 启动大型应用程序时，可能需要很长时间才能看到响应。 为了缩短响应时间，现代内核为用户地址空间创建页表，但将页面的 PTE 标记为无效。 发生页面错误时，内核从磁盘读取页面内容并将其映射到用户地址空间。 与 COW fork 和惰性分配一样，内核可以对应用程序透明地实现此功能。</p><p>在计算机上运行的程序可能需要比计算机的 RAM 更多的内存。 为了优雅地应对，操作系统可以实现分页到磁盘。 这个想法是只将一小部分用户页面存储在 RAM 中，并将其余部分存储在磁盘上的分页区域中。 内核将与存储在分页区域（因此不在 RAM 中）的内存相对应的 PTE 标记为无效。 如果应用程序试图使用已调出到磁盘的页面之一，应用程序将招致page fault，必须将page调入：kernel trap handler会分配物理RAM的page，将page从磁盘读入RAM，并修改相关的PTE指向RAM。</p><p>如果页面需要调入，但没有可用的物理 RAM，会发生什么情况？ 在这种情况下，内核必须首先通过将物理页面调出或逐出到磁盘上的分页区域来释放物理页面，并将引用该物理页面的 PTE 标记为无效。 逐出是昂贵的，因此分页在不频繁的情况下表现最佳：如果应用程序仅使用其内存页面的一个子集并且子集的并集适合 RAM。 此属性通常被称为具有良好的参考位置。 与许多虚拟内存技术一样，内核通常以对应用程序透明的方式实现磁盘分页。</p><p>无论硬件提供多少 RAM，计算机通常在很少或没有可用物理内存的情况下运行。 例如，云提供商在一台机器上多路复用许多客户，以经济高效地使用他们的硬件。 再举一个例子，用户在智能手机上运行很多应用程序的物理内存很少。 在这样的设置中，分配页面可能需要先驱逐现有页面。 因此，当空闲物理内存稀缺时，分配是昂贵的。</p><p>当可用内存不足时，惰性分配和请求分页特别有利。在 sbrk 或 exec 中急切地分配内存会导致额外的逐出成本以使内存可用。 此外，还存在浪费急切工作的风险，因为在应用程序使用该页面之前，操作系统可能已将其逐出。</p><p>结合分页和页面错误异常的其他功能包括自动扩展堆栈和内存映射文件。</p><p>4.7 real world</p><p>trampoline和陷阱框架可能看起来过于复杂。 一个驱动力是 RISCV 在强制陷阱时有意做尽可能少的事情，以允许非常快速的陷阱处理的可能性，这很重要。 因此，内核陷阱处理程序的前几条指令实际上必须在用户环境中执行：用户页表和用户寄存器内容。并且陷阱处理程序最初不知道有用的事实，例如正在运行的进程的标识或内核页表的地址。一个解决方案是可能的，因为 RISC-V 提供了受保护的地方，内核可以在进入之前隐藏信息用户空间：sscratch 寄存器和指向内核内存但由于缺少 PTE_U 而受到保护的用户页表条目。 xv6 的 trampoline 和 trapframe 利用了这些 RISC-V 特性。</p><p>如果将内核内存映射到每个进程的用户页表（具有适当的 PTE 权限标志），则可以消除对特殊trampoline页的需求。 当从用户空间陷入内核时，这也将消除对页表切换的需要。 这反过来将允许内核中的系统调用实现利用当前进程的用户内存被映射，从而允许内核代码直接取消引用用户指针。许多操作系统都使用这些想法来提高效率。 xv6 避免使用它们是为了减少由于无意中使用用户指针而导致内核出现安全漏洞的可能性，并降低确保用户和内核虚拟地址不重叠所需的一些复杂性。</p><p>生产操作系统实现写时复制fork、惰性分配、请求分页、分页到磁盘、内存映射文件等。此外，生产操作系统将尝试使用所有物理内存，用于应用程序或缓存（例如， 文件系统的缓冲区缓存，我们将在后面的第 8.2 节中介绍）。 xv6 在这方面是天真的：你希望你的操作系统使用你支付的物理内存，但 xv6 不会。 此外，如果 xv6内存不足时，它会向正在运行的应用程序返回一个错误或终止它，而不是例如驱逐另一个应用程序的页面。</p><p>4.8 exercises</p><ol><li>函数 copyin 和 copyinstr 在软件中遍历用户页表。 设置内核页表，使内核映射用户程序，copyin 和 copyinstr 可以使用 memcpy 将系统调用参数复制到内核空间，依靠硬件进行页表遍历。</li><li>实现lazy memory allocation。</li><li>实现COW fork。</li><li>有没有办法消除每个用户地址空间中的特殊 TRAPFRAME 页面映射？ 例如，是否可以将 uservec 修改为简单地将 32 个用户寄存器压入内核堆栈，或者将它们存储在 proc 结构中？</li><li>是否可以修改 xv6 以消除特殊的 TRAMPOLINE 页面映射？</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MIT6.S081-chapter3</title>
    <link href="/2023/02/19/MIT6-S081-chapter3/"/>
    <url>/2023/02/19/MIT6-S081-chapter3/</url>
    
    <content type="html"><![CDATA[<p>三、 page tables</p><p>​操作系统通过<code>page table</code>为每个进程提供自己的私有地址空间和内存，从而实现内存隔离。页表决定了内存地址空间的含义，以及可以访问物理内存的哪些部分。它们允许xv6隔离不同进程的地址空间并将它们多路复用到单个物理内存中。页表是一种流行的设计，因为它们提供了一种允许操作系统执行一些小trick的执行方式。xv6执行一些技巧，在多个地址空间中映射相同的内存(trampoline page)，并使用未映射的页面保护内核和用户堆栈。</p><p>3.1 paging hardware</p><p>作为提醒，RISC-V 指令（用户和内核）操作虚拟地址。 机器的 RAM 或物理内存是用物理地址索引的。 RISC-V 页表硬件通过将每个虚拟地址映射到物理地址来连接这两种地址。</p><p>​xv6 运行在 Sv39 RISC-V 上，这意味着只使用 64 位虚拟地址的低 39 位； 前 25 位未使用。在这个Sv39配置中，RISC-V页表在逻辑上是一个包含$2^{27}$（134217728）个页表条目（PTE）的数组。每个PTE包含一个44bit的物理页码（PPN）和一些标志位（Flags）。分页硬件使用前27位转换虚拟地址，将39位中的bit索引到页表中找到一个PTE，并制作一个56位的物理地址，其高44位来自PTE中的PPN，低12位是从PTE中复制的原始虚拟地址。图 3.1 将页表的逻辑视图显示为一个简单的 PTE 数组（有关更完整的故事，请参见图 3.2）。 页表使操作系统能够以 4096 ($2^{12}$) 字节的对齐块的粒度对虚拟地址到物理地址的转换进行控制。 这样的块称为 <em>page</em>。</p><img src="/2023/02/19/MIT6-S081-chapter3/riscv-pagetable.png" class="" title="架构图"><p>​在 Sv39 RISC-V 中，虚拟地址的前 25 位不用于转换。 物理地址也有增长的空间：PTE 格式中有空间让物理页号再增长 10 位。 RISC-V 的设计者根据技术预测选择了这些数字。$2^{39}$字节是512GB，对于在RISC-V计算机上运行的应用程序来说，这应该是足够的地址空间。256足以在不久的将来容纳可能的I&#x2F;O设备和DRAM芯片的物理内存空间。如果需要更多，RISC-V设计者已经定义了具有48位虚拟地址的Sv48。</p><p>​如图 3.2 所示，RISC-V CPU 通过三个步骤将虚拟地址转换为物理地址。 页表以三级树的形式存储在物理内存中。 树的根是一个 4096 字节的页表页，包含 512 个 PTE，其中包含树的下一级页表页的物理地址。 这些页面中的每一页都包含树中最后一层的 512 个 PTE。分页硬件使用 27 位中的高 9 位选择根页表页中的 PTE，中间 9 位选择树的下一级页表页中的 PTE，低 9 位 位来选择最终的 PTE。 （在 Sv48 RISC-V 中，页表有四层，虚拟地址索引的第 39 位到第 47 位进入顶层。）</p><img src="/2023/02/19/MIT6-S081-chapter3/riscv_address.png" class="" title="架构图"><p>如果转换地址所需的三个 PTE 中的任何一个不存在，分页硬件将引发页面错误异常，将其留给内核来处理异常。</p><p>​与图 3.1 的单层设计相比，图 3.2 的三层结构允许采用内存高效的方式来记录 PTE。 在大范围虚拟地址没有映射的常见情况下，三级结构可以省略整个页目录。 例如，如果应用程序只使用从地址 0 开始的几个页面，那么顶级页面目录的条目 1 到 511 是无效的，内核不必为 511 中间页面目录分配页面。 此外，内核也不必为那些 511 中间页目录为底层页目录分配页面。 因此，在本例中，三级设计为中间页目录节省了 511 页，为底层页目录节省了 511 × 512 页。</p><p>​尽管CPU在硬件中遍历三级结构作为执行加载或存储指令的一部分，但三级的潜在缺点是CPU必须从内存中加载三个PTE以执行加载&#x2F;存储中的虚拟地址转换一个物理地址的指令。<em>为了避免从物理内存加载PTE的成本，RISC-V CPU的缓存页表条目缓存在转换后备缓冲区（<strong>TLB</strong>）中。</em></p><p>​每个 PTE 都包含标志位，告诉分页硬件如何允许使用关联的虚拟地址。 PTE_V 指示 PTE 是否存在：如果未设置，则对页面的引用会导致异常（即不允许）。 PTE_R 控制是否允许指令读取页面。 PTE_W 控制是否允许指令写入页面。 PTE_X 控制 CPU 是否可以将页面内容解释为指令并执行它们。 PTE_U 控制是否允许用户态指令访问页面； 如果未设置 PTE_U，则 PTE 只能在管理员模式下使用。 图 3.2 展示了它是如何工作的。 标志和所有其他页面硬件相关结构在 (kernel&#x2F;riscv.h) 中定义</p><p>​需要告诉硬件使用页表，内核必须将页表的物理地址写入<code>satp</code>寄存器。每个CPU都有自己的<code>stap</code>。CPU将使用自己的<code>satp</code>指向的页表来翻译后续指令生成的所有地址。每个CPU都有自己的satp，这样不同的CPU可以运行不同的进程，每个进程都有自己的页表描述的私有地址空间。</p><p>​通常，内核将所有物理内存映射到其页表中，以便它可以使用加载&#x2F;存储指令读取和写入物理内存中的任何位置。 由于页目录在物理内存中，内核可以通过使用标准存储指令写入 PTE 的虚拟地址来在页目录中编程 PTE 的内容。</p><p>​关于术语的一些注释。 <strong>物理内存是指 DRAM 中的存储单元</strong>。 一个字节的物理内存有一个地址，称为物理地址。 指令只使用虚拟地址，分页硬件将其转换为物理地址，然后发送到 DRAM 硬件以读取或写入存储。 与物理内存和虚拟地址不同，虚拟内存不是物理对象，而是指内核提供的用于管理物理内存和虚拟地址的抽象和机制的集合。</p><img src="/2023/02/19/MIT6-S081-chapter3/riscv_physical_address.png" class="" title="架构图"><p>3.2 kernel address space</p><p>​xv6 为每个进程维护一个页表，用于描述每个进程的用户地址空间，以及一个描述内核地址空间的页表（所有进程共享这个描述内核地址空间的页表）。 内核配置其地址空间布局，使其能够访问可预测虚拟地址处的物理内存和各种硬件资源。 图 3.3 显示了此布局如何将内核虚拟地址映射到物理地址。 文件 (kernel&#x2F;memlayout.h) 声明了 xv6 内核内存布局的常量。</p><p>​QEMU模拟一台包含RAM的计算机，从物理地址0x80000000开始并持续到至少0x86400000，xv6称之为<code>PHYSTOP</code>。QEMU 模拟器还包括 I&#x2F;O 设备，例如磁盘接口。 QEMU 将设备接口暴露给软件作为内存映射控制寄存器，位于 0x80000000 以下物理地址空间。 内核可以通过读&#x2F;写这些特殊的物理地址来与设备进行交互； kernel对这些设备接口控制寄存器的访问是直接和这些设备交互而不是RAM进行交互的。</p><p>内核使用“直接映射”获取RAM和内存映射设备寄存器，将资源映射到与物理地址相同的虚拟地址。例如，内核本身在虚拟地址空间和物理内存中都位于KERNBASE&#x3D;0x80000000。直接映射简化了读取&#x2F;写入物理内存的内核代码。例如<code>fork</code>为子进程分配用户内存时，allocator返回该内存的物理地址； <code>fork</code> 在将父进程的用户内存复制到子进程时，直接使用该地址作为虚拟地址。</p><p>​有几个内核虚拟地址不是直接映射的：</p><ul><li>trampoline: （和user pagetable在同一个虚拟地址，以便在user space和kernel space之间跳转时切换进程仍然能够使用相同的映射，真实的物理地址位于kernel 文本中的<code>trampoline.S</code>）。</li><li>内核堆栈页面（kernel stack page）。 每个进程都有自己的内核栈，它被映射到高位，这样 xv6 可以在它下面留下一个未映射的保护页。 guard page的PTE是无效的（即没有设置PTE_V），所以如果内核溢出了内核栈，很可能会引发异常，内核会panic。 如果没有保护页，溢出的堆栈会覆盖其他内核内存，从而导致不正确的操作。</li><li>trampoline和trapframe由操作系统分配，用户进程无权访问</li></ul><p>​虽然内核通过高端内存映射使用其堆栈，但内核也可以通过直接映射地址访问它们。 另一种设计可能只有直接映射，并在直接映射地址处使用堆栈。 然而，在这种安排中，提供保护页将涉及取消映射虚拟地址，否则这些虚拟地址将引用物理内存，这将很难使用。</p><p>​内核使用 PTE_R 和 PTE_X 权限映射 trampoline 和内核文本的页面。 kernel从这些页面读取并执行指令。 kernel用PTE_R 和PTE_W 权限映射其他页面，以便它可以读写这些页面中的内存。 防止页的映射无效。</p><p>3.3 creating an address space</p><p>​大多数用于操作地址空间和页表的 xv6 代码都驻留在 vm.c (kernel&#x2F;vm.c:1) 中。 主要数据结构体是 <code>pagetable_t</code>，它实际上是一个指向 RISC-V 根页表页的指针； <code>pagetable_t</code> 可以是内核页表，也可以是每个进程页表之一。 核心功能是 <code>walk</code> 和 <code>mappages</code>，<code>walk</code>给定一个虚拟地址和一个页表返回一个PTE，后者给定一个页表、一个虚拟地址和物理地址，创建一个PTE以实现相应的映射。 以<code>kvm</code>开头的函数操作内核页表； 以 <code>uvm</code> 开头的函数操作用户页表； 其他功能用于两者。 <code>copyout</code> 和 <code>copyin</code> 从作为系统调用参数提供的用户虚拟地址复制数据； 它们在 vm.c 中，因为它们需要显式转换这些地址才能找到相应的物理内存。</p><p>​在引导序列的早期，main 调用 <code>kvminit</code> 以使用 <code>kvmmake</code> 创建内核的页表。 这个调用发生在 xv6 在 RISC-V 上启用分页之前，所以地址直接指向物理内存。 <code>kvmmake</code> 首先分配一个物理内存页来保存根页表页。 然后它调用 <code>kvmmap</code> 来安装内核需要的翻译。 翻译包括内核的指令和数据、直到 PHYSTOP 的物理内存，以及实际上是设备的内存范围。 <code>proc_mapstacks</code>为每个进程分配一个内核堆栈。 它调用 <code>kvmmap</code> 将每个堆栈映射到 KSTACK 生成的虚拟地址，这为无效的堆栈保护页面留出了空间。</p><p>​<code>kvmmap</code>调用 <code>mappages</code> ，它将映射安装到页表中，用于将一系列虚拟地址映射到相应的物理地址范围。 它以页面间隔为范围内的每个虚拟地址单独执行此操作。 对于每个要映射的虚拟地址，<code>mappages</code> 调用 <code>walk</code> 来查找该地址的 PTE 地址。 然后它初始化 PTE 以保存相关的物理页码、所需的权限（PTE_W、PTE_X 和&#x2F;或 PTE_R）和 PTE_V 以将 PTE 标记。</p><p>​<code>walk</code>  模仿 RISC-V 分页硬件，因为它在 PTE 中查找虚拟地址（见图 3.2）。 <code>walk</code>当时将3级页表向下9位。 它使用每一级的 9 位虚拟地址来查找下一级页表或最终页面的 PTE。 如果 PTE 无效，则所需页面尚未分配； 如果设置了 alloc 参数，walk 会分配一个新的页表页并将其物理地址放入 PTE 中。 它返回树中最低层的 PTE 地址。</p><p>​上面的代码依赖于物理内存被直接映射到内核虚拟地址空间。 例如，当遍历页表的下层时，它从 PTE中提取下一层页表的（物理）地址，然后将该地址用作虚拟地址 获取下一级的 PTE。</p><p>​main 调用 <code>kvminithart</code>安装内核页表。 它将根页表页的物理地址写入寄存器 <code>satp</code>。 此后，CPU 将使用内核页表转换地址。 由于内核使用恒等映射，下一条指令的当前虚拟地址将映射到正确的物理内存地址。</p><p>​每个RISC-V CPU都将页表条目缓存在转换后备缓冲区（TLB）中，当xv6更改页表时，它必须告诉CPU使相应缓存的TLB条目失效。如果没有这个操作，那么在稍后的某个时候，TLB可能会使用旧的缓存映射，指向同时已分配给另一个进程的物理页面，结果会导致一个进程可能会在某些页面上更改其他进程的内存。RISC-V有一个刷新当前CPU的TLB的指令：<code>sfence.vma</code>。xv6在重新加载satp寄存器后在<code>kvminithart</code>中执行<code>sfence.vma</code>，并在返回用户空间之前切换到用户页表的<code>trampoline</code>中执行<code>sfence.vma</code>。</p><p>​为避免刷新整个 TLB，RISC-V CPU 可能支持地址空间标识符 (ASID)。 然后内核可以只刷新特定地址空间的 TLB 条目。</p><p>3.4 Physical memory allocation</p><p>​内核必须在运行时为页表、用户内存、内核堆栈和管道缓冲区分配和释放物理内存。<br>​xv6 使用内核末尾和 PHYSTOP 之间的物理内存进行运行时分配。 它一次分配和释放以 4096 字节（为单位）的页面。 它通过将链接列表穿过页面本身来跟踪哪些页面是空闲的。 分配：从链表中删除一个页面； 释放：将页面添加到链表中。</p><p>3.5 code : Physical memory allocator</p><p>​分配器位于kalloc.c中，分配器的数据结构使可用于分配的物理内存页的空闲列表。每个免费页面的列表元素是一个可用于分配的结构。分配器从哪里获得内存来保存该数据结构？它将每个空闲页面的运行结构存储在空闲页面本身之中因为没有其他存储。 空闲列表由自旋锁 (kernel&#x2F;kalloc.c:21-24) 保护。 列表和锁被包装在一个结构中，以明确锁保护结构中的字段。</p><p>​函数 main 调用 <code>kinit</code> 来初始化分配器 (kernel&#x2F;kalloc.c:27)。 <code>kinit</code> 初始化空闲列表以保存内核末尾和 PHYSTOP 之间的每个页面。 xv6 应该通过解析硬件提供的配置信息来确定有多少物理内存可用。 相反，xv6 假定机器有 128 兆字节的 RAM。 kinit 调用 <code>freerange(end, PHYSTOP)</code> 通过每页调用 <code>kfree</code> 将内存添加到空闲列表。 PTE 只能引用在 4096 字节边界（是 4096 的倍数）上对齐的物理地址，因此 <code>freerange</code> 使用 PGROUNDUP 来确保它只释放对齐的物理地址。 分配器开始时没有内存； 这些对 <code>kfree</code> 的调用给它一些管理。</p><p>​分配器有时将地址视为整数以便对其执行算术运算（例如，遍历自由范围内的所有页面），有时将地址用作读写内存的指针（例如，操纵存储在每个页面中的运行结构）； 这种地址的双重使用是分配器代码充满 C 类型转换的主要原因。 另一个原因是释放和分配本质上改变了内存的类型。</p><p>​函数 <code>kfree</code> (kernel&#x2F;kalloc.c:47) 首先将要释放的内存中的每个字节设置为值 1。这将导致在释放内存后使用内存的代码（使用“悬挂引用”）读取垃圾而不是 旧的有效内容； 这会导致此类代码更快地崩溃。 然后 <code>kfree</code> 将页面添加到空闲列表：它将 pa 转换为指向 struct run 的指针，在 <code>r-&gt;next</code> 中记录空闲列表的旧开始，并将空闲列表设置为等于 r。 <code>kalloc</code> 删除并返回空闲列表中的第一个元素。</p><img src="/2023/02/19/MIT6-S081-chapter3/process.png" class="" title="架构图"><p>3.6 Process address space</p><p>​每个进程都有一个单独的页表，xv6 在进程之间切换时，也会改变页表。 如图 2.3 所示，一个进程的用户内存从虚拟地址 0 开始，并且可以增加到 MAXVA (kernel&#x2F;riscv.h:360)，原则上允许一个进程处理 256 GB 的内存。</p><p>​当进程向 xv6 请求更多用户内存时，xv6 首先使用 <code>kalloc</code> 分配物理页面。 然后它将 PTE 添加到指向新物理页面的进程页表中。 xv6 在这些 PTE 中设置 PTE_W、PTE_X、PTE_R、PTE_U 和 PTE_V 标志。 大多数进程不使用整个用户地址空间； xv6 在未使用的 PTE 中清除 PTE_V标注位。</p><p>​我们在这里看到了一些使用页表的很好的例子。 首先，不同进程的页表将用户地址翻译成不同的物理内存页，从而使每个进程拥有私有的用户内存。 其次，每个进程都将其内存视为具有从零开始的连续虚拟地址，而进程的物理内存可以是不连续的。 第三，内核在用户地址空间的顶部映射一个带有蹦床代码的页面，因此物理内存的单个页面出现在所有地址空间中。</p><p>​图 3.4 更详细地显示了 xv6 中执行进程的用户内存布局。 堆栈是单页的，显示的是 <code>exec</code> 创建的初始内容。 包含命令行参数的字符串以及指向它们的指针数组位于堆栈的最顶部。 紧接着是允许程序从 main 开始的值，就好像函数 main(argc, argv) 刚刚被调用一样。</p><p>​为了检测用户堆栈溢出分配的堆栈内存，xv6 通过清除 PTE_U 标志在堆栈正下方放置一个不可访问的保护页。 如果用户堆栈溢出并且进程试图使用堆栈下方的地址，则硬件将生成页面错误异常，因为在用户模式下运行的程序无法访问保护页面。 当用户堆栈溢出时，真实世界的操作系统可能会自动为用户堆栈分配更多内存。</p><p>3.7 code: sbrk</p><p>​<code>sbrk</code> 是进程缩小或增加其内存空间的系统调用。 系统调用由函数 <code>growproc</code> (kernel&#x2F;proc.c:253) 实现。 <code>growproc</code> 调用 <code>uvmalloc</code> 或 <code>uvmdealloc</code>，这取决于 n 是正数还是负数。 <code>uvmalloc</code> (kernel&#x2F;vm.c:221) 用<code>kalloc</code>分配物理内存，用<code>mappages</code>给用户页表添加PTE。 <code>uvmdealloc</code> 调用 <code>uvmunmap</code>(kernel&#x2F;vm.c:166)，它使用 <code>walk</code> 查找 PTE 并使用 <code>kfree</code> 释放它们引用的物理内存。</p><p>​xv6 使用进程的页表不仅告诉硬件如何映射用户虚拟地址，而且还作为唯一记录分配给该进程的物理内存页。 这就是为什么释放用户内存（在 uvmunmap 中）需要检查用户页表的原因。</p><p>3.8 code : exec</p><p><code>exec</code> 为以ELF格式定义的文件系统中的可执行文件创建用户空间。 <code>exec</code>先检查头文件中是否有ELF_MAGIC来判断这个文件是否是一个ELF格式定义的二进制文件，用<code>proc_pagetable</code>来为当前进程创建一个还没有映射的页表，然后用<code>uvmalloc</code>来为每个ELF segment分配物理空间并在页表中建立映射，然后用<code>loadseg</code>来把ELF <code>segment</code>加载到物理空间当中。注意<code>uvmalloc</code>分配的物理内存空间可以比文件本身要大。</p><p>接下来<code>exec</code>分配user stack，它仅仅分配一页给stack，通过<code>copyout</code>将传入参数的string放在stack的顶端，在ustack的下方分配一个guard page。</p><p>如果<code>exec</code>检测到错误，将跳转到<code>bad</code>标签，释放新创建的<code>pagetable</code>并返回-1。<code>exec</code>必须确定新的执行能够成功才会释放进程旧的页表(<code>proc_freepagetable(oldpagetable, oldsz)</code>)，否则如果system call不成功，就无法向旧的页表返回-1。</p><p>​exec使用<code>proc_pagetable</code>(kernel&#x2F;exec.c)分配一个没有用户映射的新页面，使用<code>uvmalloc</code>为每个ELF段分配内存，并加载每个段使用<code>loadseg</code>进入内存。<code>loadseg</code>使用<code>walladdr</code>找到分配内存的物理地址，在该地址写入ELF段的每个页面。并使用<code>readi</code>从文件中读取。</p><p><code>/init</code> 的程序节标题是用 exec 创建的第一个用户程序，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># objdump -p _init<br>user/_init: file format elf64-littleriscv<br><br>Program Header:<br>LOAD off 0x00000000000000b0 vaddr 0x0000000000000000<br>paddr 0x0000000000000000 align 2**3<br>filesz 0x0000000000000840 memsz 0x0000000000000858 flags rwx<br>STACK off 0x0000000000000000 vaddr 0x0000000000000000<br>paddr 0x0000000000000000 align 2**4<br>filesz 0x0000000000000000 memsz 0x0000000000000000 flags rw<br></code></pre></td></tr></table></figure><p>​程序节头的 filesz 可能小于 memsz，表明它们之间的间隙应该用零填充（对于 C 全局变量）而不是从文件中读取。对于 &#x2F;init，filesz 是 2112 字节，memsz 是 2136 字节，因此 uvmalloc 分配了足够的物理内存来容纳 2136 字节，但从文件 &#x2F;init 中只读取了 2112 字节。</p><p>​现在exec分配并初始化用户堆栈。它只分配一个堆栈页。exec一次将一个参数字符复制到栈顶，将指向它们的指针记录在ustack中。它在传递给main的argv列表的末尾放置一个空指针。ustack中的前三个条目是假的返回程序计数器、argc、和argv指针。</p><p>​exec将一个不可访问的页面放在堆栈页面的正下方，这样试图使用多个页面的程序就会出错。这个无法访问的页面还允许exec处理参数； 在这种情况下，exec 用于将参数复制到堆栈的 <code>copyout</code> (kernel&#x2F;vm.c:347) 函数将注意到目标页面不可访问，并将返回 -1。</p><p>​在准备新内存映像期间，如果 exec 检测到错误，如无效程序段，它会跳转到 <code>bad</code>标签，释放新映像，并返回 -1。 exec 必须等待释放旧映像，直到确定系统调用会成功：如果旧映像消失，系统调用不能返回 -1 给它。 exec 中唯一的错误情况发生在创建映像期间。 映像完成后，exec 可以提交到新页面(kernel&#x2F;exec.c:113) 并释放旧页表 (kernel&#x2F;exec.c:117)。</p><p>​exec 将 ELF 文件中的字节加载到内存中由 ELF 文件指定的地址。用户或进程可以将他们想要的任何地址放入 ELF 文件中。 因此 exec 是有风险的，因为 ELF 文件中的地址可能无意或有意地引用内核。粗心的内核导致的后果可能从崩溃到恶意破坏内核的隔离机制（即安全漏洞）。Xv6 执行大量检查以避免这些风险。 例如 if(ph.vaddr + ph.memsz &lt; ph.vaddr) 检查总和是否溢出 64 位整数。危险在于用户可以构造一个 ELF 二进制文件，其中 ph.vaddr 指向用户选择的地址，ph.memsz 足够大以至于总和溢出到 0x1000，这看起来像是一个有效值。在旧版本的 xv6 中，用户地址空间也包含内核（但在用户模式下不可读&#x2F;写），用户可以选择与内核内存相对应的地址，从而将数据从 ELF 二进制文件复制到内核中 。在 xv6 的 RISC-V 版本中，这种情况不会发生，因为内核有自己独立的页表； loadseg 加载到进程的页表中，而不是内核的页表中。</p><p>​内核开发人员很容易忽略关键检查，而现实世界的内核长期以来一直缺少检查，用户程序可以利用这些检查来获取内核特权。 xv6 很可能没有完成验证提供给内核的用户级数据的完整工作，恶意用户程序可能会利用它来绕过 xv6 的隔离。</p><p>3.9 real world</p><p>​与大多数操作系统一样，xv6使用分页硬件进行内存保护和映射。大多数操作系统通过结合分页和页面错误异常，比 xv6 更复杂地使用分页。</p><p>​xv6 通过内核使用虚拟地址和物理地址之间的直接映射进行了简化，并假设在地址 0x8000000 处存在物理 RAM，内核希望将其加载。 这适用于 QEMU，但在真正的硬件上它被证明是一个不好的idea； 真实硬件将 RAM 和设备放置在不可预测的物理地址，因此（例如）在 0x8000000 处可能没有 RAM，而 xv6 期望能够在此处存储内核。 更严谨的内核设计利用页表将任意硬件物理内存布局转换为可预测的内核虚拟地址布局。RISC-V 支持物理地址级别的保护，但 xv6 不使用该功能。 在具有大量内存的机器上，使用 RISC-V 对“超级页面”的支持可能是有意义的。 当物理内存较小时，小页面是有意义的，以允许以细粒度分配和页面出到磁盘。 例如，如果一个程序只使用 8 KB 的内存，那么给它一个完整的 4 MB 物理内存超级页面是一种浪费。 较大的页面在具有大量 RAM 的机器上有意义，并且可以减少页表操作的开销。xv6 内核缺少可以为小对象提供内存的类似 malloc 的分配器，这阻止了内核使用需要动态分配的复杂数据结构。</p><p>​内存分配是一个常年的热门话题，基本问题是如何有效的利用有限的内存和为未知的未来请求做准备。 如今，人们更关心速度而不是空间效率。 此外，更精细的内核可能会分配许多不同大小的小块，而不是（如在 xv6 中）仅分配 4096 字节的块； 一个真正的内核分配器需要处理小分配和大分配。</p><p>3.10 exercises</p><ol><li>解析 RISC-V 的设备树以找到计算机拥有的物理内存量。</li><li>编写一个用户程序，通过调用 sbrk(1) 将其地址空间增加一个字节。 运行程序并在调用 sbrk 之前和调用 sbrk 之后检查程序的页表。 内核分配了多少空间？ 新记忆的PTE包含什么？</li><li>修改 xv6 以使用内核的超级页面。</li><li>修改 xv6，以便当用户程序取消引用空指针时，它将收到异常。 也就是说，修改 xv6，使虚拟地址 0 不映射给用户程序。</li><li>exec 的 Unix 实现传统上包括对 shell 脚本的特殊处理。 如果要执行的文件以文本#! 开头，那么第一行将被视为要运行以解释该文件的程序。 例如，如果调用 exec 运行 myprog arg1 并且 myprog 的第一行是#!&#x2F;interp，那么 exec 运行 &#x2F;interp 命令行 &#x2F;interp myprog arg1。 在 xv6 中实现对这个约定的支持。</li><li>为内核实现地址空间随机化。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MIT6.S081-chapter2</title>
    <link href="/2023/02/13/MIT6-S081-chapter2/"/>
    <url>/2023/02/13/MIT6-S081-chapter2/</url>
    
    <content type="html"><![CDATA[<p>二、operating system organization</p><p>2.1 Abatracting physical resources</p><p>​       在这个计划中，每个应用程序甚至可以有自己的库来满足其需求。应用程序可以直接与硬件资源交互，并以最适合应用程序的方式使用这些资源（例如，实现高性能或可预测的性能）。一些嵌入式设备的操作系统或者实时的操作系统就是以这种方式运行。这种库方法的缺点是，如果有多个应用程序在运行，则这些应用程序必须运行良好。例如：每个应用程序必须周期性的放弃对CPU资源的使用以便于其它程序可以调用。如果每个程序都足够相信对方并且没有bug这样的合作的时分复用机制可以很OK的工作。但是没有bug和相信对方是难以实现的，因此一个比这个方案提供更强的隔离方案需要被提出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">*ip += <span class="hljs-number">1</span>;<span class="hljs-comment">//将ip指向的变量加1，相当于 ++*ip, 或（*ip)++。</span><br><span class="hljs-comment">//一元操作符从右向左结合，所以*ip++相当于*(ip++)</span><br><span class="hljs-comment">//指针的大小比较：只有在两个指针指向同一个数组的元素时比较才合法，指针只有相减是合法的</span><br></code></pre></td></tr></table></figure><p>C程序的内存分配方案： 堆（heap）由程序员通过malloc和free控制，地址从低向高增长；栈（stack）编译器自动分配释放，存放函数的参数、局部变量的值，在退出函数后自动销毁释放，地址从高向低增长。</p><p>实现一个强隔离性的方案将资源抽象成服务，对于禁止应用程序直接访问敏感的硬件资源是非常有用的。如unix程序和存储的交互通过文件系统的open、read、write和close系统调用，而不是直接读写磁盘。这为应用程序提供了路径名的便利，并允许操作系统（作为接口的实现者）管理磁盘。即使隔离不是问题，有意交互（或只是希望彼此远离）的程序也可能会发现文件系统是比直接使用磁盘更方便的抽象。</p><p>类似地，Unix 透明地在进程之间切换硬件 CPU，根据需要保存和恢复寄存器状态，因此应用程序不必知道时间共享。 这个透明度允许操作系统共享 CPU，即使某些应用程序处于无限状态循环。<br>​另一个例子是，unix使用exec系统调用来构建自己的内存映像来代替直接和物理内存交互。这允许操作系统来决定在内存的哪里放置一个进程。如果内存紧张，操作系统内甚至可能会将进程的数据存储在磁盘上，exec还提供给用户一个方便的文件系统用来存储可执行的程序映像。<br>​Unix 进程之间的许多形式的交互都是通过文件描述符发生的。 文件描述符不仅抽象出许多细节（例如，管道或文件中数据的存储位置），它们还以简化交互的方式定义。 例如，如果管道中的一个应用程序执行失败，内核会为管道中的下一个进程生成文件结束信号。</p><p>2.2 用户模式、超级模式、和系统调用</p><p>​强隔离的实现需要在程序和系统调用之间有一个坚硬的边界。如果程序出错我们不希望操作系统和其他程序出现差错。而是希望操作系统能够清理这些出错的程序并继续执行其他的程序。为了实现这样的强隔离，操作系统必须安排让应用程序不能修改或读取操作系统的数据，并且应用程序不能访问其他的程序的内存。</p><p>​CPU提供了这样的硬件支持。如RISC-V有三种让CPU执行的模式：machine mode, supervisor mode, user mode。在machine mode拥有最高的执行权力，CPU从该模式启动。用来配置计算机。XV6只在该模式下执行少量的程序然后切换到supevisor mode。</p><p>​在supervisor mode下，CPU允许执行拥有特权的指令，例如：使能&#x2F;失能中断，读写存储有page table的寄存器的值。如果应用程序在user mode想要执行特权的指令，CPU会禁止执行。一个应用程序只有在user mode下执行，如执行++i操作，在用户空间（user space）执行。在superivsor mode下执行的程序我们称之为运行在内核空间（kernel space）。</p><p>一个用户态的程序想要唤醒一个核函数必须先进入到核空间，不能直接唤醒一个核函数。CPU 提供了一条特殊的指令，可以将 CPU 从用户模式（user mode）切换到管理员模式(supervisor mode)，并在内核指定的入口点进入内核（RISC-V提供了<code>ecall</code>指令用来完成这样的任务，<code>ecall</code>指令：跳转到trampoline代码）。一旦CPU切换到supervisor mode，内核就会验证这些系统指令的参数（例如，检查传递给系统调用的地址是否是应用程序内存的一部分）从而决定是否允许应用程序执行请求的操作（例如，检查是否允许应用程序写入指定的文件），然后决定是拒绝它或执行它。内核控制转换到管理模式的入口点很重要； 例如，如果应用程序可以决定内核入口点，则恶意应用程序可以在跳过参数验证的位置进入内核。要想从supervisor mode切换到user mode，调用<code>sret</code>指令。</p><p>2.3 kernel organization</p><p>一个关键的问题是操作系统在管理者模式下该运行什么程序。一种可能是整个操作系统驻留在内核中，因此所有的系统调用的实现都运行在管理者模式。这种模式称为单片内核（monolithic kernel）。在这种形势下，整个操作系统拥有整个的硬件权限。这种组织方式很方便，因为操作系统设计者不必决定操作系统的哪一部分不需要完整的硬件特权。此外，操作系统的不同部分更容易协作。例如，操作系统可能有一个缓冲区缓存，它可以由文件系统和虚拟内存系统共享。这种组织的一个缺点是操作系统不同部分之间的接口通常很复杂，因此操作系统开发人员很容易犯错误。然而在这种模式下，一个错误的发生就会是致命的，因为在supervisor mode下的一个错误往往会导致内核失败，从而导致计算机停止工作。</p><p>​为了降低内核出错的风险，操作系统设计人员可以最大限度地减少在管理员模式下运行的操作系统代码量，并在用户模式下执行大部分操作系统。 这种内核组织称为微内核（micro kernel）。</p><img src="/2023/02/13/MIT6-S081-chapter2/microkernel.png" class="" title="架构图"><p>在图中，文件系统作为用户级进程运行。 作为进程运行的操作系统服务称为服务器。 为了允许应用程序与文件服务器进行交互，内核提供了一种进程间通信机制，可以将消息从一个用户模式进程发送到另一个用户模式进程。例如，如果像 shell 这样的应用程序想要读取或写入文件，它会向文件服务器发送消息并等待响应。在微内核中，内核接口由一些低级函数组成，用于启动应用程序、发送消息、访问设备硬件等。这种组织允许内核相对简单，因为大多数操作系统驻留在用户级服务器中。</p><p>​在现实世界中，单体内核和微内核都很流行。 许多 Unix 内核是单一的。 例如，Linux 有一个单一的内核，尽管一些操作系统功能作为用户级服务器运行（例如，窗口系统）。 Linux 为操作系统密集型应用程序提供高性能，部分原因是内核的子系统可以紧密集成。 Minix、L4 和 QNX 等操作系统被组织为带有服务器的微内核，并且在嵌入式设备中得到了广泛部署。 L4 的变体 seL4 足够小，以至于它已经过内存安全和其他安全属性的验证。操作系统的开发人员之间存在很多争论，认为哪种组织更好，并且没有任何一种方式的确凿证据。 此外，它在很大程度上取决于“更好”的含义：更快的性能、更小的代码大小、内核的可靠性、整个操作系统（包括用户级服务）的可靠性等。还有一些实际考虑可能比哪个组织的问题更重要。 一些操作系统有一个微内核，但出于性能原因，在内核空间中运行一些用户级服务。 一些操作系统具有整体内核，因为它们是这样开始的，并且没有动力转向纯微内核组织，因为新功能可能比重写现有操作系统以适应微内核设计更重要。</p><p>​与大多数 Unix 操作系统一样，Xv6 是作为一个整体内核实现的。 这样，xv6内核接口对应操作系统接口，内核实现了完整的操作系统。 由于 xv6 不提供很多服务，它的内核比一些微内核更小，但概念上 xv6 是整体的。</p><p>2.4 XV6 organization</p><img src="/2023/02/13/MIT6-S081-chapter2/organization.png" class="" title="架构图"><p>trampoline.S(汇编代码)</p><ul><li><p>对ecall瞬间的状态做快照</p><ul><li>填充struct trapframe (proc.h)</li><li>利用$sscratch(S-mode scratch) 保存所有寄存器</li><li>切换到内核栈（相当于切换到进程对应的“内核线程”）</li><li>切换到内核地址空间</li><li>跳转到tf-&gt;kernel_trap</li></ul><p>2.5 Process overview</p><p>xv6（和其他 Unix 操作系统一样）中的隔离单元是一个进程。进程抽象防止一个进程破坏或监视另一个进程的内存、CPU、文件描述符等。它还可以防止进程破坏内核本身，这样进程就无法破坏内核的隔离机制。内核必须小心地实现进程抽象，因为错误或恶意应用程序可能会诱使内核或硬件做一些坏事（例如，规避隔离）。内核用于实现进程的机制包括用户&#x2F;管理员模式标志、地址空间和线程的时间片。</p><p>​为了帮助加强隔离，进程抽象为程序提供了它拥有自己的私有机器的错觉。一个进程为程序提供了一个看似私有的内存系统或地址空间，其他进程无法读取或写入。 一个进程还为程序提供似乎是它自己的 CPU 来执行程序的指令。</p><p>​xv6 使用<code>page table</code>（由硬件实现）为每个进程提供自己的地址空间。 RISC-V 页表将虚拟地址（RISC-V 指令操作的地址）转换（或“映射”）为物理地址（CPU 芯片发送到主内存的地址）。</p><p>​xv6 为每个定义进程地址空间的进程维护一个单独的页表。 如图 2.3 所示，地址空间包括从虚拟地址零开始的进程的用户内存。首先是指令，然后是全局变量，然后是堆栈，最后是进程可以根据需要扩展的“堆”区域（用于 malloc）。 有许多因素会限制进程地址空间的最大大小：RISC-V 上的指针是 64 位宽； 硬件在页表中查找虚拟地址时只使用低 39 位； 而 xv6 只使用了这 39 位中的 38 位。因此，最大地址为 $2^{38}$ − 1 &#x3D; 0x3fffffffff，即MAXVA。在地址空间的顶部，xv6 保留了一个页面用于 trampoline 和一个映射进程的 trapframe 的页面。xv6 使用这两个页面来回转换到内核； trampoline 页面包含进出内核的代码，映射 trapframe 是保存&#x2F;恢复用户进程状态所必需的.</p><p>​xv6 内核为每个进程维护许多状态，并将其收集到一个 struct proc 中。进程最重要的内核状态部分是它的页表、内核堆栈和运行状态。 我们将使用符号 p-&gt;xxx 来指代 proc 结构的元素； 例如，p-&gt;pagetable 是指向进程页表的指针，p-&gt;kstack是指向内核堆栈的指针，p-&gt;state是指向运行状态的指针。</p><p>​每个进程都有一个执行线程（或简称线程）来执行进程的指令。 一个线程可以被挂起并稍后恢复。为了在进程之间透明地切换，内核挂起当前运行的线程并恢复另一个进程的线程。 线程的大部分状态（局部变量、函数调用返回地址）都存储在线程的堆栈中。每个进程都有两个栈：<strong>用户栈</strong>和<strong>内核栈</strong>（p-&gt;kstack）。 当进程在执行用户指令时，只有它的用户栈在使用，它的内核栈是空的。当进程进入内核时（系统调用或中断），内核代码在进程的内核栈上执行； 当一个进程在内核中时，它的用户堆栈仍然包含保存的数据，但不会被主动使用。进程的线程在主动使用其用户堆栈和内核堆栈之间交替。 内核堆栈是独立的（并且不受用户代码的影响），因此即使进程破坏了其用户堆栈，内核也可以执行。<br>​进程可以通过执行RISC-V 的<code>ecall</code>指令进行系统调用。该指令提高硬件特权级别并将程序计数器更改为内核定义的入口点。入口点的代码切换到内核堆栈并执行完成系统调用的内核指令。当系统调用完成后护内核切换回用户栈，通过调用<code>sret</code>指令返回用户空间，降低硬件的特权级别，恢复执行系统调用指令的用户指令。进程的线程可以在内核中“阻塞”以等待I&#x2F;O, 并在I&#x2F;O完成后从中断恢复。</p><p>​p-&gt;state 表示进程是否已分配、准备运行、运行、等待 I&#x2F;O 或退出。</p><p>​p-&gt;pagetable 以 RISC-V 硬件期望的格式保存进程的页表。</p><p>​xv6 导致分页硬件在用户空间中执行该进程时使用该进程的 p-&gt;pagetable。 一个进程的页表同时也记录了分配给进程内存的物理页的地址。</p><p>​总而言之，一个进程捆绑了两种设计思想：地址空间让进程产生自己内存的错觉，线程让进程产生自己的 CPU 错觉。 在 xv6 中，一个进程由一个地址空间和一个线程组成。 在真实的操作系统中，一个进程可能有多个线程来利用多个 CPU。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span>&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">procstate</span> <span class="hljs-title">state</span>;</span><br>    <span class="hljs-type">void</span> *chan;<br>    <span class="hljs-type">int</span> killed;<br>    <span class="hljs-type">int</span> xstate;<br>    <span class="hljs-type">int</span> pid;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">parent</span>;</span><br>    uint64 kstack;<br>    uint64 sz;<br>    <span class="hljs-type">pagetable_t</span> pagetable;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tranfarme</span> *<span class="hljs-title">tranframe</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> <span class="hljs-title">context</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">ofile</span>[<span class="hljs-title">NOFILE</span>];</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">cwd</span>;</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">16</span>];<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpu</span>&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">proc</span>;</span> <span class="hljs-comment">//the process running on this cpu or null</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> <span class="hljs-title">context</span>;</span> <span class="hljs-comment">//swtch() here to enter scheduler()</span><br>    <span class="hljs-type">int</span> noff; <span class="hljs-comment">// depth of push_off() nesting</span><br>    <span class="hljs-type">int</span> intena; <span class="hljs-comment">// were interrupts enabled before push_off</span><br>&#125;<br><br><br><span class="hljs-keyword">struct</span> proc* <span class="hljs-title function_">myproc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    push_off();<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpu</span>* <span class="hljs-title">c</span> =</span> mycpu();<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> c -&gt; proc;<br>    pop_off();<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-keyword">struct</span> cpu* <span class="hljs-title function_">mycpu</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-type">int</span> id = cpuid();<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpu</span>* <span class="hljs-title">c</span> =</span> &amp;cpu[id];<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.6 starting xv6, the first process and system call</p><p>​为了使 xv6 更具体，我们将概述内核如何启动和运行第一个进程。 后续章节将更详细地描述本概述中出现的机制。</p><p>​当 RISC-V 计算机开机时，它会自行初始化并运行存储在ROM中的引导加载程序（bootloader.ld）。 引导加载程序将 xv6 内核加载到内存中。 然后，在机器模式下(machine mode)，CPU 从 _entry (kernel&#x2F;entry.S:7) 开始执行 xv6。 RISC-V 从禁用分页硬件开始：虚拟地址直接映射到物理地址。</p><p>​加载程序将 xv6 内核加载到物理地址 0x80000000 的内存中。 它将内核放在 0x80000000 而不是 0x0 的原因是因为地址范围 0x0:0x80000000 之间包含有 I&#x2F;O 设备。</p><p>​<code>_entry</code> 处的指令设置了一个stack，以便 xv6 可以运行 C 代码。 xv6 在文件 start.c 中为初始堆栈 stack0 声明了空间。 _entry 处的代码将堆栈指针寄存器 sp 加载到地址 stack0+4096，堆栈的顶部，因为 RISC-V 上的堆栈向下增长。 现在内核有了堆栈，entry 在开始时调用 C 代码。</p><p>​函数 <code>start</code> 执行一些只允许在机器模式下进行的配置，然后切换到管理员模式。 为了进入管理模式，RISC-V 提供了指令 <code>mret</code>。 这个指令最常用于从先前的管理模式调用返回到机器模式。 <code>start</code> 不会从这样的调用中返回，而是将事情设置为好像有一个：它在寄存器 mstatus 中将先前的特权模式设置为主管，它通过将 main 的地址写入寄存器 mepc 来将返回地址设置为 main ，通过将 0 写入页表寄存器 <code>satp</code> 来禁用管理员模式下的虚拟地址转换，并将所有中断和异常委托给管理员模式。</p><p>​在进入管理模式之前，<code>start</code>还执行一项任务，它对时钟芯片进行编程以生成定时器中断。完成这些任务处理后，通过调用<code>mret</code>开始“返回”到管理模式，这会导致程序计数器（pc）切换到main。在main初始化几个设备和子系统后，通过调用<code>userinit</code>创建第一个进程，第一个进程执行一个用RISC-V汇编编写的小程序，make进行xv6中的第一个系统调用，initcode.S将exec系统调用的编号SYS_EXEC加载到寄存器a7当中，然后调用ecall重新进入内核。</p><p>​内核在系统调用中使用寄存器<code>a7</code>中的数字来调用所需的系统调用。系统调用将SYS_EXEC映射到内核调用的sys_exec。正如我们在第一章中看到的，exec用一个新程序代替了当前进程的内存和寄存器。</p><p>​一旦内核完成exec之后，它就会在&#x2F;init进程中返回到用户空间。如果需要，init会创建一个新的控制台设备文件，然后将其以文件描述符0，1，2打开。然后它会在控制台上启动一个shell，此时系统就被启动了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">RISC-V启动时，先运行一个存储于ROM中的bootloader程序kernel.ld来加载xv6 kernel到内存中，然后在machine模式下从_entry开始运行xv6。bootloader将xv6 kernel加载到0x80000000的物理地址中，因为前面的地址中有I/O设备<br><br>在_entry中设置了一个初始stack，stack0来让xv6执行kernel/start.c。在start函数先在machine模式下做一些配置，然后通过RISC-V提供的mret指令切换到supervisor mode，使program counter切换到kernel/main.c<br><br>main先对一些设备和子系统进行初始化，然后调用kernel/proc.c中定义的userinit来创建第一个用户进程。这个进程执行了一个initcode.S的汇编程序，这个汇编程序调用了<span class="hljs-built_in">exec</span>这个system call来执行/init，重新进入kernel。<span class="hljs-built_in">exec</span>将当前进程的内存和寄存器替换为一个新的程序(/init)，当kernel执行完毕<span class="hljs-built_in">exec</span>指定的程序后，回到/init进程。/init(user/init.c)创建了一个新的console device以文件描述符0,1,2打开，然后在console device中开启了一个shell进程，至此整个系统启动了<br></code></pre></td></tr></table></figure><p>2.7 security model</p><p>您可能想知道操作系统如何处理错误或恶意代码。 因为处理恶意比处理意外错误要难得多，所以将这个主题视为与安全有关。 这是操作系统设计中典型安全假设和目标的高级视图。</p><p>​操作系统必须假定进程的用户级代码会尽最大努力来破坏内核或其他进程。用户代码可能会尝试取消引用其与允许地址空间之外的指针空间，他可能会尝试执行任何RISC-V指令。即使是那些不打算用于用户代码的指令，他可能会尝试读写任何RISC-V控制寄存器，他可能会尝试直接访问设备硬件，他可能会将巧妙地值传递给系统调用，以试图诱使内核崩溃或做一些愚蠢的事情。内核的目标是限制每个用户进程，以便所有它可以做的事read&#x2F;write&#x2F;execute自己的用户内存。使用32位通用RISC-V寄存器，并以系统调用旨在允许的方式影响内核和其他进程。内核必须阻止任何其他操作，这通常事内核设计中的绝对要求。</p><p>​对内核自身代码的期望是完全不同的。 内核代码被假定是由善意和细心的程序员编写的。 内核代码应该没有错误，当然也不包含任何恶意内容。 这个假设会影响我们分析内核代码的方式。 例如，有许多内部内核函数（例如自旋锁）如果内核代码使用不当会导致严重问题。 在检查任何特定的内核代码时，我们想要说服自己它的行为是正确的。 然而，我们假设内核代码通常是正确编写的，并且遵循关于使用内核自己的函数和数据结构的所有规则。 在硬件层面，假定 RISC-V CPU、RAM、磁盘等按照文档中宣传的方式运行，没有硬件错误.</p><p>​当然，在现实生活中的事情并没有那么简单，很难防止聪明的用户代码通过消耗内核保护的资源（磁盘空间、CPU时间、进程表等）使系统无法使用或崩溃。通常不可能编写没有错误的代码，如果恶意用户代码的编写者直到内核或硬件错误，他们就会利用这些漏洞。值得在内核中设计安全措施以防止它有错误的可能性：断言、类型检查、堆栈保护页面等。</p><p>2.8 real word</p><p>​大多数操作系统都采用了进程的概念，而且大多数进程看起来与 xv6 的类似。 然而，现代操作系统支持一个进程中的多个线程，以允许单个进程利用多个 CPU。 在一个进程中支持多个线程涉及 xv6 所没有的相当多的机制，包括潜在的接口更改（例如，Linux 的克隆，fork 的变体），以控制进程线程共享的哪些方面。</p><p>2.9 experiment</p><ol><li>在xv6中添加一个系统调用并返回还有多少可用的内存空间的大小。</li></ol><p>常见的记录空闲页的方法有：空闲表法，空闲链表法，位示图法，成组链接法。xv6使用的是空闲链表法</p><p>实现sys_info</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysinfo</span>&#123;</span><br>    uint64 freemem; <span class="hljs-comment">// amount of free memory (bytes)</span><br>    uint64 nproc; <span class="hljs-comment">//number of process</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MIT6.S081-chapter1</title>
    <link href="/2023/02/07/MIT6-S081-chapter1/"/>
    <url>/2023/02/07/MIT6-S081-chapter1/</url>
    
    <content type="html"><![CDATA[<h3 id="《xv6-a-simple-Unix-like-teaching-operating-system》"><a href="#《xv6-a-simple-Unix-like-teaching-operating-system》" class="headerlink" title="《xv6: a simple, Unix-like teaching operating system》"></a>《xv6: a simple, Unix-like teaching operating system》</h3><p>一、 操作系统接口（Operating system interfaces）</p><p>​操作系统的工作是在多个程序之间共享一台计算机，并提供一个比硬件本身支持的更有用的服务集，操作系统在多个程序之间共享硬件资源，以便它们（看似）同时运行，操作系统为程序交互提供受控方式，以便它们可以共享数据或者协同工作。</p><img src="/2023/02/07/MIT6-S081-chapter1/xv6.png" class="" title="xv6架构图"><p>每个运行的程序称之为进程，由包含指令的内存，数据和栈组成。指令实行程序的计算，数据交由计算执行，栈管理程序的调度。当一个进程需要唤醒一个kernel服务，它就唤醒了一个system call，每个system call 进入内核，内核完成服务并返回。kernel使用了硬件保护机制提供给CPU，确保每个进程在自己的用户空间只能访问自己的内存。用户程序执行时没有这种特权，当一个用户程序唤醒一个系统调用时，硬件会提升权限并开始执行预先在内核中排序好的程序。内核提供的系统调用集合是用户程序看到的接口。</p><p>shell是一个原生的程序用来读取指令并执行。实际上，shell是一个用户程序，而不是内核的一部分。</p><p>1.1 processes and memory</p><p>xv6包含用户空间内存（指令、数据、栈），和内核私有的每个进程状态。当进程不再执行时xv6将存储和这些进程相关的CPU寄存器直到下一次运行这些进程，内核通过pid连接每个进程。</p><p><code>int fork()</code>：一个进程可以通过<code>fork</code>创建一个新的进程，提供相同的内存上下文包括指令和数据，但内存地址和寄存器是不一样的，父进程返回子进程的pid，子进程返回0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> pid = fork();  <span class="hljs-comment">//fork之后，父子进程同时开始判断pid的值，看哪个进程先判断好pid才会决定输出顺序。</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pid=%d\n&quot;</span>, pid);<br><span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent: child=%d\n&quot;</span>, pid);<br>pid = wait((<span class="hljs-type">int</span> *) <span class="hljs-number">0</span>); <span class="hljs-comment">//父进程发现子进程exit之后，wait执行完毕，打印输出。</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child %d is done\n&quot;</span>, pid);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child: exiting\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">//子进程在判断pid==0之后将exit,</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork error\n&quot;</span>);<br>&#125;<br><br>---<br>输出：<br>pid=<span class="hljs-number">2018356</span><br>parent:child=<span class="hljs-number">2018356</span><br>pid=<span class="hljs-number">0</span><br>child:existing<br>child <span class="hljs-number">2018356</span> is done  <span class="hljs-comment">//当子进程退出后，父进程的wait就会返回。</span><br><br></code></pre></td></tr></table></figure><p><code>int exit(int status)</code>: 系统调用会停止执行并释放资源,如内存和打开的文件,需要一个整型的状态参数，返回值0表示正常状态退出，1表示非正常状态退出。</p><p><code>int wait(int *status)</code>：系统调用返回当前进程被停止或被杀掉的子进程的状态，返回子进程的PID， 子进程的退出状态存储到 int *status这个地址中，并将状态码拷贝到内存中等待。如果调用者没有子进程，wait立即返回-1，如果父进程不在乎子进程的退出态，它可以给一个0地址给wait。父进程和子进程有着相同的内存上下文，但是在不同的内存和寄存器中执行。改变一个并不会改变另一个。如当wait的返回值被父进程存储到pid中时，它不会改变子进程中变量pid中的值，子进程中的变量pid的值还是0。</p><p><code>int exec(char *file, char *argv[])</code>:加载一个文件，获取执行它的参数，执行，如果执行错误返回-1，执行成功不返回，而是开始从文件入口位置开始执行命令。文件必须有一个特殊的格式，必须指明哪一部分是保存指令，哪一部分是数据。xv6使用的是ELF文件格式，当exec成功时，他不会返回给调用程序，相反，从文件加载的指令在 ELF 标头中声明的入口点开始执行。exec输入两个参数：文件包含的可执行文件名和一组参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//xv6 shell使用以上四个system call来为用户执行程序。在shell进程的main中主循环先通过getcmd来从用户获取命令，然后调用fork来运行一个和当前shell进程完全相同的子进程。父进程调用wait等待子进程exec执行完（在runcmd中调用exec）</span><br><br><span class="hljs-type">char</span> *argv[<span class="hljs-number">3</span>];<br>argv[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;echo&quot;</span>;<br>argv[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;hello&quot;</span>;<br>argv[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<br>exec(<span class="hljs-string">&quot;/bin/echo&quot;</span>, argv);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;exec error\n&quot;</span>);<br><span class="hljs-comment">//---------------------------------------------------</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">char</span> buf[<span class="hljs-number">100</span>];<br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-comment">// ensure that three file descriptions are open.</span><br>    <span class="hljs-keyword">while</span>(fd = open(<span class="hljs-string">&quot;console&quot;</span>, O_RDWR ) &gt;= <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(fd &gt;= <span class="hljs-number">3</span>)&#123;<br>            close(fd);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// read and run input commands</span><br>    <span class="hljs-keyword">while</span>(getcmd(buf, sizesof(buf)) &gt;= <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(buf[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;c&#x27;</span> &amp;&amp; buf[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;d&#x27;</span> &amp;&amp; buf[<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>            <span class="hljs-comment">// chdir must be called by the parent, not the child.</span><br>            buf[<span class="hljs-built_in">strlen</span>(buf) - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(chdir(buf + <span class="hljs-number">3</span>) &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;cannot cd %s\n&quot;</span>, buf + <span class="hljs-number">3</span>);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(fork1() == <span class="hljs-number">0</span>)<br>            runcmd(parsecmd(buf));<br>        wait(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>避免创建重复进程然后立即替换它的浪费,操作内核通过使用虚拟内存技术（如写时复制 copy-on-write）优化此用例的 <code>fork</code> 实现。xv6 隐式分配大部分用户空间内存：<code>fork</code> 分配父内存的子副本所需的内存，<code>exec</code> 分配足够的内存来保存可执行文件。在运行时需要更多内存的进程（可能是 <code>malloc</code>）可以调用 <code>sbrk(n)</code> 将其数据内存增加 n 字节； <code>sbrk</code> 返回新内存的位置。</p><p>1.2 输入输出和文件描述符 (I&#x2F;O and file descriptors)</p><p>文件描述符是用来表征一个进程将从哪里读取或者写入到哪里的内核管理对象。一个进程可以通过打开一个文件、目录或设备或创建一个管道，或复制一个已经存在的描述符。文件描述符接口抽象了文件、管道和设备之间的差异，使它们看起来都像字节流。xv6 内核使用文件描述符作为每个进程表的索引，因此每个进程都有一个从零开始的文件描述符的私有空间。每个进程都拥有自己独立的文件描述符列表，<strong>其中0是标准输入，1是标准输出，2是标准错误</strong>。shell将保证总是有3个文件描述符是可用的。</p><p><code>int read(int fd, char * buf, int n)</code>; 从文件描述符<code>fd</code>中读取n字节的数据拷贝到<code>buf</code>中，<strong>返回值是读取的字节数</strong>。每个文件描述符都有一个与之相关的offset。read 从当前文件偏移量读取数据，然后将该偏移量增加读取的字节数，下一个<code>read</code>将从新的<code>offset</code>开始读取字节，当没有更多的字节可以读取时，<code>read</code>返回0来表示读取到文件的结束。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSGSIZE 16</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[])</span>&#123;<br>    <span class="hljs-type">char</span> buf[MEGSIZE];<br>    read(<span class="hljs-number">0</span>, buf, MSGSIZE); <span class="hljs-comment">//获取前一个命令的标准化输出，即当前命令的标准化输入</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;获取到的标准化输入:%s\n&quot;</span>, buf);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>int write(int fd, char *buf,int n)</code>；从buf中写入n字节的数据到文件描述符fd中，返回值是有多少的字节数据被写入。当少于n个字节的数据被写入时互出现错误，通read一样存在偏移量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//cat命令的实现</span><br><span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>];<br><span class="hljs-type">int</span> n;<br><span class="hljs-keyword">for</span>(;;)&#123;<br>    n = read(<span class="hljs-number">0</span>, buf, <span class="hljs-keyword">sizeof</span> buf);<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;read error\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(write(<span class="hljs-number">1</span>, buf, n) != n)&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;write error\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>int close(int fd)</code>:系统调用，释放一个文件描述符，让它变得可以被未来的open pipe 或者dup系统调用使用。</p><p><code>fork</code>拷贝父进程的文件描述符到自己的内存空间中，因此子进程可以像父进程一样打开文件，<code>exec</code>代替了调用进程的内存，但是将它保留在文件表中。父进程的<code>fd table</code>将不会被子进程<code>fd table</code>的变化影响，但是文件中的<code>offset</code>将被共享。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// cat 命令的实现 cat &lt; input.txt</span><br><span class="hljs-type">char</span> *argv[<span class="hljs-number">2</span>];<br>argv[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;cat&quot;</span>;<br>argv[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>)&#123;<br>    close(<span class="hljs-number">0</span>);<br>    open(<span class="hljs-string">&quot;input.txt&quot;</span>, O_RDONLY);<br>    exec(<span class="hljs-string">&quot;cat&quot;</span>, argv);<br>&#125;<br></code></pre></td></tr></table></figure><p>关键字： O_RDONLY：打开文件for reading, OWRONLY:打开文件for writting, , ORDWR:打开文件for reading and writting , O_CREATE:如果文件不存在，就创造它, O_TRUNC：将文件截断到0的长度。</p><p><code>int dup(int fd)</code>:系统调用，返回一个引用相同底层 I&#x2F;O 对象的新对象。两个文件描述符共享一个偏移量，就像 fork 复制的文件描述符一样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// another way to write hello world</span><br>fd = dup(<span class="hljs-number">1</span>);<br>write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;hello &quot;</span>, <span class="hljs-number">6</span>);<br>write(fd, <span class="hljs-string">&quot;world\n&quot;</span>, <span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure><p>如果两个文件描述符是通过一系列 <code>fork</code> 和 <code>dup</code> 调用从同一个原始文件描述符派生的，则它们共享一个偏移量,否则文件描述符不共享偏移量，即使它们来自对同一文件的打开调用。<code>dup</code> 允许shell去实现一个这样的命令： ls existing-file non-existing-file &gt; tmp1 2 &gt;&amp;1, 2&gt;&amp;1 告诉 shell 给命令一个文件描述符 2，它是描述符 1 的副本。现有文件的名称和不存在文件的错误消息都将显示在文件 tmp1 中.xv6 shell 不支持错误文件描述符的 I&#x2F;O 重定向，但现在你知道如何实现它了。</p><p>1.3管道</p><p>管道是一个小的内核缓冲区，作为一对文件描述符暴露给进程，一个用于读取，一个用于写入。将数据写入管道的一端使该数据可用于从管道的另一端读取。 管道为进程提供了一种通信方式。（FIFO实现）</p><p><code>int pipe(int p[])</code>:p[0]为读取的fd,p[1]为写入的fd。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//以下示例代码运行程序 wc，标准输入连接到管道的读取端。</span><br><span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br><span class="hljs-type">char</span> *argv[<span class="hljs-number">2</span>];<br>argv[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;wc&quot;</span>;<br>argv[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>pipe(p);<br><span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>)&#123;<br>    close(<span class="hljs-number">0</span>);<br>    dup(p[<span class="hljs-number">0</span>]);<br>    close(p[<span class="hljs-number">0</span>]);<br>    close(p[<span class="hljs-number">1</span>]);<br>    exec(<span class="hljs-string">&quot;/bin/wc&quot;</span>, argv);<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>    close(p[<span class="hljs-number">0</span>]);<br>    write(p[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;hello world\n&quot;</span>, <span class="hljs-number">12</span>);<br>    close(p[<span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-comment">//这段程序叫做pipe，它创造了一个新的管道来记录读和写的文件描述符在数组p中。在fork之后，父进程和子进程都会有文件描述符指向这个管道，子进程调用close和dup来让文件描述符0引用管道的读取端，关闭文件描述符，之后调用exec执行wc指令，当wc读取它的标准输入时，它从管道读取，父进程关闭了管道的读取端，写管道，然后关闭写端。</span><br></code></pre></td></tr></table></figure><p>如果没有数据可用，则管道上的读取等待写入数据或关闭引用写入端的所有文件描述符； 在后一种情况下，read 将返回 0，就像已到达数据文件的末尾一样。 读取阻塞直到新数据不可能到达的事实是子进程在执行上面的 wc 之前关闭管道的写入端很重要的一个原因：如果 wc 的文件描述符之一引用了写入端管道，wc永远看不到文件结束。</p><p>xv6的shell实现一个这样的命令： <code>grep fork sh.c | wc -l</code>，子进程创建一个管道来连接管道的左端和右端。之后在管道左端调用fork和runcmd指令，在管道右端调用fork和runcmd指令，然后等待两边都结束。管道的右端可能是一个命令，它本身包含一个管道（例如，a | b | c），它本身会派生两个新的子进程（一个用于 b，一个用于 c）。因此，shell 可以创建一个进程树。这棵树的叶子节点是命令，内部节点是等待左右子节点完成的进程。原则上，可以让内部节点运行在管道的左端，但如果这样做正确的话会使实施变得复杂。考虑仅进行以下修改：<br>将 sh.c 更改为不分叉 <code>p-&gt;left</code> 并在内部进程中运行 <code>runcmd(p-&gt;left)</code>。之后例如：<code>echo hi | wc</code>不会产生输出，因为在<code>runcmd</code>中echo hi退出时，内部进程退出，从不调用fork运行右端管道,这种不正确的行为可以通过不在 runcmd 中为内部进程调用 exit 来修复，但此修复使代码复杂化：现在 <code>runcmd</code> 需要知道它是否在内部进程中。当不分叉 <code>runcmd(p-&gt;right)</code> 时也会出现并发症。例如，仅进行该修改，<code>sleep 10 | echo hi</code> 将立即打印“hi”和一个新提示，而不是在 10 秒后； 发生这种情况是因为 echo 立即运行并退出，而不是等待 sleep 完成。由于 sh.c 的目标是尽可能简单，它不会试图避免创建内部进程。</p><p>在这种情况下，管道比临时文件至少有四个优势。第一：管道会自动清理自己，使用文件重定向，shell必须小心删除&#x2F;tmp&#x2F;xyz当它执行完成后。其次，管道可以传递任意长的数据流，而文件重定向需要磁盘上有足够的可用空间来存储所有数据。 第三、管道允许管道并行执行阶段，而文件方法要求第一个程序在第二个程序开始之前完成。 第四，如果你正在实现进程间通信，管道的阻塞读写比文件的非阻塞语义更高效。</p><p>1.4文件系统</p><p>xv6 文件系统提供数据文件，其中包含未解释的字节数组（byte array）和目录，其中包含对数据文件和其他目录的命名引用。这些目录形成一棵树，从称为root的特殊目录开始。不以 &#x2F; 开头的路径是相对于调用进程的当前目录进行评估的（相对路径），该目录可以通过 <code>chdir</code> 系统调用进行更改。这两个代码片段都打开同一个文件（假设所有涉及的目录都存在)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">chdir(<span class="hljs-string">&quot;/a&quot;</span>);<br>chdir(<span class="hljs-string">&quot;b&quot;</span>);<br>open(<span class="hljs-string">&quot;c&quot;</span>, O_RDONLY);<br>open(<span class="hljs-string">&quot;/a/b/c&quot;</span>, O_RDONLY);<br><span class="hljs-comment">//第一个片段将进程的当前目录更改为/a/b； 第二个既不引用也不更改进程的当前目录。</span><br></code></pre></td></tr></table></figure><p>有创建新文件和目录的系统调用：<code>mkdir</code> 创建新目录，使用 <code>O_CREATE</code> 标志打开创建新数据文件，<code>mknod</code> 创建新设备文件。 这个例子说明了所有三个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">mkdir(<span class="hljs-string">&quot;/dir&quot;</span>);<br>fd = open(<span class="hljs-string">&quot;/dir/file&quot;</span>, O_CREATE|O_WRONLY);<br>close(fd);<br>mknod(<span class="hljs-string">&quot;/console&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p><code>mknod</code> 创建一个引用设备的特殊文件,与设备文件相关联的是主设备号（major device）和次设备号(minor device),通过这两个参数唯一的确定这个设备，<code>mknod</code> 的两个参数，它们唯一地标识内核设备。当进程稍后打开设备文件时，内核将read和write系统调用转移到这个内核设备上，而不是将它们传递给文件系统。</p><p>文件名与文件本身不同； 同一个底层文件，称为索引节点（<code>inode</code>），可以有多个名称，称为links。每个link都包含目录中的一个条目； 该条目包含一个文件名称和对 <code>inode</code> 的引用。<code>inode</code> 保存有关文件的元数据，包括其类型（文件或目录或设备）、长度、文件内容在磁盘上的位置以及文件的链接数。</p><p><code>int fstat(int fd, struct stat *st)</code> ：系统调用从文件描述符<strong>fd</strong>引用的 <code>inode</code> 检索信息，将<code>inode</code>中的相关信息存储到<strong>st</strong>中。执行成功返回0， 失败返回-1。在 stat.h (kernel&#x2F;stat.h) 中定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span>  T_DIR 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> T_FILE 2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> T_DEVICE 3</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span>&#123;</span><br>    <span class="hljs-type">int</span> dev; <span class="hljs-comment">//file system&#x27;s disk device</span><br>    uint ino; <span class="hljs-comment">//inode number</span><br>    <span class="hljs-type">short</span> type; <span class="hljs-comment">//type of file</span><br>    <span class="hljs-type">short</span> nlink; <span class="hljs-comment">// number of links to file</span><br>    uint64 size; <span class="hljs-comment">//size of file in bytes</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>link</code>:系统调用，创建一个指向同一个<code>inode</code>的文件名。<code>unlink</code>则是将一个文件名从文件系统中移除，只有当指向这个<code>inode</code>的文件名的数量为0时，这个<code>inode</code>以及其存储的文件内容才会被从硬盘上移除。 此片段创建一个名为 a 和 b 的新文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">open(<span class="hljs-string">&quot;a&quot;</span>, O_CREATE|O_WRONLY);<br>link(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>);<br></code></pre></td></tr></table></figure><p>从 a 读取或写入 a 与从 b 读取或写入相同。每个 <code>inode</code> 都由唯一的 <code>inode</code> 编号标识。在上面的代码执行之后，可以通过检查 fstat 的结果来确定 a 和 b 引用相同的底层内容：两者都将返回相同的 <code>inode</code> 号（ino），并且 nlink 计数将设置为 2。<code>unlink</code> 系统调用从文件系统中删除一个名称。 只有当文件的链接计数为零并且没有文件描述符引用它时，文件的索引节点和保存其内容的磁盘空间才会被释放。 从而添加 <code>unlink(&quot;a&quot;)；</code>到最后一个代码序列使 <code>inode</code> 和文件内容可访问为 b。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">fd = open(<span class="hljs-string">&quot;/tmp/xyz&quot;</span>, O_CREATE|O_RDWR);<br>unlink(<span class="hljs-string">&quot;/tmp/xyz&quot;</span>);<br></code></pre></td></tr></table></figure><p>以上代码是创建一个没有名称的临时 <code>inode</code> 的惯用方法，当进程关闭 fd 或退出时将被清理。</p><p>Unix 提供可从 shell 调用的文件实用程序作为用户级程序，例如 <code>mkdir</code>、<code>ln</code> 和 <code>rm</code>等。这种设计允许任何人通过添加新的用户级程序来扩展命令行界面。事后看来，这个计划似乎很明显，但在 Unix 时代设计的其他系统通常将此类命令内置到 shell 中（并将 shell 内置到内核中）。一个例外是 cd，它内置于 shell (user&#x2F;sh.c:160) 中。 cd 必须更改 shell 本身的当前工作目录。 如果 cd 作为常规命令运行，则 shell 将派生一个子进程，子进程将运行 cd，而 cd 将更改子进程的工作目录。 父级（即 shell 的）工作目录不会改变。</p><p>1.5 Real world</p><p>Unix 将“标准”文件描述符、管道和用于操作它们的方便的 shell 语法相结合，这是编写通用可重用程序的重大进步。 这个想法引发了一场 “软件工具”文化,也是 Unix 强大和流行的主要原因，而 shell 是第一个所谓的“脚本语言”。 Unix 系统调用接口今天在 BSD、Linux 和 macOS 等系统中仍然存在。Unix 系统调用接口已通过可移植操作系统接口 (POSIX) 标准进行了标准化。xv6 不符合 POSIX：它缺少许多系统调用（包括基本的系统调用，例如 <code>lseek</code>），并且它提供的许多系统调用与标准不同。 xv6 的主要目标是简单明了，同时提供简单的类 UNIX 系统调用接口。 为了运行基本的 Unix 程序，一些人用更多的系统调用和一个简单的 C 库扩展了 xv6。然而，与 xv6 相比，现代内核提供了更多的系统调用和更多种类的内核服务。 例如，它们支持网络、窗口系统、用户级线程、许多设备的驱动程序等等。 现代内核不断快速发展，并提供许多超越 POSIX 的功能。</p><p>Unix 使用一组文件名和文件描述符接口统一访问多种类型的资源（文件、目录和设备）。 这个想法可以扩展到更多种类的资源；一个很好的例子是Plan 9，它将“资源是文件”的概念应用于网络、图形等。然而，大多数 Unix 派生的操作系统并没有遵循这条路线。</p><p>文件系统和文件描述符是强大的抽象。 即便如此，还有其他操作系统接口模型。 Multics 是 Unix 的前身，它以一种使文件存储看起来像内存的方式抽象了文件存储，从而产生了一种截然不同的界面风格。 Multics 设计的复杂性直接影响了 Unix 的设计者，他们试图构建更简单的东西。</p><p>Xv6 不提供用户或保护一个用户免受另一个用户侵害的概念； 在 Unix 术语中，所有 xv6 进程都以 root 身份运行。</p><p>1.6 Exercises</p><p>“乒乓”：创建两个进程在管道的两端，父进程发送字节到子进程，子进程接收到字节打印自己的pid和recevied ping，然后通过管道写字节到父进程，父进程接收到后打印pid和recevied pong然后退出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#includeuser/user .h<span class="hljs-string">&quot;</span></span><br><span class="hljs-string"><span class="hljs-meta">const int MESSAGE_SIZE = 7;</span></span><br><span class="hljs-string"><span class="hljs-meta">int main(int argc, char *argv[])&#123;</span></span><br><span class="hljs-string"><span class="hljs-meta">    int fd[2];</span></span><br><span class="hljs-string"><span class="hljs-meta">    char buf[MESSAGE_SIZE];</span></span><br><span class="hljs-string"><span class="hljs-meta">    pipe(fd);</span></span><br><span class="hljs-string"><span class="hljs-meta">    int pid = fork();</span></span><br><span class="hljs-string"><span class="hljs-meta">    if(pid &gt; 0)&#123;</span></span><br><span class="hljs-string"><span class="hljs-meta">        write(fd[1], &quot;</span>114514<span class="hljs-string">&quot;, 6);</span></span><br><span class="hljs-string"><span class="hljs-meta">        read(fd[0], buf, 6);</span></span><br><span class="hljs-string"><span class="hljs-meta">        printf(&quot;</span>%d: received pong\n<span class="hljs-string">&quot;, getpid());</span></span><br><span class="hljs-string"><span class="hljs-meta">        exit(0);</span></span><br><span class="hljs-string"><span class="hljs-meta">    &#125;else&#123;</span></span><br><span class="hljs-string"><span class="hljs-meta">        read(fd[0], buf, 6);</span></span><br><span class="hljs-string"><span class="hljs-meta">        printf(&quot;</span>%d: received ping\n<span class="hljs-string">&quot;, getpid());</span></span><br><span class="hljs-string"><span class="hljs-meta">        write(fd[1], &quot;</span>114514<span class="hljs-string">&quot;, 6);</span></span><br><span class="hljs-string"><span class="hljs-meta">        exit(0);</span></span><br><span class="hljs-string"><span class="hljs-meta">    &#125;</span></span><br><span class="hljs-string"><span class="hljs-meta">&#125;</span></span><br></code></pre></td></tr></table></figure><p>素数筛法：使用pipe和fork实现流水线，将一组数范围为2到35喂入到一个进程中，先打印出最小的一个数，这个数是素数，之后用其他的数来除这个素数，如果可以整除则将其drop，不能整除的喂入到下一个进程，直到打印出所有的素数。</p><p>实现find：使用递归的方式找到指定的文件夹下的目标文件，参考user&#x2F;ls.c实现方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// hints:1.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> &#123;</span><br>    ushort inum;<br>    <span class="hljs-type">char</span> name[DIRSIZE];<br>&#125;<br><span class="hljs-comment">//hints:2.</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">memmove</span><span class="hljs-params">(<span class="hljs-type">void</span> *str1, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *str2, <span class="hljs-type">size_t</span> n)</span>;<span class="hljs-comment">//从str2复制n个字符到str1，返回一个指向目标存储区str1的指针。</span><br></code></pre></td></tr></table></figure><p>实现xargs：</p><p><code>xargs</code>的作用是把stdin中的数据用空格或回车分割成命令行参数</p><p>例：<code>find .-name &#39;*.py&#39; | xargs cat | wc -l</code> :统计当前目录下所有python文件的总行数</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
