<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MIT6.S081-chapter3</title>
    <link href="/2023/03/14/MIT6-S081-chapter3/"/>
    <url>/2023/03/14/MIT6-S081-chapter3/</url>
    
    <content type="html"><![CDATA[<ul><li>MIT6.S081</li><li>xv6</li><li>C</li></ul><hr><p>三、 page tables</p><p>​操作系统通过<code>page table</code>为每个进程提供自己的私有地址空间和内存，从而实现内存隔离。页表决定了内存地址空间的含义，以及可以访问物理内存的哪些部分。它们允许xv6隔离不同进程的地址空间并将它们多路复用到单个物理内存中。页表是一种流行的设计，因为它们提供了一种允许操作系统执行一些小trick的执行方式。xv6执行一些技巧，在多个地址空间中映射相同的内存(trampoline page)，并使用未映射的页面保护内核和用户堆栈。</p><p>3.1 paging hardware</p><p>作为提醒，RISC-V 指令（用户和内核）操作虚拟地址。 机器的 RAM 或物理内存是用物理地址索引的。 RISC-V 页表硬件通过将每个虚拟地址映射到物理地址来连接这两种地址。</p><p>​xv6 运行在 Sv39 RISC-V 上，这意味着只使用 64 位虚拟地址的低 39 位； 前 25 位未使用。在这个Sv39配置中，RISC-V页表在逻辑上是一个包含$2^{27}$（134217728）个页表条目（PTE）的数组。每个PTE包含一个44bit的物理页码（PPN）和一些标志位（Flags）。分页硬件使用前27位转换虚拟地址，将39位中的bit索引到页表中找到一个PTE，并制作一个56位的物理地址，其高44位来自PTE中的PPN，低12位是从PTE中复制的原始虚拟地址。图 3.1 将页表的逻辑视图显示为一个简单的 PTE 数组（有关更完整的故事，请参见图 3.2）。 页表使操作系统能够以 4096 ($2^{12}$) 字节的对齐块的粒度对虚拟地址到物理地址的转换进行控制。 这样的块称为 <em>page</em>。</p><img src="/2023/03/14/MIT6-S081-chapter3/riscv-pagetable.png" class="" title="架构图"><p>​在 Sv39 RISC-V 中，虚拟地址的前 25 位不用于转换。 物理地址也有增长的空间：PTE 格式中有空间让物理页号再增长 10 位。 RISC-V 的设计者根据技术预测选择了这些数字。$2^{39}$字节是512GB，对于在RISC-V计算机上运行的应用程序来说，这应该是足够的地址空间。256足以在不久的将来容纳可能的I&#x2F;O设备和DRAM芯片的物理内存空间。如果需要更多，RISC-V设计者已经定义了具有48位虚拟地址的Sv48。</p><p>​如图 3.2 所示，RISC-V CPU 通过三个步骤将虚拟地址转换为物理地址。 页表以三级树的形式存储在物理内存中。 树的根是一个 4096 字节的页表页，包含 512 个 PTE，其中包含树的下一级页表页的物理地址。 这些页面中的每一页都包含树中最后一层的 512 个 PTE。分页硬件使用 27 位中的高 9 位选择根页表页中的 PTE，中间 9 位选择树的下一级页表页中的 PTE，低 9 位 位来选择最终的 PTE。 （在 Sv48 RISC-V 中，页表有四层，虚拟地址索引的第 39 位到第 47 位进入顶层。）</p><img src="/2023/03/14/MIT6-S081-chapter3/riscv_address.png" class="" title="架构图"><p>如果转换地址所需的三个 PTE 中的任何一个不存在，分页硬件将引发页面错误异常，将其留给内核来处理异常。</p><p>​与图 3.1 的单层设计相比，图 3.2 的三层结构允许采用内存高效的方式来记录 PTE。 在大范围虚拟地址没有映射的常见情况下，三级结构可以省略整个页目录。 例如，如果应用程序只使用从地址 0 开始的几个页面，那么顶级页面目录的条目 1 到 511 是无效的，内核不必为 511 中间页面目录分配页面。 此外，内核也不必为那些 511 中间页目录为底层页目录分配页面。 因此，在本例中，三级设计为中间页目录节省了 511 页，为底层页目录节省了 511 × 512 页。</p><p>​尽管CPU在硬件中遍历三级结构作为执行加载或存储指令的一部分，但三级的潜在缺点是CPU必须从内存中加载三个PTE以执行加载&#x2F;存储中的虚拟地址转换一个物理地址的指令。<em>为了避免从物理内存加载PTE的成本，RISC-V CPU的缓存页表条目缓存在转换后备缓冲区（<strong>TLB</strong>）中。</em></p><p>​每个 PTE 都包含标志位，告诉分页硬件如何允许使用关联的虚拟地址。 PTE_V 指示 PTE 是否存在：如果未设置，则对页面的引用会导致异常（即不允许）。 PTE_R 控制是否允许指令读取页面。 PTE_W 控制是否允许指令写入页面。 PTE_X 控制 CPU 是否可以将页面内容解释为指令并执行它们。 PTE_U 控制是否允许用户态指令访问页面； 如果未设置 PTE_U，则 PTE 只能在管理员模式下使用。 图 3.2 展示了它是如何工作的。 标志和所有其他页面硬件相关结构在 (kernel&#x2F;riscv.h) 中定义</p><p>​需要告诉硬件使用页表，内核必须将页表的物理地址写入<code>satp</code>寄存器。每个CPU都有自己的<code>stap</code>。CPU将使用自己的<code>satp</code>指向的页表来翻译后续指令生成的所有地址。每个CPU都有自己的satp，这样不同的CPU可以运行不同的进程，每个进程都有自己的页表描述的私有地址空间。</p><p>​通常，内核将所有物理内存映射到其页表中，以便它可以使用加载&#x2F;存储指令读取和写入物理内存中的任何位置。 由于页目录在物理内存中，内核可以通过使用标准存储指令写入 PTE 的虚拟地址来在页目录中编程 PTE 的内容。</p><p>​关于术语的一些注释。 <strong>物理内存是指 DRAM 中的存储单元</strong>。 一个字节的物理内存有一个地址，称为物理地址。 指令只使用虚拟地址，分页硬件将其转换为物理地址，然后发送到 DRAM 硬件以读取或写入存储。 与物理内存和虚拟地址不同，虚拟内存不是物理对象，而是指内核提供的用于管理物理内存和虚拟地址的抽象和机制的集合。</p><img src="/2023/03/14/MIT6-S081-chapter3/riscv_physical_address.png" class="" title="架构图"><p>3.2 kernel address space</p><p>​xv6 为每个进程维护一个页表，用于描述每个进程的用户地址空间，以及一个描述内核地址空间的页表（所有进程共享这个描述内核地址空间的页表）。 内核配置其地址空间布局，使其能够访问可预测虚拟地址处的物理内存和各种硬件资源。 图 3.3 显示了此布局如何将内核虚拟地址映射到物理地址。 文件 (kernel&#x2F;memlayout.h) 声明了 xv6 内核内存布局的常量。</p><p>​QEMU模拟一台包含RAM的计算机，从物理地址0x80000000开始并持续到至少0x86400000，xv6称之为<code>PHYSTOP</code>。QEMU 模拟器还包括 I&#x2F;O 设备，例如磁盘接口。 QEMU 将设备接口暴露给软件作为内存映射控制寄存器，位于 0x80000000 以下物理地址空间。 内核可以通过读&#x2F;写这些特殊的物理地址来与设备进行交互； kernel对这些设备接口控制寄存器的访问是直接和这些设备交互而不是RAM进行交互的。</p><p>内核使用“直接映射”获取RAM和内存映射设备寄存器，将资源映射到与物理地址相同的虚拟地址。例如，内核本身在虚拟地址空间和物理内存中都位于KERNBASE&#x3D;0x80000000。直接映射简化了读取&#x2F;写入物理内存的内核代码。例如<code>fork</code>为子进程分配用户内存时，allocator返回该内存的物理地址； <code>fork</code> 在将父进程的用户内存复制到子进程时，直接使用该地址作为虚拟地址。</p><p>​有几个内核虚拟地址不是直接映射的：</p><ul><li>trampoline: （和user pagetable在同一个虚拟地址，以便在user space和kernel space之间跳转时切换进程仍然能够使用相同的映射，真实的物理地址位于kernel 文本中的<code>trampoline.S</code>）。</li><li>内核堆栈页面（kernel stack page）。 每个进程都有自己的内核栈，它被映射到高位，这样 xv6 可以在它下面留下一个未映射的保护页。 guard page的PTE是无效的（即没有设置PTE_V），所以如果内核溢出了内核栈，很可能会引发异常，内核会panic。 如果没有保护页，溢出的堆栈会覆盖其他内核内存，从而导致不正确的操作。</li><li>trampoline和trapframe由操作系统分配，用户进程无权访问</li></ul><p>​虽然内核通过高端内存映射使用其堆栈，但内核也可以通过直接映射地址访问它们。 另一种设计可能只有直接映射，并在直接映射地址处使用堆栈。 然而，在这种安排中，提供保护页将涉及取消映射虚拟地址，否则这些虚拟地址将引用物理内存，这将很难使用。</p><p>​内核使用 PTE_R 和 PTE_X 权限映射 trampoline 和内核文本的页面。 kernel从这些页面读取并执行指令。 kernel用PTE_R 和PTE_W 权限映射其他页面，以便它可以读写这些页面中的内存。 防止页的映射无效。</p><p>3.3 creating an address space</p><p>​大多数用于操作地址空间和页表的 xv6 代码都驻留在 vm.c (kernel&#x2F;vm.c:1) 中。 主要数据结构体是 <code>pagetable_t</code>，它实际上是一个指向 RISC-V 根页表页的指针； <code>pagetable_t</code> 可以是内核页表，也可以是每个进程页表之一。 核心功能是 <code>walk</code> 和 <code>mappages</code>，<code>walk</code>给定一个虚拟地址和一个页表返回一个PTE，后者给定一个页表、一个虚拟地址和物理地址，创建一个PTE以实现相应的映射。 以<code>kvm</code>开头的函数操作内核页表； 以 <code>uvm</code> 开头的函数操作用户页表； 其他功能用于两者。 <code>copyout</code> 和 <code>copyin</code> 从作为系统调用参数提供的用户虚拟地址复制数据； 它们在 vm.c 中，因为它们需要显式转换这些地址才能找到相应的物理内存。</p><p>​在引导序列的早期，main 调用 <code>kvminit</code> 以使用 <code>kvmmake</code> 创建内核的页表。 这个调用发生在 xv6 在 RISC-V 上启用分页之前，所以地址直接指向物理内存。 <code>kvmmake</code> 首先分配一个物理内存页来保存根页表页。 然后它调用 <code>kvmmap</code> 来安装内核需要的翻译。 翻译包括内核的指令和数据、直到 PHYSTOP 的物理内存，以及实际上是设备的内存范围。 <code>proc_mapstacks</code>为每个进程分配一个内核堆栈。 它调用 <code>kvmmap</code> 将每个堆栈映射到 KSTACK 生成的虚拟地址，这为无效的堆栈保护页面留出了空间。</p><p>​<code>kvmmap</code>调用 <code>mappages</code> ，它将映射安装到页表中，用于将一系列虚拟地址映射到相应的物理地址范围。 它以页面间隔为范围内的每个虚拟地址单独执行此操作。 对于每个要映射的虚拟地址，<code>mappages</code> 调用 <code>walk</code> 来查找该地址的 PTE 地址。 然后它初始化 PTE 以保存相关的物理页码、所需的权限（PTE_W、PTE_X 和&#x2F;或 PTE_R）和 PTE_V 以将 PTE 标记。</p><p>​<code>walk</code>  模仿 RISC-V 分页硬件，因为它在 PTE 中查找虚拟地址（见图 3.2）。 <code>walk</code>当时将3级页表向下9位。 它使用每一级的 9 位虚拟地址来查找下一级页表或最终页面的 PTE。 如果 PTE 无效，则所需页面尚未分配； 如果设置了 alloc 参数，walk 会分配一个新的页表页并将其物理地址放入 PTE 中。 它返回树中最低层的 PTE 地址。</p><p>​上面的代码依赖于物理内存被直接映射到内核虚拟地址空间。 例如，当遍历页表的下层时，它从 PTE中提取下一层页表的（物理）地址，然后将该地址用作虚拟地址 获取下一级的 PTE。</p><p>​main 调用 <code>kvminithart</code>安装内核页表。 它将根页表页的物理地址写入寄存器 <code>satp</code>。 此后，CPU 将使用内核页表转换地址。 由于内核使用恒等映射，下一条指令的当前虚拟地址将映射到正确的物理内存地址。</p><p>​每个RISC-V CPU都将页表条目缓存在转换后备缓冲区（TLB）中，当xv6更改页表时，它必须告诉CPU使相应缓存的TLB条目失效。如果没有这个操作，那么在稍后的某个时候，TLB可能会使用旧的缓存映射，指向同时已分配给另一个进程的物理页面，结果会导致一个进程可能会在某些页面上更改其他进程的内存。RISC-V有一个刷新当前CPU的TLB的指令：<code>sfence.vma</code>。xv6在重新加载satp寄存器后在<code>kvminithart</code>中执行<code>sfence.vma</code>，并在返回用户空间之前切换到用户页表的<code>trampoline</code>中执行<code>sfence.vma</code>。</p><p>​为避免刷新整个 TLB，RISC-V CPU 可能支持地址空间标识符 (ASID)。 然后内核可以只刷新特定地址空间的 TLB 条目。</p><p>3.4 Physical memory allocation</p><p>​内核必须在运行时为页表、用户内存、内核堆栈和管道缓冲区分配和释放物理内存。<br>​xv6 使用内核末尾和 PHYSTOP 之间的物理内存进行运行时分配。 它一次分配和释放以 4096 字节（为单位）的页面。 它通过将链接列表穿过页面本身来跟踪哪些页面是空闲的。 分配：从链表中删除一个页面； 释放：将页面添加到链表中。</p><p>3.5 code : Physical memory allocator</p><p>​分配器位于kalloc.c中，分配器的数据结构使可用于分配的物理内存页的空闲列表。每个免费页面的列表元素是一个可用于分配的结构。分配器从哪里获得内存来保存该数据结构？它将每个空闲页面的运行结构存储在空闲页面本身之中因为没有其他存储。 空闲列表由自旋锁 (kernel&#x2F;kalloc.c:21-24) 保护。 列表和锁被包装在一个结构中，以明确锁保护结构中的字段。</p><p>​函数 main 调用 <code>kinit</code> 来初始化分配器 (kernel&#x2F;kalloc.c:27)。 <code>kinit</code> 初始化空闲列表以保存内核末尾和 PHYSTOP 之间的每个页面。 xv6 应该通过解析硬件提供的配置信息来确定有多少物理内存可用。 相反，xv6 假定机器有 128 兆字节的 RAM。 kinit 调用 <code>freerange(end, PHYSTOP)</code> 通过每页调用 <code>kfree</code> 将内存添加到空闲列表。 PTE 只能引用在 4096 字节边界（是 4096 的倍数）上对齐的物理地址，因此 <code>freerange</code> 使用 PGROUNDUP 来确保它只释放对齐的物理地址。 分配器开始时没有内存； 这些对 <code>kfree</code> 的调用给它一些管理。</p><p>​分配器有时将地址视为整数以便对其执行算术运算（例如，遍历自由范围内的所有页面），有时将地址用作读写内存的指针（例如，操纵存储在每个页面中的运行结构）； 这种地址的双重使用是分配器代码充满 C 类型转换的主要原因。 另一个原因是释放和分配本质上改变了内存的类型。</p><p>​函数 <code>kfree</code> (kernel&#x2F;kalloc.c:47) 首先将要释放的内存中的每个字节设置为值 1。这将导致在释放内存后使用内存的代码（使用“悬挂引用”）读取垃圾而不是 旧的有效内容； 这会导致此类代码更快地崩溃。 然后 <code>kfree</code> 将页面添加到空闲列表：它将 pa 转换为指向 struct run 的指针，在 <code>r-&gt;next</code> 中记录空闲列表的旧开始，并将空闲列表设置为等于 r。 <code>kalloc</code> 删除并返回空闲列表中的第一个元素。</p><img src="/2023/03/14/MIT6-S081-chapter3/process.png" class="" title="架构图"><p>3.6 Process address space</p><p>​每个进程都有一个单独的页表，xv6 在进程之间切换时，也会改变页表。 如图 2.3 所示，一个进程的用户内存从虚拟地址 0 开始，并且可以增加到 MAXVA (kernel&#x2F;riscv.h:360)，原则上允许一个进程处理 256 GB 的内存。</p><p>​当进程向 xv6 请求更多用户内存时，xv6 首先使用 <code>kalloc</code> 分配物理页面。 然后它将 PTE 添加到指向新物理页面的进程页表中。 xv6 在这些 PTE 中设置 PTE_W、PTE_X、PTE_R、PTE_U 和 PTE_V 标志。 大多数进程不使用整个用户地址空间； xv6 在未使用的 PTE 中清除 PTE_V标注位。</p><p>​我们在这里看到了一些使用页表的很好的例子。 首先，不同进程的页表将用户地址翻译成不同的物理内存页，从而使每个进程拥有私有的用户内存。 其次，每个进程都将其内存视为具有从零开始的连续虚拟地址，而进程的物理内存可以是不连续的。 第三，内核在用户地址空间的顶部映射一个带有蹦床代码的页面，因此物理内存的单个页面出现在所有地址空间中。</p><p>​图 3.4 更详细地显示了 xv6 中执行进程的用户内存布局。 堆栈是单页的，显示的是 <code>exec</code> 创建的初始内容。 包含命令行参数的字符串以及指向它们的指针数组位于堆栈的最顶部。 紧接着是允许程序从 main 开始的值，就好像函数 main(argc, argv) 刚刚被调用一样。</p><p>​为了检测用户堆栈溢出分配的堆栈内存，xv6 通过清除 PTE_U 标志在堆栈正下方放置一个不可访问的保护页。 如果用户堆栈溢出并且进程试图使用堆栈下方的地址，则硬件将生成页面错误异常，因为在用户模式下运行的程序无法访问保护页面。 当用户堆栈溢出时，真实世界的操作系统可能会自动为用户堆栈分配更多内存。</p><p>3.7 code: sbrk</p><p>​<code>sbrk</code> 是进程缩小或增加其内存空间的系统调用。 系统调用由函数 <code>growproc</code> (kernel&#x2F;proc.c:253) 实现。 <code>growproc</code> 调用 <code>uvmalloc</code> 或 <code>uvmdealloc</code>，这取决于 n 是正数还是负数。 <code>uvmalloc</code> (kernel&#x2F;vm.c:221) 用<code>kalloc</code>分配物理内存，用<code>mappages</code>给用户页表添加PTE。 <code>uvmdealloc</code> 调用 <code>uvmunmap</code>(kernel&#x2F;vm.c:166)，它使用 <code>walk</code> 查找 PTE 并使用 <code>kfree</code> 释放它们引用的物理内存。</p><p>​xv6 使用进程的页表不仅告诉硬件如何映射用户虚拟地址，而且还作为唯一记录分配给该进程的物理内存页。 这就是为什么释放用户内存（在 uvmunmap 中）需要检查用户页表的原因。</p><p>3.8 code : exec</p><p><code>exec</code> 为以ELF格式定义的文件系统中的可执行文件创建用户空间。 <code>exec</code>先检查头文件中是否有ELF_MAGIC来判断这个文件是否是一个ELF格式定义的二进制文件，用<code>proc_pagetable</code>来为当前进程创建一个还没有映射的页表，然后用<code>uvmalloc</code>来为每个ELF segment分配物理空间并在页表中建立映射，然后用<code>loadseg</code>来把ELF <code>segment</code>加载到物理空间当中。注意<code>uvmalloc</code>分配的物理内存空间可以比文件本身要大。</p><p>接下来<code>exec</code>分配user stack，它仅仅分配一页给stack，通过<code>copyout</code>将传入参数的string放在stack的顶端，在ustack的下方分配一个guard page。</p><p>如果<code>exec</code>检测到错误，将跳转到<code>bad</code>标签，释放新创建的<code>pagetable</code>并返回-1。<code>exec</code>必须确定新的执行能够成功才会释放进程旧的页表(<code>proc_freepagetable(oldpagetable, oldsz)</code>)，否则如果system call不成功，就无法向旧的页表返回-1。</p><p>​exec使用<code>proc_pagetable</code>(kernel&#x2F;exec.c)分配一个没有用户映射的新页面，使用<code>uvmalloc</code>为每个ELF段分配内存，并加载每个段使用<code>loadseg</code>进入内存。<code>loadseg</code>使用<code>walladdr</code>找到分配内存的物理地址，在该地址写入ELF段的每个页面。并使用<code>readi</code>从文件中读取。</p><p><code>/init</code> 的程序节标题是用 exec 创建的第一个用户程序，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># objdump -p _init<br>user/_init: file format elf64-littleriscv<br><br>Program Header:<br>LOAD off 0x00000000000000b0 vaddr 0x0000000000000000<br>paddr 0x0000000000000000 align 2**3<br>filesz 0x0000000000000840 memsz 0x0000000000000858 flags rwx<br>STACK off 0x0000000000000000 vaddr 0x0000000000000000<br>paddr 0x0000000000000000 align 2**4<br>filesz 0x0000000000000000 memsz 0x0000000000000000 flags rw<br></code></pre></td></tr></table></figure><p>​程序节头的 filesz 可能小于 memsz，表明它们之间的间隙应该用零填充（对于 C 全局变量）而不是从文件中读取。对于 &#x2F;init，filesz 是 2112 字节，memsz 是 2136 字节，因此 uvmalloc 分配了足够的物理内存来容纳 2136 字节，但从文件 &#x2F;init 中只读取了 2112 字节。</p><p>​现在exec分配并初始化用户堆栈。它只分配一个堆栈页。exec一次将一个参数字符复制到栈顶，将指向它们的指针记录在ustack中。它在传递给main的argv列表的末尾放置一个空指针。ustack中的前三个条目是假的返回程序计数器、argc、和argv指针。</p><p>​exec将一个不可访问的页面放在堆栈页面的正下方，这样试图使用多个页面的程序就会出错。这个无法访问的页面还允许exec处理参数； 在这种情况下，exec 用于将参数复制到堆栈的 <code>copyout</code> (kernel&#x2F;vm.c:347) 函数将注意到目标页面不可访问，并将返回 -1。</p><p>​在准备新内存映像期间，如果 exec 检测到错误，如无效程序段，它会跳转到 <code>bad</code>标签，释放新映像，并返回 -1。 exec 必须等待释放旧映像，直到确定系统调用会成功：如果旧映像消失，系统调用不能返回 -1 给它。 exec 中唯一的错误情况发生在创建映像期间。 映像完成后，exec 可以提交到新页面(kernel&#x2F;exec.c:113) 并释放旧页表 (kernel&#x2F;exec.c:117)。</p><p>​exec 将 ELF 文件中的字节加载到内存中由 ELF 文件指定的地址。用户或进程可以将他们想要的任何地址放入 ELF 文件中。 因此 exec 是有风险的，因为 ELF 文件中的地址可能无意或有意地引用内核。粗心的内核导致的后果可能从崩溃到恶意破坏内核的隔离机制（即安全漏洞）。Xv6 执行大量检查以避免这些风险。 例如 if(ph.vaddr + ph.memsz &lt; ph.vaddr) 检查总和是否溢出 64 位整数。危险在于用户可以构造一个 ELF 二进制文件，其中 ph.vaddr 指向用户选择的地址，ph.memsz 足够大以至于总和溢出到 0x1000，这看起来像是一个有效值。在旧版本的 xv6 中，用户地址空间也包含内核（但在用户模式下不可读&#x2F;写），用户可以选择与内核内存相对应的地址，从而将数据从 ELF 二进制文件复制到内核中 。在 xv6 的 RISC-V 版本中，这种情况不会发生，因为内核有自己独立的页表； loadseg 加载到进程的页表中，而不是内核的页表中。</p><p>​内核开发人员很容易忽略关键检查，而现实世界的内核长期以来一直缺少检查，用户程序可以利用这些检查来获取内核特权。 xv6 很可能没有完成验证提供给内核的用户级数据的完整工作，恶意用户程序可能会利用它来绕过 xv6 的隔离。</p><p>3.9 real world</p><p>​与大多数操作系统一样，xv6使用分页硬件进行内存保护和映射。大多数操作系统通过结合分页和页面错误异常，比 xv6 更复杂地使用分页。</p><p>​xv6 通过内核使用虚拟地址和物理地址之间的直接映射进行了简化，并假设在地址 0x8000000 处存在物理 RAM，内核希望将其加载。 这适用于 QEMU，但在真正的硬件上它被证明是一个不好的idea； 真实硬件将 RAM 和设备放置在不可预测的物理地址，因此（例如）在 0x8000000 处可能没有 RAM，而 xv6 期望能够在此处存储内核。 更严谨的内核设计利用页表将任意硬件物理内存布局转换为可预测的内核虚拟地址布局。RISC-V 支持物理地址级别的保护，但 xv6 不使用该功能。 在具有大量内存的机器上，使用 RISC-V 对“超级页面”的支持可能是有意义的。 当物理内存较小时，小页面是有意义的，以允许以细粒度分配和页面出到磁盘。 例如，如果一个程序只使用 8 KB 的内存，那么给它一个完整的 4 MB 物理内存超级页面是一种浪费。 较大的页面在具有大量 RAM 的机器上有意义，并且可以减少页表操作的开销。xv6 内核缺少可以为小对象提供内存的类似 malloc 的分配器，这阻止了内核使用需要动态分配的复杂数据结构。</p><p>​内存分配是一个常年的热门话题，基本问题是如何有效的利用有限的内存和为未知的未来请求做准备。 如今，人们更关心速度而不是空间效率。 此外，更精细的内核可能会分配许多不同大小的小块，而不是（如在 xv6 中）仅分配 4096 字节的块； 一个真正的内核分配器需要处理小分配和大分配。</p><p>3.10 exercises</p><ol><li>解析 RISC-V 的设备树以找到计算机拥有的物理内存量。</li><li>编写一个用户程序，通过调用 sbrk(1) 将其地址空间增加一个字节。 运行程序并在调用 sbrk 之前和调用 sbrk 之后检查程序的页表。 内核分配了多少空间？ 新记忆的PTE包含什么？</li><li>修改 xv6 以使用内核的超级页面。</li><li>修改 xv6，以便当用户程序取消引用空指针时，它将收到异常。 也就是说，修改 xv6，使虚拟地址 0 不映射给用户程序。</li><li>exec 的 Unix 实现传统上包括对 shell 脚本的特殊处理。 如果要执行的文件以文本#! 开头，那么第一行将被视为要运行以解释该文件的程序。 例如，如果调用 exec 运行 myprog arg1 并且 myprog 的第一行是#!&#x2F;interp，那么 exec 运行 &#x2F;interp 命令行 &#x2F;interp myprog arg1。 在 xv6 中实现对这个约定的支持。</li><li>为内核实现地址空间随机化。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MIT6.S081-chapter2</title>
    <link href="/2023/03/08/MIT6-S081-chapter2/"/>
    <url>/2023/03/08/MIT6-S081-chapter2/</url>
    
    <content type="html"><![CDATA[<ul><li>MIT6.S081</li><li>xv6</li><li>C</li></ul><hr><p>二、operating system organization</p><p>2.1 Abatracting physical resources</p><p>​       在这个计划中，每个应用程序甚至可以有自己的库来满足其需求。应用程序可以直接与硬件资源交互，并以最适合应用程序的方式使用这些资源（例如，实现高性能或可预测的性能）。一些嵌入式设备的操作系统或者实时的操作系统就是以这种方式运行。这种库方法的缺点是，如果有多个应用程序在运行，则这些应用程序必须运行良好。例如：每个应用程序必须周期性的放弃对CPU资源的使用以便于其它程序可以调用。如果每个程序都足够相信对方并且没有bug这样的合作的时分复用机制可以很OK的工作。但是没有bug和相信对方是难以实现的，因此一个比这个方案提供更强的隔离方案需要被提出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">*ip += <span class="hljs-number">1</span>;<span class="hljs-comment">//将ip指向的变量加1，相当于 ++*ip, 或（*ip)++。</span><br><span class="hljs-comment">//一元操作符从右向左结合，所以*ip++相当于*(ip++)</span><br><span class="hljs-comment">//指针的大小比较：只有在两个指针指向同一个数组的元素时比较才合法，指针只有相减是合法的</span><br></code></pre></td></tr></table></figure><p>C程序的内存分配方案： 堆（heap）由程序员通过malloc和free控制，地址从低向高增长；栈（stack）编译器自动分配释放，存放函数的参数、局部变量的值，在退出函数后自动销毁释放，地址从高向低增长。</p><p>实现一个强隔离性的方案将资源抽象成服务，对于禁止应用程序直接访问敏感的硬件资源是非常有用的。如unix程序和存储的交互通过文件系统的open、read、write和close系统调用，而不是直接读写磁盘。这为应用程序提供了路径名的便利，并允许操作系统（作为接口的实现者）管理磁盘。即使隔离不是问题，有意交互（或只是希望彼此远离）的程序也可能会发现文件系统是比直接使用磁盘更方便的抽象。</p><p>类似地，Unix 透明地在进程之间切换硬件 CPU，根据需要保存和恢复寄存器状态，因此应用程序不必知道时间共享。 这个透明度允许操作系统共享 CPU，即使某些应用程序处于无限状态循环。<br>​另一个例子是，unix使用exec系统调用来构建自己的内存映像来代替直接和物理内存交互。这允许操作系统来决定在内存的哪里放置一个进程。如果内存紧张，操作系统内甚至可能会将进程的数据存储在磁盘上，exec还提供给用户一个方便的文件系统用来存储可执行的程序映像。<br>​Unix 进程之间的许多形式的交互都是通过文件描述符发生的。 文件描述符不仅抽象出许多细节（例如，管道或文件中数据的存储位置），它们还以简化交互的方式定义。 例如，如果管道中的一个应用程序执行失败，内核会为管道中的下一个进程生成文件结束信号。</p><p>2.2 用户模式、超级模式、和系统调用</p><p>​强隔离的实现需要在程序和系统调用之间有一个坚硬的边界。如果程序出错我们不希望操作系统和其他程序出现差错。而是希望操作系统能够清理这些出错的程序并继续执行其他的程序。为了实现这样的强隔离，操作系统必须安排让应用程序不能修改或读取操作系统的数据，并且应用程序不能访问其他的程序的内存。</p><p>​CPU提供了这样的硬件支持。如RISC-V有三种让CPU执行的模式：machine mode, supervisor mode, user mode。在machine mode拥有最高的执行权力，CPU从该模式启动。用来配置计算机。XV6只在该模式下执行少量的程序然后切换到supevisor mode。</p><p>​在supervisor mode下，CPU允许执行拥有特权的指令，例如：使能&#x2F;失能中断，读写存储有page table的寄存器的值。如果应用程序在user mode想要执行特权的指令，CPU会禁止执行。一个应用程序只有在user mode下执行，如执行++i操作，在用户空间（user space）执行。在superivsor mode下执行的程序我们称之为运行在内核空间（kernel space）。</p><p>一个用户态的程序想要唤醒一个核函数必须先进入到核空间，不能直接唤醒一个核函数。CPU 提供了一条特殊的指令，可以将 CPU 从用户模式（user mode）切换到管理员模式(supervisor mode)，并在内核指定的入口点进入内核（RISC-V提供了<code>ecall</code>指令用来完成这样的任务，<code>ecall</code>指令：跳转到trampoline代码）。一旦CPU切换到supervisor mode，内核就会验证这些系统指令的参数（例如，检查传递给系统调用的地址是否是应用程序内存的一部分）从而决定是否允许应用程序执行请求的操作（例如，检查是否允许应用程序写入指定的文件），然后决定是拒绝它或执行它。内核控制转换到管理模式的入口点很重要； 例如，如果应用程序可以决定内核入口点，则恶意应用程序可以在跳过参数验证的位置进入内核。要想从supervisor mode切换到user mode，调用<code>sret</code>指令。</p><p>2.3 kernel organization</p><p>一个关键的问题是操作系统在管理者模式下该运行什么程序。一种可能是整个操作系统驻留在内核中，因此所有的系统调用的实现都运行在管理者模式。这种模式称为单片内核（monolithic kernel）。在这种形势下，整个操作系统拥有整个的硬件权限。这种组织方式很方便，因为操作系统设计者不必决定操作系统的哪一部分不需要完整的硬件特权。此外，操作系统的不同部分更容易协作。例如，操作系统可能有一个缓冲区缓存，它可以由文件系统和虚拟内存系统共享。这种组织的一个缺点是操作系统不同部分之间的接口通常很复杂，因此操作系统开发人员很容易犯错误。然而在这种模式下，一个错误的发生就会是致命的，因为在supervisor mode下的一个错误往往会导致内核失败，从而导致计算机停止工作。</p><p>​为了降低内核出错的风险，操作系统设计人员可以最大限度地减少在管理员模式下运行的操作系统代码量，并在用户模式下执行大部分操作系统。 这种内核组织称为微内核（micro kernel）。</p><img src="/2023/03/08/MIT6-S081-chapter2/microkernel.png" class="" title="架构图"><p>在图中，文件系统作为用户级进程运行。 作为进程运行的操作系统服务称为服务器。 为了允许应用程序与文件服务器进行交互，内核提供了一种进程间通信机制，可以将消息从一个用户模式进程发送到另一个用户模式进程。例如，如果像 shell 这样的应用程序想要读取或写入文件，它会向文件服务器发送消息并等待响应。在微内核中，内核接口由一些低级函数组成，用于启动应用程序、发送消息、访问设备硬件等。这种组织允许内核相对简单，因为大多数操作系统驻留在用户级服务器中。</p><p>​在现实世界中，单体内核和微内核都很流行。 许多 Unix 内核是单一的。 例如，Linux 有一个单一的内核，尽管一些操作系统功能作为用户级服务器运行（例如，窗口系统）。 Linux 为操作系统密集型应用程序提供高性能，部分原因是内核的子系统可以紧密集成。 Minix、L4 和 QNX 等操作系统被组织为带有服务器的微内核，并且在嵌入式设备中得到了广泛部署。 L4 的变体 seL4 足够小，以至于它已经过内存安全和其他安全属性的验证。操作系统的开发人员之间存在很多争论，认为哪种组织更好，并且没有任何一种方式的确凿证据。 此外，它在很大程度上取决于“更好”的含义：更快的性能、更小的代码大小、内核的可靠性、整个操作系统（包括用户级服务）的可靠性等。还有一些实际考虑可能比哪个组织的问题更重要。 一些操作系统有一个微内核，但出于性能原因，在内核空间中运行一些用户级服务。 一些操作系统具有整体内核，因为它们是这样开始的，并且没有动力转向纯微内核组织，因为新功能可能比重写现有操作系统以适应微内核设计更重要。</p><p>​与大多数 Unix 操作系统一样，Xv6 是作为一个整体内核实现的。 这样，xv6内核接口对应操作系统接口，内核实现了完整的操作系统。 由于 xv6 不提供很多服务，它的内核比一些微内核更小，但概念上 xv6 是整体的。</p><p>2.4 XV6 organization</p><img src="/2023/03/08/MIT6-S081-chapter2/organization.png" class="" title="架构图"><p>trampoline.S(汇编代码)</p><ul><li><p>对ecall瞬间的状态做快照</p><ul><li>填充struct trapframe (proc.h)</li><li>利用$sscratch(S-mode scratch) 保存所有寄存器</li><li>切换到内核栈（相当于切换到进程对应的“内核线程”）</li><li>切换到内核地址空间</li><li>跳转到tf-&gt;kernel_trap</li></ul><p>2.5 Process overview</p><p>xv6（和其他 Unix 操作系统一样）中的隔离单元是一个进程。进程抽象防止一个进程破坏或监视另一个进程的内存、CPU、文件描述符等。它还可以防止进程破坏内核本身，这样进程就无法破坏内核的隔离机制。内核必须小心地实现进程抽象，因为错误或恶意应用程序可能会诱使内核或硬件做一些坏事（例如，规避隔离）。内核用于实现进程的机制包括用户&#x2F;管理员模式标志、地址空间和线程的时间片。</p><p>​为了帮助加强隔离，进程抽象为程序提供了它拥有自己的私有机器的错觉。一个进程为程序提供了一个看似私有的内存系统或地址空间，其他进程无法读取或写入。 一个进程还为程序提供似乎是它自己的 CPU 来执行程序的指令。</p><p>​xv6 使用<code>page table</code>（由硬件实现）为每个进程提供自己的地址空间。 RISC-V 页表将虚拟地址（RISC-V 指令操作的地址）转换（或“映射”）为物理地址（CPU 芯片发送到主内存的地址）。</p><p>​xv6 为每个定义进程地址空间的进程维护一个单独的页表。 如图 2.3 所示，地址空间包括从虚拟地址零开始的进程的用户内存。首先是指令，然后是全局变量，然后是堆栈，最后是进程可以根据需要扩展的“堆”区域（用于 malloc）。 有许多因素会限制进程地址空间的最大大小：RISC-V 上的指针是 64 位宽； 硬件在页表中查找虚拟地址时只使用低 39 位； 而 xv6 只使用了这 39 位中的 38 位。因此，最大地址为 $2^{38}$ − 1 &#x3D; 0x3fffffffff，即MAXVA。在地址空间的顶部，xv6 保留了一个页面用于 trampoline 和一个映射进程的 trapframe 的页面。xv6 使用这两个页面来回转换到内核； trampoline 页面包含进出内核的代码，映射 trapframe 是保存&#x2F;恢复用户进程状态所必需的.</p><p>​xv6 内核为每个进程维护许多状态，并将其收集到一个 struct proc 中。进程最重要的内核状态部分是它的页表、内核堆栈和运行状态。 我们将使用符号 p-&gt;xxx 来指代 proc 结构的元素； 例如，p-&gt;pagetable 是指向进程页表的指针，p-&gt;kstack是指向内核堆栈的指针，p-&gt;state是指向运行状态的指针。</p><p>​每个进程都有一个执行线程（或简称线程）来执行进程的指令。 一个线程可以被挂起并稍后恢复。为了在进程之间透明地切换，内核挂起当前运行的线程并恢复另一个进程的线程。 线程的大部分状态（局部变量、函数调用返回地址）都存储在线程的堆栈中。每个进程都有两个栈：<strong>用户栈</strong>和<strong>内核栈</strong>（p-&gt;kstack）。 当进程在执行用户指令时，只有它的用户栈在使用，它的内核栈是空的。当进程进入内核时（系统调用或中断），内核代码在进程的内核栈上执行； 当一个进程在内核中时，它的用户堆栈仍然包含保存的数据，但不会被主动使用。进程的线程在主动使用其用户堆栈和内核堆栈之间交替。 内核堆栈是独立的（并且不受用户代码的影响），因此即使进程破坏了其用户堆栈，内核也可以执行。<br>​进程可以通过执行RISC-V 的<code>ecall</code>指令进行系统调用。该指令提高硬件特权级别并将程序计数器更改为内核定义的入口点。入口点的代码切换到内核堆栈并执行完成系统调用的内核指令。当系统调用完成后护内核切换回用户栈，通过调用<code>sret</code>指令返回用户空间，降低硬件的特权级别，恢复执行系统调用指令的用户指令。进程的线程可以在内核中“阻塞”以等待I&#x2F;O, 并在I&#x2F;O完成后从中断恢复。</p><p>​p-&gt;state 表示进程是否已分配、准备运行、运行、等待 I&#x2F;O 或退出。</p><p>​p-&gt;pagetable 以 RISC-V 硬件期望的格式保存进程的页表。</p><p>​xv6 导致分页硬件在用户空间中执行该进程时使用该进程的 p-&gt;pagetable。 一个进程的页表同时也记录了分配给进程内存的物理页的地址。</p><p>​总而言之，一个进程捆绑了两种设计思想：地址空间让进程产生自己内存的错觉，线程让进程产生自己的 CPU 错觉。 在 xv6 中，一个进程由一个地址空间和一个线程组成。 在真实的操作系统中，一个进程可能有多个线程来利用多个 CPU。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span>&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">procstate</span> <span class="hljs-title">state</span>;</span><br>    <span class="hljs-type">void</span> *chan;<br>    <span class="hljs-type">int</span> killed;<br>    <span class="hljs-type">int</span> xstate;<br>    <span class="hljs-type">int</span> pid;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">parent</span>;</span><br>    uint64 kstack;<br>    uint64 sz;<br>    <span class="hljs-type">pagetable_t</span> pagetable;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tranfarme</span> *<span class="hljs-title">tranframe</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> <span class="hljs-title">context</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">ofile</span>[<span class="hljs-title">NOFILE</span>];</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">cwd</span>;</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">16</span>];<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpu</span>&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">proc</span>;</span> <span class="hljs-comment">//the process running on this cpu or null</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> <span class="hljs-title">context</span>;</span> <span class="hljs-comment">//swtch() here to enter scheduler()</span><br>    <span class="hljs-type">int</span> noff; <span class="hljs-comment">// depth of push_off() nesting</span><br>    <span class="hljs-type">int</span> intena; <span class="hljs-comment">// were interrupts enabled before push_off</span><br>&#125;<br><br><br><span class="hljs-keyword">struct</span> proc* <span class="hljs-title function_">myproc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    push_off();<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpu</span>* <span class="hljs-title">c</span> =</span> mycpu();<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> c -&gt; proc;<br>    pop_off();<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-keyword">struct</span> cpu* <span class="hljs-title function_">mycpu</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-type">int</span> id = cpuid();<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpu</span>* <span class="hljs-title">c</span> =</span> &amp;cpu[id];<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.6 starting xv6, the first process and system call</p><p>​为了使 xv6 更具体，我们将概述内核如何启动和运行第一个进程。 后续章节将更详细地描述本概述中出现的机制。</p><p>​当 RISC-V 计算机开机时，它会自行初始化并运行存储在ROM中的引导加载程序（bootloader.ld）。 引导加载程序将 xv6 内核加载到内存中。 然后，在机器模式下(machine mode)，CPU 从 _entry (kernel&#x2F;entry.S:7) 开始执行 xv6。 RISC-V 从禁用分页硬件开始：虚拟地址直接映射到物理地址。</p><p>​加载程序将 xv6 内核加载到物理地址 0x80000000 的内存中。 它将内核放在 0x80000000 而不是 0x0 的原因是因为地址范围 0x0:0x80000000 之间包含有 I&#x2F;O 设备。</p><p>​<code>_entry</code> 处的指令设置了一个stack，以便 xv6 可以运行 C 代码。 xv6 在文件 start.c 中为初始堆栈 stack0 声明了空间。 _entry 处的代码将堆栈指针寄存器 sp 加载到地址 stack0+4096，堆栈的顶部，因为 RISC-V 上的堆栈向下增长。 现在内核有了堆栈，entry 在开始时调用 C 代码。</p><p>​函数 <code>start</code> 执行一些只允许在机器模式下进行的配置，然后切换到管理员模式。 为了进入管理模式，RISC-V 提供了指令 <code>mret</code>。 这个指令最常用于从先前的管理模式调用返回到机器模式。 <code>start</code> 不会从这样的调用中返回，而是将事情设置为好像有一个：它在寄存器 mstatus 中将先前的特权模式设置为主管，它通过将 main 的地址写入寄存器 mepc 来将返回地址设置为 main ，通过将 0 写入页表寄存器 <code>satp</code> 来禁用管理员模式下的虚拟地址转换，并将所有中断和异常委托给管理员模式。</p><p>​在进入管理模式之前，<code>start</code>还执行一项任务，它对时钟芯片进行编程以生成定时器中断。完成这些任务处理后，通过调用<code>mret</code>开始“返回”到管理模式，这会导致程序计数器（pc）切换到main。在main初始化几个设备和子系统后，通过调用<code>userinit</code>创建第一个进程，第一个进程执行一个用RISC-V汇编编写的小程序，make进行xv6中的第一个系统调用，initcode.S将exec系统调用的编号SYS_EXEC加载到寄存器a7当中，然后调用ecall重新进入内核。</p><p>​内核在系统调用中使用寄存器<code>a7</code>中的数字来调用所需的系统调用。系统调用将SYS_EXEC映射到内核调用的sys_exec。正如我们在第一章中看到的，exec用一个新程序代替了当前进程的内存和寄存器。</p><p>​一旦内核完成exec之后，它就会在&#x2F;init进程中返回到用户空间。如果需要，init会创建一个新的控制台设备文件，然后将其以文件描述符0，1，2打开。然后它会在控制台上启动一个shell，此时系统就被启动了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">RISC-V启动时，先运行一个存储于ROM中的bootloader程序kernel.ld来加载xv6 kernel到内存中，然后在machine模式下从_entry开始运行xv6。bootloader将xv6 kernel加载到0x80000000的物理地址中，因为前面的地址中有I/O设备<br><br>在_entry中设置了一个初始stack，stack0来让xv6执行kernel/start.c。在start函数先在machine模式下做一些配置，然后通过RISC-V提供的mret指令切换到supervisor mode，使program counter切换到kernel/main.c<br><br>main先对一些设备和子系统进行初始化，然后调用kernel/proc.c中定义的userinit来创建第一个用户进程。这个进程执行了一个initcode.S的汇编程序，这个汇编程序调用了<span class="hljs-built_in">exec</span>这个system call来执行/init，重新进入kernel。<span class="hljs-built_in">exec</span>将当前进程的内存和寄存器替换为一个新的程序(/init)，当kernel执行完毕<span class="hljs-built_in">exec</span>指定的程序后，回到/init进程。/init(user/init.c)创建了一个新的console device以文件描述符0,1,2打开，然后在console device中开启了一个shell进程，至此整个系统启动了<br></code></pre></td></tr></table></figure><p>2.7 security model</p><p>您可能想知道操作系统如何处理错误或恶意代码。 因为处理恶意比处理意外错误要难得多，所以将这个主题视为与安全有关。 这是操作系统设计中典型安全假设和目标的高级视图。</p><p>​操作系统必须假定进程的用户级代码会尽最大努力来破坏内核或其他进程。用户代码可能会尝试取消引用其与允许地址空间之外的指针空间，他可能会尝试执行任何RISC-V指令。即使是那些不打算用于用户代码的指令，他可能会尝试读写任何RISC-V控制寄存器，他可能会尝试直接访问设备硬件，他可能会将巧妙地值传递给系统调用，以试图诱使内核崩溃或做一些愚蠢的事情。内核的目标是限制每个用户进程，以便所有它可以做的事read&#x2F;write&#x2F;execute自己的用户内存。使用32位通用RISC-V寄存器，并以系统调用旨在允许的方式影响内核和其他进程。内核必须阻止任何其他操作，这通常事内核设计中的绝对要求。</p><p>​对内核自身代码的期望是完全不同的。 内核代码被假定是由善意和细心的程序员编写的。 内核代码应该没有错误，当然也不包含任何恶意内容。 这个假设会影响我们分析内核代码的方式。 例如，有许多内部内核函数（例如自旋锁）如果内核代码使用不当会导致严重问题。 在检查任何特定的内核代码时，我们想要说服自己它的行为是正确的。 然而，我们假设内核代码通常是正确编写的，并且遵循关于使用内核自己的函数和数据结构的所有规则。 在硬件层面，假定 RISC-V CPU、RAM、磁盘等按照文档中宣传的方式运行，没有硬件错误.</p><p>​当然，在现实生活中的事情并没有那么简单，很难防止聪明的用户代码通过消耗内核保护的资源（磁盘空间、CPU时间、进程表等）使系统无法使用或崩溃。通常不可能编写没有错误的代码，如果恶意用户代码的编写者直到内核或硬件错误，他们就会利用这些漏洞。值得在内核中设计安全措施以防止它有错误的可能性：断言、类型检查、堆栈保护页面等。</p><p>2.8 real word</p><p>​大多数操作系统都采用了进程的概念，而且大多数进程看起来与 xv6 的类似。 然而，现代操作系统支持一个进程中的多个线程，以允许单个进程利用多个 CPU。 在一个进程中支持多个线程涉及 xv6 所没有的相当多的机制，包括潜在的接口更改（例如，Linux 的克隆，fork 的变体），以控制进程线程共享的哪些方面。</p><p>2.9 experiment</p><ol><li>在xv6中添加一个系统调用并返回还有多少可用的内存空间的大小。</li></ol><p>常见的记录空闲页的方法有：空闲表法，空闲链表法，位示图法，成组链接法。xv6使用的是空闲链表法</p><p>实现sys_info</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysinfo</span>&#123;</span><br>    uint64 freemem; <span class="hljs-comment">// amount of free memory (bytes)</span><br>    uint64 nproc; <span class="hljs-comment">//number of process</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MIT6.S081-chapter1</title>
    <link href="/2023/03/05/MIT6-S081-chapter1/"/>
    <url>/2023/03/05/MIT6-S081-chapter1/</url>
    
    <content type="html"><![CDATA[<ul><li>MIT6.S081</li><li>xv6</li><li>C</li></ul><hr><h3 id="《xv6-a-simple-Unix-like-teaching-operating-system》"><a href="#《xv6-a-simple-Unix-like-teaching-operating-system》" class="headerlink" title="《xv6: a simple, Unix-like teaching operating system》"></a>《xv6: a simple, Unix-like teaching operating system》</h3><p>一、 操作系统接口（Operating system interfaces）</p><p>​操作系统的工作是在多个程序之间共享一台计算机，并提供一个比硬件本身支持的更有用的服务集，操作系统在多个程序之间共享硬件资源，以便它们（看似）同时运行，操作系统为程序交互提供受控方式，以便它们可以共享数据或者协同工作。</p><img src="/2023/03/05/MIT6-S081-chapter1/xv6.png" class="" title="xv6架构图"><p>每个运行的程序称之为进程，由包含指令的内存，数据和栈组成。指令实行程序的计算，数据交由计算执行，栈管理程序的调度。当一个进程需要唤醒一个kernel服务，它就唤醒了一个system call，每个system call 进入内核，内核完成服务并返回。kernel使用了硬件保护机制提供给CPU，确保每个进程在自己的用户空间只能访问自己的内存。用户程序执行时没有这种特权，当一个用户程序唤醒一个系统调用时，硬件会提升权限并开始执行预先在内核中排序好的程序。内核提供的系统调用集合是用户程序看到的接口。</p><p>shell是一个原生的程序用来读取指令并执行。实际上，shell是一个用户程序，而不是内核的一部分。</p><p>1.1 processes and memory</p><p>xv6包含用户空间内存（指令、数据、栈），和内核私有的每个进程状态。当进程不再执行时xv6将存储和这些进程相关的CPU寄存器直到下一次运行这些进程，内核通过pid连接每个进程。</p><p><code>int fork()</code>：一个进程可以通过<code>fork</code>创建一个新的进程，提供相同的内存上下文包括指令和数据，但内存地址和寄存器是不一样的，父进程返回子进程的pid，子进程返回0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> pid = fork();  <span class="hljs-comment">//fork之后，父子进程同时开始判断pid的值，看哪个进程先判断好pid才会决定输出顺序。</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pid=%d\n&quot;</span>, pid);<br><span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent: child=%d\n&quot;</span>, pid);<br>pid = wait((<span class="hljs-type">int</span> *) <span class="hljs-number">0</span>); <span class="hljs-comment">//父进程发现子进程exit之后，wait执行完毕，打印输出。</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child %d is done\n&quot;</span>, pid);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child: exiting\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">//子进程在判断pid==0之后将exit,</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork error\n&quot;</span>);<br>&#125;<br><br>---<br>输出：<br>pid=<span class="hljs-number">2018356</span><br>parent:child=<span class="hljs-number">2018356</span><br>pid=<span class="hljs-number">0</span><br>child:existing<br>child <span class="hljs-number">2018356</span> is done  <span class="hljs-comment">//当子进程退出后，父进程的wait就会返回。</span><br><br></code></pre></td></tr></table></figure><p><code>int exit(int status)</code>: 系统调用会停止执行并释放资源,如内存和打开的文件,需要一个整型的状态参数，返回值0表示正常状态退出，1表示非正常状态退出。</p><p><code>int wait(int *status)</code>：系统调用返回当前进程被停止或被杀掉的子进程的状态，返回子进程的PID， 子进程的退出状态存储到 int *status这个地址中，并将状态码拷贝到内存中等待。如果调用者没有子进程，wait立即返回-1，如果父进程不在乎子进程的退出态，它可以给一个0地址给wait。父进程和子进程有着相同的内存上下文，但是在不同的内存和寄存器中执行。改变一个并不会改变另一个。如当wait的返回值被父进程存储到pid中时，它不会改变子进程中变量pid中的值，子进程中的变量pid的值还是0。</p><p><code>int exec(char *file, char *argv[])</code>:加载一个文件，获取执行它的参数，执行，如果执行错误返回-1，执行成功不返回，而是开始从文件入口位置开始执行命令。文件必须有一个特殊的格式，必须指明哪一部分是保存指令，哪一部分是数据。xv6使用的是ELF文件格式，当exec成功时，他不会返回给调用程序，相反，从文件加载的指令在 ELF 标头中声明的入口点开始执行。exec输入两个参数：文件包含的可执行文件名和一组参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//xv6 shell使用以上四个system call来为用户执行程序。在shell进程的main中主循环先通过getcmd来从用户获取命令，然后调用fork来运行一个和当前shell进程完全相同的子进程。父进程调用wait等待子进程exec执行完（在runcmd中调用exec）</span><br><br><span class="hljs-type">char</span> *argv[<span class="hljs-number">3</span>];<br>argv[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;echo&quot;</span>;<br>argv[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;hello&quot;</span>;<br>argv[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<br>exec(<span class="hljs-string">&quot;/bin/echo&quot;</span>, argv);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;exec error\n&quot;</span>);<br><span class="hljs-comment">//---------------------------------------------------</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">char</span> buf[<span class="hljs-number">100</span>];<br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-comment">// ensure that three file descriptions are open.</span><br>    <span class="hljs-keyword">while</span>(fd = open(<span class="hljs-string">&quot;console&quot;</span>, O_RDWR ) &gt;= <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(fd &gt;= <span class="hljs-number">3</span>)&#123;<br>            close(fd);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// read and run input commands</span><br>    <span class="hljs-keyword">while</span>(getcmd(buf, sizesof(buf)) &gt;= <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(buf[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;c&#x27;</span> &amp;&amp; buf[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;d&#x27;</span> &amp;&amp; buf[<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>            <span class="hljs-comment">// chdir must be called by the parent, not the child.</span><br>            buf[<span class="hljs-built_in">strlen</span>(buf) - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(chdir(buf + <span class="hljs-number">3</span>) &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;cannot cd %s\n&quot;</span>, buf + <span class="hljs-number">3</span>);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(fork1() == <span class="hljs-number">0</span>)<br>            runcmd(parsecmd(buf));<br>        wait(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>避免创建重复进程然后立即替换它的浪费,操作内核通过使用虚拟内存技术（如写时复制 copy-on-write）优化此用例的 <code>fork</code> 实现。xv6 隐式分配大部分用户空间内存：<code>fork</code> 分配父内存的子副本所需的内存，<code>exec</code> 分配足够的内存来保存可执行文件。在运行时需要更多内存的进程（可能是 <code>malloc</code>）可以调用 <code>sbrk(n)</code> 将其数据内存增加 n 字节； <code>sbrk</code> 返回新内存的位置。</p><p>1.2 输入输出和文件描述符 (I&#x2F;O and file descriptors)</p><p>文件描述符是用来表征一个进程将从哪里读取或者写入到哪里的内核管理对象。一个进程可以通过打开一个文件、目录或设备或创建一个管道，或复制一个已经存在的描述符。文件描述符接口抽象了文件、管道和设备之间的差异，使它们看起来都像字节流。xv6 内核使用文件描述符作为每个进程表的索引，因此每个进程都有一个从零开始的文件描述符的私有空间。每个进程都拥有自己独立的文件描述符列表，<strong>其中0是标准输入，1是标准输出，2是标准错误</strong>。shell将保证总是有3个文件描述符是可用的。</p><p><code>int read(int fd, char * buf, int n)</code>; 从文件描述符<code>fd</code>中读取n字节的数据拷贝到<code>buf</code>中，<strong>返回值是读取的字节数</strong>。每个文件描述符都有一个与之相关的offset。read 从当前文件偏移量读取数据，然后将该偏移量增加读取的字节数，下一个<code>read</code>将从新的<code>offset</code>开始读取字节，当没有更多的字节可以读取时，<code>read</code>返回0来表示读取到文件的结束。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSGSIZE 16</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[])</span>&#123;<br>    <span class="hljs-type">char</span> buf[MEGSIZE];<br>    read(<span class="hljs-number">0</span>, buf, MSGSIZE); <span class="hljs-comment">//获取前一个命令的标准化输出，即当前命令的标准化输入</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;获取到的标准化输入:%s\n&quot;</span>, buf);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>int write(int fd, char *buf,int n)</code>；从buf中写入n字节的数据到文件描述符fd中，返回值是有多少的字节数据被写入。当少于n个字节的数据被写入时互出现错误，通read一样存在偏移量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//cat命令的实现</span><br><span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>];<br><span class="hljs-type">int</span> n;<br><span class="hljs-keyword">for</span>(;;)&#123;<br>    n = read(<span class="hljs-number">0</span>, buf, <span class="hljs-keyword">sizeof</span> buf);<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;read error\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(write(<span class="hljs-number">1</span>, buf, n) != n)&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;write error\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>int close(int fd)</code>:系统调用，释放一个文件描述符，让它变得可以被未来的open pipe 或者dup系统调用使用。</p><p><code>fork</code>拷贝父进程的文件描述符到自己的内存空间中，因此子进程可以像父进程一样打开文件，<code>exec</code>代替了调用进程的内存，但是将它保留在文件表中。父进程的<code>fd table</code>将不会被子进程<code>fd table</code>的变化影响，但是文件中的<code>offset</code>将被共享。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// cat 命令的实现 cat &lt; input.txt</span><br><span class="hljs-type">char</span> *argv[<span class="hljs-number">2</span>];<br>argv[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;cat&quot;</span>;<br>argv[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>)&#123;<br>    close(<span class="hljs-number">0</span>);<br>    open(<span class="hljs-string">&quot;input.txt&quot;</span>, O_RDONLY);<br>    exec(<span class="hljs-string">&quot;cat&quot;</span>, argv);<br>&#125;<br></code></pre></td></tr></table></figure><p>关键字： O_RDONLY：打开文件for reading, OWRONLY:打开文件for writting, , ORDWR:打开文件for reading and writting , O_CREATE:如果文件不存在，就创造它, O_TRUNC：将文件截断到0的长度。</p><p><code>int dup(int fd)</code>:系统调用，返回一个引用相同底层 I&#x2F;O 对象的新对象。两个文件描述符共享一个偏移量，就像 fork 复制的文件描述符一样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// another way to write hello world</span><br>fd = dup(<span class="hljs-number">1</span>);<br>write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;hello &quot;</span>, <span class="hljs-number">6</span>);<br>write(fd, <span class="hljs-string">&quot;world\n&quot;</span>, <span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure><p>如果两个文件描述符是通过一系列 <code>fork</code> 和 <code>dup</code> 调用从同一个原始文件描述符派生的，则它们共享一个偏移量,否则文件描述符不共享偏移量，即使它们来自对同一文件的打开调用。<code>dup</code> 允许shell去实现一个这样的命令： ls existing-file non-existing-file &gt; tmp1 2 &gt;&amp;1, 2&gt;&amp;1 告诉 shell 给命令一个文件描述符 2，它是描述符 1 的副本。现有文件的名称和不存在文件的错误消息都将显示在文件 tmp1 中.xv6 shell 不支持错误文件描述符的 I&#x2F;O 重定向，但现在你知道如何实现它了。</p><p>1.3管道</p><p>管道是一个小的内核缓冲区，作为一对文件描述符暴露给进程，一个用于读取，一个用于写入。将数据写入管道的一端使该数据可用于从管道的另一端读取。 管道为进程提供了一种通信方式。（FIFO实现）</p><p><code>int pipe(int p[])</code>:p[0]为读取的fd,p[1]为写入的fd。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//以下示例代码运行程序 wc，标准输入连接到管道的读取端。</span><br><span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br><span class="hljs-type">char</span> *argv[<span class="hljs-number">2</span>];<br>argv[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;wc&quot;</span>;<br>argv[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>pipe(p);<br><span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>)&#123;<br>    close(<span class="hljs-number">0</span>);<br>    dup(p[<span class="hljs-number">0</span>]);<br>    close(p[<span class="hljs-number">0</span>]);<br>    close(p[<span class="hljs-number">1</span>]);<br>    exec(<span class="hljs-string">&quot;/bin/wc&quot;</span>, argv);<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>    close(p[<span class="hljs-number">0</span>]);<br>    write(p[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;hello world\n&quot;</span>, <span class="hljs-number">12</span>);<br>    close(p[<span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-comment">//这段程序叫做pipe，它创造了一个新的管道来记录读和写的文件描述符在数组p中。在fork之后，父进程和子进程都会有文件描述符指向这个管道，子进程调用close和dup来让文件描述符0引用管道的读取端，关闭文件描述符，之后调用exec执行wc指令，当wc读取它的标准输入时，它从管道读取，父进程关闭了管道的读取端，写管道，然后关闭写端。</span><br></code></pre></td></tr></table></figure><p>如果没有数据可用，则管道上的读取等待写入数据或关闭引用写入端的所有文件描述符； 在后一种情况下，read 将返回 0，就像已到达数据文件的末尾一样。 读取阻塞直到新数据不可能到达的事实是子进程在执行上面的 wc 之前关闭管道的写入端很重要的一个原因：如果 wc 的文件描述符之一引用了写入端管道，wc永远看不到文件结束。</p><p>xv6的shell实现一个这样的命令： <code>grep fork sh.c | wc -l</code>，子进程创建一个管道来连接管道的左端和右端。之后在管道左端调用fork和runcmd指令，在管道右端调用fork和runcmd指令，然后等待两边都结束。管道的右端可能是一个命令，它本身包含一个管道（例如，a | b | c），它本身会派生两个新的子进程（一个用于 b，一个用于 c）。因此，shell 可以创建一个进程树。这棵树的叶子节点是命令，内部节点是等待左右子节点完成的进程。原则上，可以让内部节点运行在管道的左端，但如果这样做正确的话会使实施变得复杂。考虑仅进行以下修改：<br>将 sh.c 更改为不分叉 <code>p-&gt;left</code> 并在内部进程中运行 <code>runcmd(p-&gt;left)</code>。之后例如：<code>echo hi | wc</code>不会产生输出，因为在<code>runcmd</code>中echo hi退出时，内部进程退出，从不调用fork运行右端管道,这种不正确的行为可以通过不在 runcmd 中为内部进程调用 exit 来修复，但此修复使代码复杂化：现在 <code>runcmd</code> 需要知道它是否在内部进程中。当不分叉 <code>runcmd(p-&gt;right)</code> 时也会出现并发症。例如，仅进行该修改，<code>sleep 10 | echo hi</code> 将立即打印“hi”和一个新提示，而不是在 10 秒后； 发生这种情况是因为 echo 立即运行并退出，而不是等待 sleep 完成。由于 sh.c 的目标是尽可能简单，它不会试图避免创建内部进程。</p><p>在这种情况下，管道比临时文件至少有四个优势。第一：管道会自动清理自己，使用文件重定向，shell必须小心删除&#x2F;tmp&#x2F;xyz当它执行完成后。其次，管道可以传递任意长的数据流，而文件重定向需要磁盘上有足够的可用空间来存储所有数据。 第三、管道允许管道并行执行阶段，而文件方法要求第一个程序在第二个程序开始之前完成。 第四，如果你正在实现进程间通信，管道的阻塞读写比文件的非阻塞语义更高效。</p><p>1.4文件系统</p><p>xv6 文件系统提供数据文件，其中包含未解释的字节数组（byte array）和目录，其中包含对数据文件和其他目录的命名引用。这些目录形成一棵树，从称为root的特殊目录开始。不以 &#x2F; 开头的路径是相对于调用进程的当前目录进行评估的（相对路径），该目录可以通过 <code>chdir</code> 系统调用进行更改。这两个代码片段都打开同一个文件（假设所有涉及的目录都存在)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">chdir(<span class="hljs-string">&quot;/a&quot;</span>);<br>chdir(<span class="hljs-string">&quot;b&quot;</span>);<br>open(<span class="hljs-string">&quot;c&quot;</span>, O_RDONLY);<br>open(<span class="hljs-string">&quot;/a/b/c&quot;</span>, O_RDONLY);<br><span class="hljs-comment">//第一个片段将进程的当前目录更改为/a/b； 第二个既不引用也不更改进程的当前目录。</span><br></code></pre></td></tr></table></figure><p>有创建新文件和目录的系统调用：<code>mkdir</code> 创建新目录，使用 <code>O_CREATE</code> 标志打开创建新数据文件，<code>mknod</code> 创建新设备文件。 这个例子说明了所有三个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">mkdir(<span class="hljs-string">&quot;/dir&quot;</span>);<br>fd = open(<span class="hljs-string">&quot;/dir/file&quot;</span>, O_CREATE|O_WRONLY);<br>close(fd);<br>mknod(<span class="hljs-string">&quot;/console&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p><code>mknod</code> 创建一个引用设备的特殊文件,与设备文件相关联的是主设备号（major device）和次设备号(minor device),通过这两个参数唯一的确定这个设备，<code>mknod</code> 的两个参数，它们唯一地标识内核设备。当进程稍后打开设备文件时，内核将read和write系统调用转移到这个内核设备上，而不是将它们传递给文件系统。</p><p>文件名与文件本身不同； 同一个底层文件，称为索引节点（<code>inode</code>），可以有多个名称，称为links。每个link都包含目录中的一个条目； 该条目包含一个文件名称和对 <code>inode</code> 的引用。<code>inode</code> 保存有关文件的元数据，包括其类型（文件或目录或设备）、长度、文件内容在磁盘上的位置以及文件的链接数。</p><p><code>int fstat(int fd, struct stat *st)</code> ：系统调用从文件描述符<strong>fd</strong>引用的 <code>inode</code> 检索信息，将<code>inode</code>中的相关信息存储到<strong>st</strong>中。执行成功返回0， 失败返回-1。在 stat.h (kernel&#x2F;stat.h) 中定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span>  T_DIR 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> T_FILE 2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> T_DEVICE 3</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span>&#123;</span><br>    <span class="hljs-type">int</span> dev; <span class="hljs-comment">//file system&#x27;s disk device</span><br>    uint ino; <span class="hljs-comment">//inode number</span><br>    <span class="hljs-type">short</span> type; <span class="hljs-comment">//type of file</span><br>    <span class="hljs-type">short</span> nlink; <span class="hljs-comment">// number of links to file</span><br>    uint64 size; <span class="hljs-comment">//size of file in bytes</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>link</code>:系统调用，创建一个指向同一个<code>inode</code>的文件名。<code>unlink</code>则是将一个文件名从文件系统中移除，只有当指向这个<code>inode</code>的文件名的数量为0时，这个<code>inode</code>以及其存储的文件内容才会被从硬盘上移除。 此片段创建一个名为 a 和 b 的新文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">open(<span class="hljs-string">&quot;a&quot;</span>, O_CREATE|O_WRONLY);<br>link(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>);<br></code></pre></td></tr></table></figure><p>从 a 读取或写入 a 与从 b 读取或写入相同。每个 <code>inode</code> 都由唯一的 <code>inode</code> 编号标识。在上面的代码执行之后，可以通过检查 fstat 的结果来确定 a 和 b 引用相同的底层内容：两者都将返回相同的 <code>inode</code> 号（ino），并且 nlink 计数将设置为 2。<code>unlink</code> 系统调用从文件系统中删除一个名称。 只有当文件的链接计数为零并且没有文件描述符引用它时，文件的索引节点和保存其内容的磁盘空间才会被释放。 从而添加 <code>unlink(&quot;a&quot;)；</code>到最后一个代码序列使 <code>inode</code> 和文件内容可访问为 b。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">fd = open(<span class="hljs-string">&quot;/tmp/xyz&quot;</span>, O_CREATE|O_RDWR);<br>unlink(<span class="hljs-string">&quot;/tmp/xyz&quot;</span>);<br></code></pre></td></tr></table></figure><p>以上代码是创建一个没有名称的临时 <code>inode</code> 的惯用方法，当进程关闭 fd 或退出时将被清理。</p><p>Unix 提供可从 shell 调用的文件实用程序作为用户级程序，例如 <code>mkdir</code>、<code>ln</code> 和 <code>rm</code>等。这种设计允许任何人通过添加新的用户级程序来扩展命令行界面。事后看来，这个计划似乎很明显，但在 Unix 时代设计的其他系统通常将此类命令内置到 shell 中（并将 shell 内置到内核中）。一个例外是 cd，它内置于 shell (user&#x2F;sh.c:160) 中。 cd 必须更改 shell 本身的当前工作目录。 如果 cd 作为常规命令运行，则 shell 将派生一个子进程，子进程将运行 cd，而 cd 将更改子进程的工作目录。 父级（即 shell 的）工作目录不会改变。</p><p>1.5 Real world</p><p>Unix 将“标准”文件描述符、管道和用于操作它们的方便的 shell 语法相结合，这是编写通用可重用程序的重大进步。 这个想法引发了一场 “软件工具”文化,也是 Unix 强大和流行的主要原因，而 shell 是第一个所谓的“脚本语言”。 Unix 系统调用接口今天在 BSD、Linux 和 macOS 等系统中仍然存在。Unix 系统调用接口已通过可移植操作系统接口 (POSIX) 标准进行了标准化。xv6 不符合 POSIX：它缺少许多系统调用（包括基本的系统调用，例如 <code>lseek</code>），并且它提供的许多系统调用与标准不同。 xv6 的主要目标是简单明了，同时提供简单的类 UNIX 系统调用接口。 为了运行基本的 Unix 程序，一些人用更多的系统调用和一个简单的 C 库扩展了 xv6。然而，与 xv6 相比，现代内核提供了更多的系统调用和更多种类的内核服务。 例如，它们支持网络、窗口系统、用户级线程、许多设备的驱动程序等等。 现代内核不断快速发展，并提供许多超越 POSIX 的功能。</p><p>Unix 使用一组文件名和文件描述符接口统一访问多种类型的资源（文件、目录和设备）。 这个想法可以扩展到更多种类的资源；一个很好的例子是Plan 9，它将“资源是文件”的概念应用于网络、图形等。然而，大多数 Unix 派生的操作系统并没有遵循这条路线。</p><p>文件系统和文件描述符是强大的抽象。 即便如此，还有其他操作系统接口模型。 Multics 是 Unix 的前身，它以一种使文件存储看起来像内存的方式抽象了文件存储，从而产生了一种截然不同的界面风格。 Multics 设计的复杂性直接影响了 Unix 的设计者，他们试图构建更简单的东西。</p><p>Xv6 不提供用户或保护一个用户免受另一个用户侵害的概念； 在 Unix 术语中，所有 xv6 进程都以 root 身份运行。</p><p>1.6 Exercises</p><p>“乒乓”：创建两个进程在管道的两端，父进程发送字节到子进程，子进程接收到字节打印自己的pid和recevied ping，然后通过管道写字节到父进程，父进程接收到后打印pid和recevied pong然后退出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#includeuser/user .h<span class="hljs-string">&quot;</span></span><br><span class="hljs-string"><span class="hljs-meta">const int MESSAGE_SIZE = 7;</span></span><br><span class="hljs-string"><span class="hljs-meta">int main(int argc, char *argv[])&#123;</span></span><br><span class="hljs-string"><span class="hljs-meta">    int fd[2];</span></span><br><span class="hljs-string"><span class="hljs-meta">    char buf[MESSAGE_SIZE];</span></span><br><span class="hljs-string"><span class="hljs-meta">    pipe(fd);</span></span><br><span class="hljs-string"><span class="hljs-meta">    int pid = fork();</span></span><br><span class="hljs-string"><span class="hljs-meta">    if(pid &gt; 0)&#123;</span></span><br><span class="hljs-string"><span class="hljs-meta">        write(fd[1], &quot;</span>114514<span class="hljs-string">&quot;, 6);</span></span><br><span class="hljs-string"><span class="hljs-meta">        read(fd[0], buf, 6);</span></span><br><span class="hljs-string"><span class="hljs-meta">        printf(&quot;</span>%d: received pong\n<span class="hljs-string">&quot;, getpid());</span></span><br><span class="hljs-string"><span class="hljs-meta">        exit(0);</span></span><br><span class="hljs-string"><span class="hljs-meta">    &#125;else&#123;</span></span><br><span class="hljs-string"><span class="hljs-meta">        read(fd[0], buf, 6);</span></span><br><span class="hljs-string"><span class="hljs-meta">        printf(&quot;</span>%d: received ping\n<span class="hljs-string">&quot;, getpid());</span></span><br><span class="hljs-string"><span class="hljs-meta">        write(fd[1], &quot;</span>114514<span class="hljs-string">&quot;, 6);</span></span><br><span class="hljs-string"><span class="hljs-meta">        exit(0);</span></span><br><span class="hljs-string"><span class="hljs-meta">    &#125;</span></span><br><span class="hljs-string"><span class="hljs-meta">&#125;</span></span><br></code></pre></td></tr></table></figure><p>素数筛法：使用pipe和fork实现流水线，将一组数范围为2到35喂入到一个进程中，先打印出最小的一个数，这个数是素数，之后用其他的数来除这个素数，如果可以整除则将其drop，不能整除的喂入到下一个进程，直到打印出所有的素数。</p><p>实现find：使用递归的方式找到指定的文件夹下的目标文件，参考user&#x2F;ls.c实现方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// hints:1.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> &#123;</span><br>    ushort inum;<br>    <span class="hljs-type">char</span> name[DIRSIZE];<br>&#125;<br><span class="hljs-comment">//hints:2.</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">memmove</span><span class="hljs-params">(<span class="hljs-type">void</span> *str1, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *str2, <span class="hljs-type">size_t</span> n)</span>;<span class="hljs-comment">//从str2复制n个字符到str1，返回一个指向目标存储区str1的指针。</span><br></code></pre></td></tr></table></figure><p>实现xargs：</p><p><code>xargs</code>的作用是把stdin中的数据用空格或回车分割成命令行参数</p><p>例：<code>find .-name &#39;*.py&#39; | xargs cat | wc -l</code> :统计当前目录下所有python文件的总行数</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/12/14/hello-world/"/>
    <url>/2022/12/14/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
